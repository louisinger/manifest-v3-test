{"version":3,"file":"blech32.cjs.production.min.js","sources":["../src/utils.ts","../src/blech32.ts","../src/blech32Addr.ts"],"sourcesContent":["export function convertBits(\n  bytes: number[],\n  from: number,\n  to: number,\n  pad: boolean\n): number[] {\n  if (from < 1 || from > 8 || to < 1 || from > 8) {\n    throw new Error(\"only bits groups between 1 and 8 are allowed\");\n  }\n\n  const regrouped: number[] = [];\n\n  let nextByte = 0;\n  let filledBits = 0;\n\n  for (const n of bytes) {\n    let b = n << (8 - from);\n    // How many bits remaining to extract from the input data.\n    let remFromBits = from;\n    while (remFromBits > 0) {\n      // How many bits remaining to be added to the next byte.\n      const remToBits = to - filledBits;\n\n      // The number of bytes to next extract is the minimum of\n      // remFromBits and remToBits.\n      let toExtract = remFromBits;\n      if (remToBits < toExtract) {\n        toExtract = remToBits;\n      }\n\n      // Add the next bits to nextByte, shifting the already\n      // added bits to the left.\n      nextByte = (nextByte << toExtract) | (b >> (8 - toExtract));\n\n      // Discard the bits we just extracted and get ready for\n      // next iteration.\n      b = (b << toExtract) % 256;\n      remFromBits -= toExtract;\n      filledBits += toExtract;\n\n      // If the nextByte is completely filled, we add it to\n      // our regrouped bytes and start on the next byte.\n      if (filledBits === to) {\n        regrouped.push(nextByte);\n        filledBits = 0;\n        nextByte = 0;\n      }\n    }\n  }\n\n  // We pad any unfinished group if specified.\n  if (pad && filledBits > 0) {\n    nextByte = nextByte << (to - filledBits);\n    regrouped.push(nextByte);\n    filledBits = 0;\n    nextByte = 0;\n  }\n\n  // Any incomplete group must be <= 4 bits, and all zeroes.\n  if (filledBits > 0 && (filledBits > 4 || nextByte !== 0)) {\n    throw new Error(\"invalid incomplete group of bits\");\n  }\n\n  return regrouped;\n}\n\nexport function validateWitnessVersion(version: number): void {\n  if (version < 0 || version > 16) {\n    throw new Error(\"invalid witness version\");\n  }\n}\n","import Long from \"long\";\nimport { validateWitnessVersion } from \"./utils\";\n\nconst CHARSET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\";\nexport const MAX_LEN = 1000;\n\nfunction hexToLong(hex: string): Long.Long {\n  return Long.fromString(hex, true, 16);\n}\n\nconst GENERATORS = [\n  \"7d52fba40bd886\",\n  \"5e8dbf1a03950c\",\n  \"1c3a3c74072a18\",\n  \"385d72fa0e5139\",\n  \"7093e5a608865b\"\n].map(hexToLong);\n\nexport type EncodingType = \"blech32\" | \"blech32m\";\nexport const BLECH32: EncodingType = \"blech32\";\nexport const BLECH32M: EncodingType = \"blech32m\";\n\nexport function getEncodingType(witnessVersion: number): EncodingType {\n  validateWitnessVersion(witnessVersion);\n  if (witnessVersion === 0) {\n    return BLECH32;\n  } else if (witnessVersion === 1) {\n    return BLECH32M;\n  } else {\n    throw new Error(\n      `Unsuported witness version (${witnessVersion}), only 0 (blech32) or 1 (blech32m) are supported`\n    );\n  }\n}\n\nfunction getEncodingConst(enc: EncodingType): Long.Long {\n  if (enc === BLECH32) {\n    return Long.fromNumber(1);\n  } else if (enc === BLECH32M) {\n    return hexToLong(\"455972a3350f7a1\");\n  } else {\n    throw new Error(\"Invalid encoding type\");\n  }\n}\n\nfunction polymod(values: number[]): Long.Long {\n  let chk = Long.fromNumber(1);\n  for (let p = 0; p < values.length; ++p) {\n    const top = chk.shiftRight(55);\n    chk = chk\n      .and(hexToLong(\"7fffffffffffff\"))\n      .shiftLeft(5)\n      .xor(values[p]);\n    for (let i = 0; i < 5; i++) {\n      if (\n        top\n          .shiftRight(Long.fromNumber(i))\n          .and(1)\n          .equals(1)\n      ) {\n        chk = chk.xor(GENERATORS[i]);\n      }\n    }\n  }\n  return chk;\n}\n\nfunction hrpExpand(hrp: string): Uint8Array {\n  const ret: number[] = [];\n\n  for (let p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) >> 5);\n  }\n\n  ret.push(0);\n\n  for (let p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) & 31);\n  }\n  return Uint8Array.from(ret);\n}\n\nfunction verifyChecksum(\n  hrp: string,\n  data: number[],\n  enc: EncodingType\n): boolean {\n  const hrpAndData = Array.from(hrpExpand(hrp)).concat(data);\n  return polymod(hrpAndData).equals(getEncodingConst(enc));\n}\n\nconst zeros = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\nfunction createChecksum(\n  hrp: string,\n  data: Uint8Array,\n  enc: EncodingType\n): number[] {\n  const values = Array.from(hrpExpand(hrp))\n    .concat(Array.from(data))\n    .concat(zeros); // concat 12 zero\n\n  const mod = polymod(values).xor(getEncodingConst(enc));\n\n  const ret: Long.Long[] = [];\n  for (let p = 0; p < 12; ++p) {\n    ret.push(mod.shiftRight(5 * (11 - p)).and(31));\n  }\n  return ret.map(long => long.toInt());\n}\n\n// blech32 encode function\nexport function encode(\n  hrp: string,\n  data: Uint8Array,\n  enc: EncodingType\n): string {\n  const checkSum = createChecksum(hrp, data, enc);\n\n  const combined = Array.from(data).concat(checkSum);\n  let ret = hrp + \"1\";\n  for (let p = 0; p < combined.length; ++p) {\n    ret += CHARSET.charAt(combined[p]);\n  }\n  return ret;\n}\n\n// blech32 decode function\nexport function decode(\n  blechString: string,\n  enc: EncodingType\n): { hrp: string; data: Uint8Array } {\n  let has_lower = false;\n  let has_upper = false;\n  for (let p = 0; p < blechString.length; ++p) {\n    if (blechString.charCodeAt(p) < 33 || blechString.charCodeAt(p) > 126) {\n      throw new Error(\"Invalid charcode in blech32 string\");\n    }\n    if (blechString.charCodeAt(p) >= 97 && blechString.charCodeAt(p) <= 122) {\n      has_lower = true;\n    }\n    if (blechString.charCodeAt(p) >= 65 && blechString.charCodeAt(p) <= 90) {\n      has_upper = true;\n    }\n  }\n  if (has_lower && has_upper) {\n    throw new Error(\"blech32 has lowercases AND uppercases\");\n  }\n\n  blechString = blechString.toLowerCase();\n  const pos = blechString.lastIndexOf(\"1\");\n  if (pos < 1 || pos + 13 > blechString.length) {\n    throw new Error('Invalid index of \"1\"');\n  }\n  const hrp = blechString.substring(0, pos);\n  const data: number[] = [];\n  for (let p = pos + 1; p < blechString.length; ++p) {\n    const d = CHARSET.indexOf(blechString.charAt(p));\n    if (d === -1) {\n      throw new Error(\n        `\"${blechString.charAt(p)}\" is not allowed in blech32 strings`\n      );\n    }\n    data.push(d);\n  }\n\n  if (!verifyChecksum(hrp, data, enc)) {\n    throw new Error(`invalid ${enc} checksum \"${blechString}\"`);\n  }\n\n  return { hrp: hrp, data: Uint8Array.from(data.slice(0, data.length - 12)) };\n}\n","import { EncodingType } from \".\";\nimport { decode, encode, MAX_LEN, getEncodingType } from \"./blech32\";\nimport { convertBits, validateWitnessVersion } from \"./utils\";\n\ninterface Blech32AddressData {\n  witness: string;\n  blindingPublicKey: string;\n  witnessVersion: number;\n  hrp: string;\n}\n\n/**\n * encodeAddress encodes data\n * @param hrp human readeable part\n * @param witnessProgram witnessProgram = pubkey + witness\n * @param witnessVersion witness version\n */\nfunction encodeAddress({\n  witness,\n  witnessVersion,\n  blindingPublicKey,\n  hrp\n}: Blech32AddressData): string {\n  validateWitnessVersion(witnessVersion);\n\n  const witnessProgram = Buffer.concat([\n    Buffer.from(blindingPublicKey, \"hex\"),\n    Buffer.from(witness, \"hex\")\n  ]);\n  const witnessProgLength = witnessProgram.length;\n\n  if (\n    witnessVersion === 0 &&\n    witnessProgLength !== 53 &&\n    witnessProgLength !== 65\n  )\n    throw new Error(\n      \"witness version 0 needs witness program length = 53 OR = 65\"\n    );\n\n  if (witnessProgLength < 2 || witnessProgLength > 65)\n    throw new Error(\"witness program length should be >= 2 and <= 65\");\n\n  const data = [\n    witnessVersion,\n    ...convertBits(Array.from(witnessProgram), 8, 5, true)\n  ];\n  return encode(hrp, Uint8Array.from(data), getEncodingType(data[0]));\n}\n\n/**\n * decodeAddress decodes a segwit string address.\n * @param addr the blech32 encoded string.\n * @param encodingType the encoding type.\n */\nfunction decodeAddress(addr: string, enc: EncodingType): Blech32AddressData {\n  const { hrp, data } = decode(addr, enc);\n\n  const witnessVersion = data[0];\n  validateWitnessVersion(witnessVersion);\n\n  if (data.length === 0 || data.length > MAX_LEN)\n    throw new Error(\"Invalid data length\");\n\n  const witnessProgram = convertBits(Array.from(data.slice(1)), 5, 8, false);\n  if (witnessProgram.length < 2 || witnessProgram.length > 65)\n    throw new Error(\"Invalid witness data length\");\n\n  if (\n    data[0] === 0 &&\n    witnessProgram.length !== 53 &&\n    witnessProgram.length !== 65\n  )\n    throw new Error(\"Invalid witness data length for witness version 0\");\n\n  const blindingPublicKey = Buffer.from(witnessProgram.slice(0, 33)).toString(\n    \"hex\"\n  );\n  const witness = Buffer.from(witnessProgram.slice(33)).toString(\"hex\");\n\n  return {\n    witness,\n    blindingPublicKey,\n    witnessVersion,\n    hrp\n  };\n}\n\n/**\n * a class wrapping the encodeAddress and decodeAddress functions.\n */\nexport class Blech32Address {\n  address: string;\n  witnessVersion: number;\n  blindingPublicKey: string;\n  witness: string;\n\n  private constructor(data: Blech32AddressData) {\n    this.witness = data.witness;\n    this.blindingPublicKey = data.blindingPublicKey;\n    this.witnessVersion = data.witnessVersion;\n    this.address = encodeAddress(data);\n  }\n\n  static from(\n    witness: string,\n    blindingPublicKey: string,\n    hrp: string,\n    witnessVersion: number\n  ) {\n    return new Blech32Address({\n      witness,\n      witnessVersion,\n      blindingPublicKey,\n      hrp\n    });\n  }\n\n  static fromString(\n    blechString: string,\n    encodingType: EncodingType\n  ): Blech32Address {\n    return new Blech32Address(decodeAddress(blechString, encodingType));\n  }\n}\n"],"names":["convertBits","bytes","from","to","pad","Error","regrouped","nextByte","filledBits","b","remFromBits","remToBits","toExtract","push","validateWitnessVersion","version","CHARSET","hexToLong","hex","Long","fromString","GENERATORS","map","getEncodingType","witnessVersion","getEncodingConst","enc","fromNumber","polymod","values","chk","p","length","top","shiftRight","and","shiftLeft","xor","i","equals","hrpExpand","hrp","ret","charCodeAt","Uint8Array","zeros","encode","data","checkSum","mod","Array","concat","long","toInt","createChecksum","combined","charAt","decode","blechString","has_lower","has_upper","pos","toLowerCase","lastIndexOf","substring","d","indexOf","verifyChecksum","slice","Blech32Address","witness","blindingPublicKey","address","witnessProgram","Buffer","witnessProgLength","encodeAddress","encodingType","addr","toString","decodeAddress"],"mappings":"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"}