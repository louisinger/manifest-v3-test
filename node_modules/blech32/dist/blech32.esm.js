import Long from 'long';

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function convertBits(bytes, from, to, pad) {
  if (from < 1 || from > 8 || to < 1 || from > 8) {
    throw new Error("only bits groups between 1 and 8 are allowed");
  }

  var regrouped = [];
  var nextByte = 0;
  var filledBits = 0;

  for (var _iterator = _createForOfIteratorHelperLoose(bytes), _step; !(_step = _iterator()).done;) {
    var n = _step.value;
    var b = n << 8 - from; // How many bits remaining to extract from the input data.

    var remFromBits = from;

    while (remFromBits > 0) {
      // How many bits remaining to be added to the next byte.
      var remToBits = to - filledBits; // The number of bytes to next extract is the minimum of
      // remFromBits and remToBits.

      var toExtract = remFromBits;

      if (remToBits < toExtract) {
        toExtract = remToBits;
      } // Add the next bits to nextByte, shifting the already
      // added bits to the left.


      nextByte = nextByte << toExtract | b >> 8 - toExtract; // Discard the bits we just extracted and get ready for
      // next iteration.

      b = (b << toExtract) % 256;
      remFromBits -= toExtract;
      filledBits += toExtract; // If the nextByte is completely filled, we add it to
      // our regrouped bytes and start on the next byte.

      if (filledBits === to) {
        regrouped.push(nextByte);
        filledBits = 0;
        nextByte = 0;
      }
    }
  } // We pad any unfinished group if specified.


  if (pad && filledBits > 0) {
    nextByte = nextByte << to - filledBits;
    regrouped.push(nextByte);
    filledBits = 0;
    nextByte = 0;
  } // Any incomplete group must be <= 4 bits, and all zeroes.


  if (filledBits > 0 && (filledBits > 4 || nextByte !== 0)) {
    throw new Error("invalid incomplete group of bits");
  }

  return regrouped;
}
function validateWitnessVersion(version) {
  if (version < 0 || version > 16) {
    throw new Error("invalid witness version");
  }
}

var CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var MAX_LEN = 1000;

function hexToLong(hex) {
  return Long.fromString(hex, true, 16);
}

var GENERATORS = /*#__PURE__*/["7d52fba40bd886", "5e8dbf1a03950c", "1c3a3c74072a18", "385d72fa0e5139", "7093e5a608865b"].map(hexToLong);
var BLECH32 = "blech32";
var BLECH32M = "blech32m";
function getEncodingType(witnessVersion) {
  validateWitnessVersion(witnessVersion);

  if (witnessVersion === 0) {
    return BLECH32;
  } else if (witnessVersion === 1) {
    return BLECH32M;
  } else {
    throw new Error("Unsuported witness version (" + witnessVersion + "), only 0 (blech32) or 1 (blech32m) are supported");
  }
}

function getEncodingConst(enc) {
  if (enc === BLECH32) {
    return Long.fromNumber(1);
  } else if (enc === BLECH32M) {
    return hexToLong("455972a3350f7a1");
  } else {
    throw new Error("Invalid encoding type");
  }
}

function polymod(values) {
  var chk = Long.fromNumber(1);

  for (var p = 0; p < values.length; ++p) {
    var top = chk.shiftRight(55);
    chk = chk.and(hexToLong("7fffffffffffff")).shiftLeft(5).xor(values[p]);

    for (var i = 0; i < 5; i++) {
      if (top.shiftRight(Long.fromNumber(i)).and(1).equals(1)) {
        chk = chk.xor(GENERATORS[i]);
      }
    }
  }

  return chk;
}

function hrpExpand(hrp) {
  var ret = [];

  for (var p = 0; p < hrp.length; ++p) {
    ret.push(hrp.charCodeAt(p) >> 5);
  }

  ret.push(0);

  for (var _p = 0; _p < hrp.length; ++_p) {
    ret.push(hrp.charCodeAt(_p) & 31);
  }

  return Uint8Array.from(ret);
}

function verifyChecksum(hrp, data, enc) {
  var hrpAndData = Array.from(hrpExpand(hrp)).concat(data);
  return polymod(hrpAndData).equals(getEncodingConst(enc));
}

var zeros = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

function createChecksum(hrp, data, enc) {
  var values = Array.from(hrpExpand(hrp)).concat(Array.from(data)).concat(zeros); // concat 12 zero

  var mod = polymod(values).xor(getEncodingConst(enc));
  var ret = [];

  for (var p = 0; p < 12; ++p) {
    ret.push(mod.shiftRight(5 * (11 - p)).and(31));
  }

  return ret.map(function (_long) {
    return _long.toInt();
  });
} // blech32 encode function


function encode(hrp, data, enc) {
  var checkSum = createChecksum(hrp, data, enc);
  var combined = Array.from(data).concat(checkSum);
  var ret = hrp + "1";

  for (var p = 0; p < combined.length; ++p) {
    ret += CHARSET.charAt(combined[p]);
  }

  return ret;
} // blech32 decode function

function decode(blechString, enc) {
  var has_lower = false;
  var has_upper = false;

  for (var p = 0; p < blechString.length; ++p) {
    if (blechString.charCodeAt(p) < 33 || blechString.charCodeAt(p) > 126) {
      throw new Error("Invalid charcode in blech32 string");
    }

    if (blechString.charCodeAt(p) >= 97 && blechString.charCodeAt(p) <= 122) {
      has_lower = true;
    }

    if (blechString.charCodeAt(p) >= 65 && blechString.charCodeAt(p) <= 90) {
      has_upper = true;
    }
  }

  if (has_lower && has_upper) {
    throw new Error("blech32 has lowercases AND uppercases");
  }

  blechString = blechString.toLowerCase();
  var pos = blechString.lastIndexOf("1");

  if (pos < 1 || pos + 13 > blechString.length) {
    throw new Error('Invalid index of "1"');
  }

  var hrp = blechString.substring(0, pos);
  var data = [];

  for (var _p2 = pos + 1; _p2 < blechString.length; ++_p2) {
    var d = CHARSET.indexOf(blechString.charAt(_p2));

    if (d === -1) {
      throw new Error("\"" + blechString.charAt(_p2) + "\" is not allowed in blech32 strings");
    }

    data.push(d);
  }

  if (!verifyChecksum(hrp, data, enc)) {
    throw new Error("invalid " + enc + " checksum \"" + blechString + "\"");
  }

  return {
    hrp: hrp,
    data: Uint8Array.from(data.slice(0, data.length - 12))
  };
}

/**
 * encodeAddress encodes data
 * @param hrp human readeable part
 * @param witnessProgram witnessProgram = pubkey + witness
 * @param witnessVersion witness version
 */

function encodeAddress(_ref) {
  var witness = _ref.witness,
      witnessVersion = _ref.witnessVersion,
      blindingPublicKey = _ref.blindingPublicKey,
      hrp = _ref.hrp;
  validateWitnessVersion(witnessVersion);
  var witnessProgram = Buffer.concat([Buffer.from(blindingPublicKey, "hex"), Buffer.from(witness, "hex")]);
  var witnessProgLength = witnessProgram.length;
  if (witnessVersion === 0 && witnessProgLength !== 53 && witnessProgLength !== 65) throw new Error("witness version 0 needs witness program length = 53 OR = 65");
  if (witnessProgLength < 2 || witnessProgLength > 65) throw new Error("witness program length should be >= 2 and <= 65");
  var data = [witnessVersion].concat(convertBits(Array.from(witnessProgram), 8, 5, true));
  return encode(hrp, Uint8Array.from(data), getEncodingType(data[0]));
}
/**
 * decodeAddress decodes a segwit string address.
 * @param addr the blech32 encoded string.
 * @param encodingType the encoding type.
 */


function decodeAddress(addr, enc) {
  var _decode = decode(addr, enc),
      hrp = _decode.hrp,
      data = _decode.data;

  var witnessVersion = data[0];
  validateWitnessVersion(witnessVersion);
  if (data.length === 0 || data.length > MAX_LEN) throw new Error("Invalid data length");
  var witnessProgram = convertBits(Array.from(data.slice(1)), 5, 8, false);
  if (witnessProgram.length < 2 || witnessProgram.length > 65) throw new Error("Invalid witness data length");
  if (data[0] === 0 && witnessProgram.length !== 53 && witnessProgram.length !== 65) throw new Error("Invalid witness data length for witness version 0");
  var blindingPublicKey = Buffer.from(witnessProgram.slice(0, 33)).toString("hex");
  var witness = Buffer.from(witnessProgram.slice(33)).toString("hex");
  return {
    witness: witness,
    blindingPublicKey: blindingPublicKey,
    witnessVersion: witnessVersion,
    hrp: hrp
  };
}
/**
 * a class wrapping the encodeAddress and decodeAddress functions.
 */


var Blech32Address = /*#__PURE__*/function () {
  function Blech32Address(data) {
    this.witness = data.witness;
    this.blindingPublicKey = data.blindingPublicKey;
    this.witnessVersion = data.witnessVersion;
    this.address = encodeAddress(data);
  }

  Blech32Address.from = function from(witness, blindingPublicKey, hrp, witnessVersion) {
    return new Blech32Address({
      witness: witness,
      witnessVersion: witnessVersion,
      blindingPublicKey: blindingPublicKey,
      hrp: hrp
    });
  };

  Blech32Address.fromString = function fromString(blechString, encodingType) {
    return new Blech32Address(decodeAddress(blechString, encodingType));
  };

  return Blech32Address;
}();

export { BLECH32, BLECH32M, Blech32Address, MAX_LEN, decode, encode, getEncodingType };
//# sourceMappingURL=blech32.esm.js.map
