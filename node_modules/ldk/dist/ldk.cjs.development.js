'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var liquidjsLib = require('liquidjs-lib');
var psbt = require('liquidjs-lib/src/psbt');
var bip39 = require('bip39');
var b58 = _interopDefault(require('bs58check'));
var BIP32Factory = _interopDefault(require('bip32'));
var slip77 = require('slip77');
var ECPairFactory = _interopDefault(require('ecpair'));
var axios = _interopDefault(require('axios'));

function _asyncIterator(iterable) {
  var method,
      async,
      sync,
      retry = 2;

  for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {
    if (async && null != (method = iterable[async])) return method.call(iterable);
    if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));
    async = "@@asyncIterator", sync = "@@iterator";
  }

  throw new TypeError("Object is not async iterable");
}

function AsyncFromSyncIterator(s) {
  function AsyncFromSyncIteratorContinuation(r) {
    if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
    var done = r.done;
    return Promise.resolve(r.value).then(function (value) {
      return {
        value: value,
        done: done
      };
    });
  }

  return AsyncFromSyncIterator = function (s) {
    this.s = s, this.n = s.next;
  }, AsyncFromSyncIterator.prototype = {
    s: null,
    n: null,
    next: function () {
      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
    },
    return: function (value) {
      var ret = this.s.return;
      return void 0 === ret ? Promise.resolve({
        value: value,
        done: !0
      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
    },
    throw: function (value) {
      var thr = this.s.return;
      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
    }
  }, new AsyncFromSyncIterator(s);
}

function _AwaitValue(value) {
  this.wrapped = value;
}

function _AsyncGenerator(gen) {
  var front, back;

  function send(key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };

      if (back) {
        back = back.next = request;
      } else {
        front = back = request;
        resume(key, arg);
      }
    });
  }

  function resume(key, arg) {
    try {
      var result = gen[key](arg);
      var value = result.value;
      var wrappedAwait = value instanceof _AwaitValue;
      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
        if (wrappedAwait) {
          resume(key === "return" ? "return" : "next", arg);
          return;
        }

        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }

  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: true
        });
        break;

      case "throw":
        front.reject(value);
        break;

      default:
        front.resolve({
          value: value,
          done: false
        });
        break;
    }

    front = front.next;

    if (front) {
      resume(front.key, front.arg);
    } else {
      back = null;
    }
  }

  this._invoke = send;

  if (typeof gen.return !== "function") {
    this.return = undefined;
  }
}

_AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () {
  return this;
};

_AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
};

_AsyncGenerator.prototype.throw = function (arg) {
  return this._invoke("throw", arg);
};

_AsyncGenerator.prototype.return = function (arg) {
  return this._invoke("return", arg);
};

function _wrapAsyncGenerator(fn) {
  return function () {
    return new _AsyncGenerator(fn.apply(this, arguments));
  };
}

function _awaitAsyncGenerator(value) {
  return new _AwaitValue(value);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
});

var ZERO = /*#__PURE__*/Buffer.alloc(32);
function toAssetHash(x) {
  var withoutFirstByte = x.slice(1);
  return withoutFirstByte.reverse().toString('hex');
}
function fromAssetHash(x) {
  return Buffer.concat([Buffer.from('01', 'hex'), Buffer.from(x, 'hex').reverse()]);
}
function toNumber(x) {
  return liquidjsLib.confidential.confidentialValueToSatoshi(x);
}
function isValidAmount(amount) {
  if (amount <= 0 || !Number.isSafeInteger(amount)) return false;
  return true;
}
var emptyNonce = /*#__PURE__*/Buffer.from('0x00', 'hex');

function bufferNotEmptyOrNull(buffer) {
  return buffer != null && buffer.length > 0;
}
/**
 * Checks if a given output is a confidential one.
 * @param output the ouput to check.
 */


function isConfidentialOutput(_ref) {
  var rangeProof = _ref.rangeProof,
      surjectionProof = _ref.surjectionProof,
      nonce = _ref.nonce;
  return bufferNotEmptyOrNull(rangeProof) && bufferNotEmptyOrNull(surjectionProof) && nonce !== emptyNonce;
}
var BufferMap = /*#__PURE__*/function () {
  function BufferMap() {
    this.map = new Map();
  }

  var _proto = BufferMap.prototype;

  _proto.bufferToStringPrimitive = function bufferToStringPrimitive(buffer) {
    return buffer.toString('hex').valueOf();
  };

  _proto.get = function get(key) {
    return this.map.get(this.bufferToStringPrimitive(key));
  };

  _proto.set = function set(key, value) {
    this.map.set(this.bufferToStringPrimitive(key), value);
    return this;
  };

  _proto.values = function values() {
    return Array.from(this.map.values());
  };

  return BufferMap;
}(); // This has been taken from https://github.com/Casa/xpub-converter/blob/master/js/xpubConvert.js

/*
  This script uses version bytes as described in SLIP-132
  https://github.com/satoshilabs/slips/blob/master/slip-0132.md
*/

var prefixes = /*#__PURE__*/new Map([['xpub', '0488b21e'], ['ypub', '049d7cb2'], ['Ypub', '0295b43f'], ['zpub', '04b24746'], ['Zpub', '02aa7ed3'], ['tpub', '043587cf'], ['upub', '044a5262'], ['Upub', '024289ef'], ['vpub', '045f1cf6'], ['Vpub', '02575483']]);
/*
 * This function takes an extended public key (with any version bytes, it doesn't need to be an xpub)
 * and converts it to an extended public key formatted with the desired version bytes
 * @param xpub: an extended public key in base58 format. Example: xpub6CpihtY9HVc1jNJWCiXnRbpXm5BgVNKqZMsM4XqpDcQigJr6AHNwaForLZ3kkisDcRoaXSUms6DJNhxFtQGeZfWAQWCZQe1esNetx5Wqe4M
 * @param targetFormat: a string representing the desired prefix; must exist in the "prefixes" mapping defined above. Example: Zpub
 */

function changeVersionBytes(xpub, targetFormat) {
  if (!prefixes.has(targetFormat)) {
    return 'Invalid target version';
  } // trim whitespace


  xpub = xpub.trim();

  try {
    var data = b58.decode(xpub);
    data = data.slice(4);
    data = Buffer.concat([Buffer.from(prefixes.get(targetFormat), 'hex'), data]);
    return b58.encode(data);
  } catch (err) {
    throw new Error("Invalid extended public key! Please double check that you didn't accidentally paste extra data.");
  }
}

function fromXpub(xub, chain) {
  var format = chain === 'liquid' ? 'zpub' : 'vpub';
  return changeVersionBytes(xub, format);
}
function toXpub(anyPub) {
  return changeVersionBytes(anyPub, 'xpub');
}
var extendedPubKeyRegexp = /[a-z]pub[a-km-zA-HJ-NP-Z1-9]{100,108}$/;
var masterBlindKeyRegexp = /[0-9a-fA-F]{64}$/;
function isValidXpub(xpub) {
  return extendedPubKeyRegexp.test(xpub);
}
function isValidExtendedBlindKey(masterBlind) {
  return masterBlindKeyRegexp.test(masterBlind);
}
function psetToUnsignedHex(psetBase64) {
  var pset;

  try {
    pset = liquidjsLib.Psbt.fromBase64(psetBase64);
  } catch (ignore) {
    throw new Error('Invalid pset');
  }

  return pset.data.globalMap.unsignedTx.toBuffer().toString('hex');
}
function psetToUnsignedTx(ptx) {
  return liquidjsLib.Transaction.fromHex(psetToUnsignedHex(ptx));
}
function toOutpoint(_ref2) {
  var txid = _ref2.txid,
      vout = _ref2.vout;
  return {
    txid: txid,
    vout: vout
  };
}
function getNetwork(str) {
  return str ? liquidjsLib.networks[str] : liquidjsLib.networks.liquid;
}
/**
 * Compute the blinding data for a given output
 * @param utxo blinded utxo
 * @param blindPrivKey blinding private key
 */

function unblindOutput(_x, _x2) {
  return _unblindOutput.apply(this, arguments);
} // util function that parse a derivation path and return the index

function _unblindOutput() {
  _unblindOutput = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(utxo, blindPrivKey) {
    var unblindData;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (isConfidentialOutput(utxo.prevout)) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return", _extends({}, utxo, {
              unblindData: {
                asset: utxo.prevout.asset.slice(1),
                value: liquidjsLib.confidential.confidentialValueToSatoshi(utxo.prevout.value).toString(10),
                assetBlindingFactor: ZERO,
                valueBlindingFactor: ZERO
              }
            }));

          case 2:
            _context.next = 4;
            return liquidjsLib.confidential.unblindOutputWithKey(utxo.prevout, Buffer.from(blindPrivKey, 'hex'));

          case 4:
            unblindData = _context.sent;
            return _context.abrupt("return", _extends({}, utxo, {
              unblindData: unblindData
            }));

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _unblindOutput.apply(this, arguments);
}

function getIndexFromAddress(addr) {
  if (!addr.derivationPath) {
    throw new Error('need derivation path to be defined');
  }

  var derivationPathSplitted = addr.derivationPath.split('/');
  return parseInt(derivationPathSplitted[derivationPathSplitted.length - 1]);
} // throws an error if actual is not expect

function checkIdentityType(actual, expect) {
  if (actual !== expect) throw new Error("Incorrect Identity type: need " + expect + " and get " + actual + ".");
}
function checkMnemonic(mnemonic, language) {
  if (language) bip39.setDefaultWordlist(language);
  if (!bip39.validateMnemonic(mnemonic)) throw new Error('Mnemonic is not valid.');
}
function decodePset(psetBase64) {
  var pset;

  try {
    pset = liquidjsLib.Psbt.fromBase64(psetBase64);
  } catch (ignore) {
    throw new Error('Invalid pset');
  }

  return pset;
}
function getScripts(addresses) {
  return new Set(addresses.map(function (a) {
    return liquidjsLib.address.toOutputScript(a.confidentialAddress).toString('hex');
  }));
}
function groupBy(xs, key) {
  return xs.reduce(function (rv, x) {
    var _rv$k;

    var k = key(x);
    var row = (_rv$k = rv[k]) != null ? _rv$k : [];
    rv[k] = [].concat(row, [x]);
    return rv;
  }, {});
}

(function (IdentityType) {
  IdentityType[IdentityType["PrivateKey"] = 1] = "PrivateKey";
  IdentityType[IdentityType["Mnemonic"] = 2] = "Mnemonic";
  IdentityType[IdentityType["MasterPublicKey"] = 3] = "MasterPublicKey";
  IdentityType[IdentityType["Inject"] = 4] = "Inject";
  IdentityType[IdentityType["Ledger"] = 5] = "Ledger";
  IdentityType[IdentityType["Trezor"] = 6] = "Trezor";
  IdentityType[IdentityType["MultisigWatchOnly"] = 7] = "MultisigWatchOnly";
  IdentityType[IdentityType["Multisig"] = 8] = "Multisig";
})(exports.IdentityType || (exports.IdentityType = {}));

function isUnblindedOutput(output) {
  return output.unblindData !== undefined;
}
function getSats(output) {
  if (isUnblindedOutput(output)) return parseInt(output.unblindData.value, 10);

  if (!isConfidentialOutput(output.prevout)) {
    return liquidjsLib.confidential.confidentialValueToSatoshi(output.prevout.value);
  }

  throw new Error('cannot get value for confidential output, need unblinded one');
}
function getAsset(output) {
  if (isUnblindedOutput(output)) {
    var asset = Buffer.from(output.unblindData.asset).reverse();
    return asset.toString('hex');
  }

  if (!isConfidentialOutput(output.prevout)) {
    var _asset = Buffer.from(output.prevout.asset).slice(1).reverse();

    return _asset.toString('hex');
  }

  throw new Error('cannot get asset for confidential output, need unblinded one');
}

/**
 * Abstract class for Identity.
 */

var Identity = /*#__PURE__*/function () {
  function Identity(args) {
    if (!args.chain || !liquidjsLib.networks.hasOwnProperty(args.chain)) {
      throw new Error('Network is missing or not valid');
    }

    if (!args.type || !(args.type in exports.IdentityType)) {
      throw new Error('Type is missing or not valid');
    }

    this.network = liquidjsLib.networks[args.chain];
    this.type = args.type;
    this.ecclib = args.ecclib;
  }

  var _proto = Identity.prototype;

  _proto.blindPsetWithBlindKeysGetter = /*#__PURE__*/function () {
    var _blindPsetWithBlindKeysGetter = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(getBlindingKeyPair, psetBase64, outputsToBlind, outputsPubKeys, inputsBlindingDataLike) {
      var inputsData, outputsKeys, pset, transaction, _iterator, _step, _index, _pubKey, _script, pubKey, index, input, script, vout, witness, privKey, blinders, blinded;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              inputsData = new Map();
              outputsKeys = new Map();
              pset = decodePset(psetBase64);
              transaction = liquidjsLib.Transaction.fromHex(psetToUnsignedHex(psetBase64)); // set the outputs map

              _iterator = _createForOfIteratorHelperLoose(outputsToBlind);

            case 5:
              if ((_step = _iterator()).done) {
                _context.next = 16;
                break;
              }

              _index = _step.value;

              if (!(outputsPubKeys != null && outputsPubKeys.has(_index))) {
                _context.next = 11;
                break;
              }

              _pubKey = Buffer.from(outputsPubKeys.get(_index), 'hex');
              outputsKeys.set(_index, _pubKey);
              return _context.abrupt("continue", 14);

            case 11:
              _script = transaction.outs[_index].script;
              pubKey = getBlindingKeyPair(_script).publicKey;
              outputsKeys.set(_index, pubKey);

            case 14:
              _context.next = 5;
              break;

            case 16:
              index = 0;

            case 17:
              if (!(index < pset.data.inputs.length)) {
                _context.next = 43;
                break;
              }

              input = pset.data.inputs[index];
              script = undefined; // continue if the input witness is unconfidential

              if (!input.witnessUtxo) {
                _context.next = 24;
                break;
              }

              if (isConfidentialOutput(input.witnessUtxo)) {
                _context.next = 23;
                break;
              }

              return _context.abrupt("continue", 40);

            case 23:
              script = input.witnessUtxo.script;

            case 24:
              if (!input.nonWitnessUtxo) {
                _context.next = 30;
                break;
              }

              vout = transaction.ins[index].index;
              witness = liquidjsLib.Transaction.fromBuffer(input.nonWitnessUtxo).outs[vout];

              if (isConfidentialOutput(witness)) {
                _context.next = 29;
                break;
              }

              return _context.abrupt("continue", 40);

            case 29:
              script = witness.script;

            case 30:
              if (!(inputsBlindingDataLike != null && inputsBlindingDataLike.has(index))) {
                _context.next = 33;
                break;
              }

              inputsData.set(index, inputsBlindingDataLike.get(index));
              return _context.abrupt("continue", 40);

            case 33:
              if (script) {
                _context.next = 35;
                break;
              }

              throw new Error('no witness script for input #' + index);

            case 35:
              // else, get the private blinding key and use it as blindingDataLike
              privKey = getBlindingKeyPair(script).privateKey;
              _context.next = 38;
              return liquidjsLib.confidential.unblindOutputWithKey(input.witnessUtxo, privKey);

            case 38:
              blinders = _context.sent;
              inputsData.set(index, blinders);

            case 40:
              index++;
              _context.next = 17;
              break;

            case 43:
              _context.next = 45;
              return pset.blindOutputsByIndex(psbt.Psbt.ECCKeysGenerator(this.ecclib), inputsData, outputsKeys);

            case 45:
              blinded = _context.sent;
              return _context.abrupt("return", blinded.toBase64());

            case 47:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function blindPsetWithBlindKeysGetter(_x, _x2, _x3, _x4, _x5) {
      return _blindPsetWithBlindKeysGetter.apply(this, arguments);
    }

    return blindPsetWithBlindKeysGetter;
  }();

  return Identity;
}();
function privateBlindKeyGetter(identity) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(script) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", identity.getBlindingPrivateKey(script));

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x6) {
      return _ref.apply(this, arguments);
    };
  }();
}

var MasterPublicKey = /*#__PURE__*/function (_Identity) {
  _inheritsLoose(MasterPublicKey, _Identity);

  function MasterPublicKey(args) {
    var _this;

    _this = _Identity.call(this, args) || this;
    _this.index = MasterPublicKey.INITIAL_INDEX;
    _this.changeIndex = MasterPublicKey.INITIAL_INDEX;
    _this.scriptToAddressCache = {}; // check the identity type

    checkIdentityType(args.type, exports.IdentityType.MasterPublicKey); // validate xpub

    if (!isValidXpub(args.opts.masterPublicKey)) {
      throw new Error('Master public key is not valid');
    } // validate master blinding key


    if (!isValidExtendedBlindKey(args.opts.masterBlindingKey)) {
      throw new Error('Master blinding key is not valid');
    }

    _this.masterPublicKeyNode = BIP32Factory(args.ecclib).fromBase58(args.opts.masterPublicKey);
    _this.masterBlindingKeyNode = slip77.SLIP77Factory(args.ecclib).fromMasterBlindingKey(args.opts.masterBlindingKey);
    _this.baseDerivationPath = args.opts.baseDerivationPath || MasterPublicKey.INITIAL_BASE_PATH;
    return _this;
  }

  var _proto = MasterPublicKey.prototype;

  _proto.blindPset = /*#__PURE__*/function () {
    var _blindPset = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(psetBase64, outputsToBlind, outputsPubKeys, inputsBlindingDataLike) {
      var _this2 = this;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", _Identity.prototype.blindPsetWithBlindKeysGetter.call(this, function (script) {
                return _this2.getBlindingKeyPair(script.toString('hex'), true);
              }, psetBase64, outputsToBlind, outputsPubKeys, inputsBlindingDataLike));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function blindPset(_x, _x2, _x3, _x4) {
      return _blindPset.apply(this, arguments);
    }

    return blindPset;
  }();

  _proto.isAbleToSign = function isAbleToSign() {
    return false;
  }
  /**
   * return the next public key derivated from the baseNode.
   * increment the private member index +1.
   */
  ;

  _proto.derivePublicKeyWithIndex = function derivePublicKeyWithIndex(isChange, index) {
    var changeIndex = isChange ? 1 : 0;
    var baseNode = this.masterPublicKeyNode.derive(changeIndex);
    var child = baseNode.derive(index);
    return child.publicKey;
  }
  /**
   * Derives the script given as parameter to a keypair (SLIP77).
   * @param scriptPubKey script to derive.
   */
  ;

  _proto.getBlindingKeyPair = function getBlindingKeyPair(scriptPubKey, checkScript) {
    if (checkScript === void 0) {
      checkScript = false;
    }

    if (checkScript) {
      var addressInterface = this.scriptToAddressCache[scriptPubKey];

      if (!addressInterface) {
        throw new Error("unknow blinding key for script " + scriptPubKey);
      }
    }

    var _this$masterBlindingK = this.masterBlindingKeyNode.derive(scriptPubKey),
        publicKey = _this$masterBlindingK.publicKey,
        privateKey = _this$masterBlindingK.privateKey;

    return {
      publicKey: publicKey,
      privateKey: privateKey
    };
  };

  _proto.scriptFromPublicKey = function scriptFromPublicKey(publicKey) {
    return liquidjsLib.payments.p2wpkh({
      pubkey: publicKey,
      network: this.network
    }).output.toString('hex');
  };

  _proto.createConfidentialAddress = function createConfidentialAddress(signingPublicKey, blindingPublicKey) {
    return liquidjsLib.payments.p2wpkh({
      pubkey: signingPublicKey,
      blindkey: blindingPublicKey,
      network: this.network
    }).confidentialAddress;
  } // store the generation inside local cache
  ;

  _proto.persistAddressToCache = function persistAddressToCache(address) {
    var publicKeyBuffer = Buffer.from(address.publicKey, 'hex');
    var script = this.scriptFromPublicKey(publicKeyBuffer);
    this.scriptToAddressCache[script] = address;
  };

  _proto.getAddress = function getAddress(isChange, index) {
    // get the next key pair
    var publicKey = this.derivePublicKeyWithIndex(isChange, index); // use the public key to compute the scriptPubKey

    var script = this.scriptFromPublicKey(publicKey); // generate the blindKeyPair from the scriptPubKey

    var blindingKeyPair = this.getBlindingKeyPair(script); // with blindingPublicKey & signingPublicKey, generate the confidential address

    var confidentialAddress = this.createConfidentialAddress(publicKey, blindingKeyPair.publicKey); // create the address generation object

    var path = this.baseDerivationPath + "/" + (isChange ? 1 : 0) + "/" + index;
    var newAddressGeneration = {
      address: {
        confidentialAddress: confidentialAddress,
        blindingPrivateKey: blindingKeyPair.privateKey.toString('hex'),
        derivationPath: path,
        publicKey: publicKey.toString('hex')
      },
      publicKey: publicKey.toString('hex')
    }; // return the generation data

    return newAddressGeneration;
  };

  _proto.getNextAddress = /*#__PURE__*/function () {
    var _getNextAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
      var addr;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              addr = this.getAddress(false, this.index);
              this.persistAddressToCache(addr);
              this.index = this.index + 1;
              return _context2.abrupt("return", addr.address);

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getNextAddress() {
      return _getNextAddress.apply(this, arguments);
    }

    return getNextAddress;
  }();

  _proto.getNextChangeAddress = /*#__PURE__*/function () {
    var _getNextChangeAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
      var addr;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              addr = this.getAddress(true, this.changeIndex);
              this.persistAddressToCache(addr);
              this.changeIndex = this.changeIndex + 1;
              return _context3.abrupt("return", addr.address);

            case 4:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function getNextChangeAddress() {
      return _getNextChangeAddress.apply(this, arguments);
    }

    return getNextChangeAddress;
  }();

  _proto.getBlindingPrivateKey = /*#__PURE__*/function () {
    var _getBlindingPrivateKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(script) {
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", this.getBlindingKeyPair(script).privateKey.toString('hex'));

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function getBlindingPrivateKey(_x5) {
      return _getBlindingPrivateKey.apply(this, arguments);
    }

    return getBlindingPrivateKey;
  }();

  _proto.signPset = function signPset(_) {
    throw new Error('MasterPublicKey is a watch only identity. Use Mnemonic to sign transactions');
  } // returns all the addresses generated
  ;

  _proto.getAddresses =
  /*#__PURE__*/
  function () {
    var _getAddresses = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5() {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", Object.values(this.scriptToAddressCache).map(function (addrExtended) {
                return addrExtended.address;
              }));

            case 1:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function getAddresses() {
      return _getAddresses.apply(this, arguments);
    }

    return getAddresses;
  }();

  _proto.getXPub = function getXPub() {
    return this.masterPublicKeyNode.toBase58();
  };

  return MasterPublicKey;
}(Identity);
MasterPublicKey.INITIAL_BASE_PATH = "m/84'/0'/0'";
MasterPublicKey.INITIAL_INDEX = 0;

/**
 * @class Mnemonic
 * Get a mnemonic as parameter to set up an HD Wallet.
 * @member masterPrivateKeyNode a BIP32 node computed from the seed, used to generate signing key pairs.
 * @member masterBlindingKeyNode a SLIP77 node computed from the seed, used to generate the blinding key pairs.
 * @member derivationPath the base derivation path.
 * @member index the next index used to derive the base node (for signing key pairs).
 * @member scriptToAddressCache a map scriptPubKey --> address generation.
 */

var Mnemonic = /*#__PURE__*/function (_MasterPublicKey) {
  _inheritsLoose(Mnemonic, _MasterPublicKey);

  function Mnemonic(args) {
    var _this;

    checkIdentityType(args.type, exports.IdentityType.Mnemonic); // check set the language if it is different of the default language.
    // the "language exists check" is delegated to `bip39.setDefaultWordlist` function.

    bip39.setDefaultWordlist(args.opts.language || 'english');
    checkMnemonic(args.opts.mnemonic); // retreive the wallet's seed from mnemonic

    var walletSeed = bip39.mnemonicToSeedSync(args.opts.mnemonic, args.opts.passphrase); // generate the master private key from the wallet seed

    var network = liquidjsLib.networks[args.chain];
    var bip32 = BIP32Factory(args.ecclib);
    var masterPrivateKeyNode = bip32.fromSeed(walletSeed, network); // compute and expose the masterPublicKey in this.masterPublicKey

    var masterPublicKey = toXpub(masterPrivateKeyNode.derivePath(args.opts.baseDerivationPath || MasterPublicKey.INITIAL_BASE_PATH).neutered().toBase58()); // generate the master blinding key from the seed

    var masterBlindingKeyNode = slip77.SLIP77Factory(args.ecclib).fromSeed(walletSeed);
    var masterBlindingKey = masterBlindingKeyNode.masterKey.toString('hex');
    _this = _MasterPublicKey.call(this, _extends({}, args, {
      type: exports.IdentityType.MasterPublicKey,
      opts: {
        masterPublicKey: masterPublicKey,
        masterBlindingKey: masterBlindingKey,
        baseDerivationPath: args.opts.baseDerivationPath
      }
    })) || this;
    _this.masterBlindingKey = masterBlindingKey;
    _this.masterBlindingKeyNode = masterBlindingKeyNode;
    _this.masterPublicKey = masterPublicKey;
    _this.masterPrivateKeyNode = masterPrivateKeyNode;
    _this.mnemonic = args.opts.mnemonic;
    return _this;
  }

  var _proto = Mnemonic.prototype;

  _proto.blindPset = /*#__PURE__*/function () {
    var _blindPset = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(psetBase64, outputsToBlind, outputsPubKeys, inputsBlindingDataLike) {
      var _this2 = this;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", _MasterPublicKey.prototype.blindPsetWithBlindKeysGetter.call(this, function (script) {
                return _MasterPublicKey.prototype.getBlindingKeyPair.call(_this2, script.toString('hex'), true);
              }, psetBase64, outputsToBlind, outputsPubKeys, inputsBlindingDataLike));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function blindPset(_x, _x2, _x3, _x4) {
      return _blindPset.apply(this, arguments);
    }

    return blindPset;
  }();

  _proto.isAbleToSign = function isAbleToSign() {
    return true;
  }
  /**
   * return the next keypair derivated from the baseNode.
   * increment the private member index +1.
   */
  ;

  _proto.derivePath = function derivePath(derivationPath) {
    if (!this.ecclib) throw new Error('ecclib is missing, cannot derive public key');
    var wif = this.masterPrivateKeyNode.derivePath(derivationPath).toWIF();

    var _ECPairFactory$fromWI = ECPairFactory(this.ecclib).fromWIF(wif, this.network),
        publicKey = _ECPairFactory$fromWI.publicKey,
        privateKey = _ECPairFactory$fromWI.privateKey;

    return {
      publicKey: publicKey,
      privateKey: privateKey
    };
  };

  _proto.signPset = /*#__PURE__*/function () {
    var _signPset = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(psetBase64) {
      var pset, signInputPromises, index, input, addressGeneration, privateKeyBuffer, signingKeyPair;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (this.ecclib) {
                _context2.next = 2;
                break;
              }

              throw new Error('ecclib is missing, cannot sign pset');

            case 2:
              pset = liquidjsLib.Psbt.fromBase64(psetBase64);
              signInputPromises = [];

              for (index = 0; index < pset.data.inputs.length; index++) {
                input = pset.data.inputs[index];

                if (input.witnessUtxo) {
                  addressGeneration = this.scriptToAddressCache[input.witnessUtxo.script.toString('hex')];

                  if (addressGeneration) {
                    // if there is an address generated for the input script: build the signing key pair.
                    privateKeyBuffer = this.derivePath(addressGeneration.address.derivationPath).privateKey;
                    signingKeyPair = ECPairFactory(this.ecclib).fromPrivateKey(privateKeyBuffer); // add the promise to array

                    signInputPromises.push(pset.signInputAsync(index, signingKeyPair));
                  }
                }
              } // wait that all signing promise resolved


              _context2.next = 7;
              return Promise.all(signInputPromises);

            case 7:
              return _context2.abrupt("return", pset.toBase64());

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function signPset(_x5) {
      return _signPset.apply(this, arguments);
    }

    return signPset;
  }();

  Mnemonic.Random = function Random(chain, ecclib, baseDerivationPath) {
    var randomMnemonic = bip39.generateMnemonic();
    return new Mnemonic({
      chain: chain,
      ecclib: ecclib,
      type: exports.IdentityType.Mnemonic,
      opts: {
        mnemonic: randomMnemonic,
        baseDerivationPath: baseDerivationPath
      }
    });
  };

  return Mnemonic;
}(MasterPublicKey);

/**
 * The PrivateKey Identity takes a WIF and modelize a user using his private key.
 * @member signingKeyPair private, the key pair used to sign inputs.
 * @member blindingKeyPair private, the key pair used to blind outputs.
 * @member confidentialAddress private, the confidential address generated from keypairs.
 * @member blindingPrivateKey private, the blinding private key associated with the confidential address.
 * @member scriptPubKey private, the scriptPubKey associated to the confidential address.
 * @method signPset sign all the inputs when it's possible (scriptPubKey = input's script).
 * @method getAddresses return an array of one element containing the blindingPrivateKey & the confidentialAddress.
 */

var PrivateKey = /*#__PURE__*/function (_Identity) {
  _inheritsLoose(PrivateKey, _Identity);

  function PrivateKey(args) {
    var _this;

    _this = _Identity.call(this, args) || this; // checks the args type.

    checkIdentityType(args.type, exports.IdentityType.PrivateKey); // decode signing key pair from WIF

    _this.signingKeyPair = _this.decodeFromWif(args.opts.signingKeyWIF); // decode blinding key pair from WIF

    _this.blindingKeyPair = _this.decodeFromWif(args.opts.blindingKeyWIF); // create payment

    var p2wpkh = liquidjsLib.payments.p2wpkh({
      pubkey: _this.signingKeyPair.publicKey,
      blindkey: _this.blindingKeyPair.publicKey,
      network: _this.network
    }); // store data inside private fields.

    _this.confidentialAddress = p2wpkh.confidentialAddress;
    _this.blindingPrivateKey = _this.blindingKeyPair.privateKey.toString('hex');
    _this.scriptPubKey = p2wpkh.output;
    return _this;
  }

  var _proto = PrivateKey.prototype;

  _proto.blindPset = /*#__PURE__*/function () {
    var _blindPset = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(psetBase64, outputsToBlind, outputsPubKeys, inputsBlindingDataLike) {
      var _this2 = this;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", _Identity.prototype.blindPsetWithBlindKeysGetter.call(this, function (script) {
                return _this2.getBlindingKeyPair(script);
              }, psetBase64, outputsToBlind, outputsPubKeys, inputsBlindingDataLike));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function blindPset(_x, _x2, _x3, _x4) {
      return _blindPset.apply(this, arguments);
    }

    return blindPset;
  }();

  _proto.getBlindingKeyPair = function getBlindingKeyPair(script) {
    if (!script.equals(this.scriptPubKey)) {
      throw new Error(script + ' is unknown by the PrivateKey Identity');
    }

    return {
      publicKey: this.blindingKeyPair.publicKey,
      privateKey: this.blindingKeyPair.privateKey
    };
  };

  _proto.isAbleToSign = function isAbleToSign() {
    return true;
  };

  _proto.decodeFromWif = function decodeFromWif(wif) {
    return ECPairFactory(this.ecclib).fromWIF(wif, this.network);
  };

  _proto.getAddress = function getAddress() {
    return {
      confidentialAddress: this.confidentialAddress,
      blindingPrivateKey: this.blindingPrivateKey,
      derivationPath: undefined,
      publicKey: this.signingKeyPair.publicKey.toString('hex')
    };
  };

  _proto.getNextAddress = /*#__PURE__*/function () {
    var _getNextAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", this.getAddress());

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getNextAddress() {
      return _getNextAddress.apply(this, arguments);
    }

    return getNextAddress;
  }();

  _proto.getNextChangeAddress = /*#__PURE__*/function () {
    var _getNextChangeAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", this.getAddress());

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function getNextChangeAddress() {
      return _getNextChangeAddress.apply(this, arguments);
    }

    return getNextChangeAddress;
  }();

  _proto.getBlindingPrivateKey = /*#__PURE__*/function () {
    var _getBlindingPrivateKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(script) {
      var scriptPubKeyBuffer;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              scriptPubKeyBuffer = Buffer.from(script, 'hex');

              if (scriptPubKeyBuffer.equals(this.scriptPubKey)) {
                _context4.next = 3;
                break;
              }

              throw new Error('The script is not PrivateKey.scriptPubKey.');

            case 3:
              return _context4.abrupt("return", this.blindingPrivateKey);

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function getBlindingPrivateKey(_x5) {
      return _getBlindingPrivateKey.apply(this, arguments);
    }

    return getBlindingPrivateKey;
  }()
  /**
   * iterate through inputs and sign when it's possible, then returns the signed pset (base64 encoded).
   * @param psetBase64 the base64 encoded pset.
   */
  ;

  _proto.signPset =
  /*#__PURE__*/
  function () {
    var _signPset = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(psetBase64) {
      var _this3 = this;

      var pset, indexOfInputs, index, input;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              pset = liquidjsLib.Psbt.fromBase64(psetBase64);
              indexOfInputs = [];

              for (index = 0; index < pset.data.inputs.length; index++) {
                input = pset.data.inputs[index];

                if (input.witnessUtxo) {
                  if (input.witnessUtxo.script.equals(this.scriptPubKey)) {
                    indexOfInputs.push(index);
                  }
                } else {
                  indexOfInputs.push(index);
                }
              } // sign all the inputs asynchronously


              _context5.next = 5;
              return Promise.all(indexOfInputs.map(function (index) {
                return pset.signInputAsync(index, _this3.signingKeyPair);
              }));

            case 5:
              return _context5.abrupt("return", pset.toBase64());

            case 6:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function signPset(_x6) {
      return _signPset.apply(this, arguments);
    }

    return signPset;
  }()
  /**
   * for private key: only returns one confidential address & the associated blindingPrivKey.
   */
  ;

  _proto.getAddresses =
  /*#__PURE__*/
  function () {
    var _getAddresses = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6() {
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.abrupt("return", [{
                confidentialAddress: this.confidentialAddress,
                blindingPrivateKey: this.blindingPrivateKey,
                derivationPath: undefined,
                publicKey: this.signingKeyPair.publicKey.toString('hex')
              }]);

            case 1:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function getAddresses() {
      return _getAddresses.apply(this, arguments);
    }

    return getAddresses;
  }();

  return PrivateKey;
}(Identity);

var BrowserInject = /*#__PURE__*/function (_Identity) {
  _inheritsLoose(BrowserInject, _Identity);

  function BrowserInject(args) {
    var _this;

    _this = _Identity.call(this, args) || this; // checks the args type.

    checkIdentityType(args.type, exports.IdentityType.Inject); //checks if we are in the brower and if the provider is injected in the dom

    if (window === undefined || window[args.opts.windowProvider] === undefined) {
      throw new Error('The value.windowProvider of IdentityOpts is not valid or the script is to injected in the window');
    } // the provider must implement BrowserInjectProviderInterface


    _this.provider = window[args.opts.windowProvider];
    return _this;
  }

  var _proto = BrowserInject.prototype;

  _proto.getNextAddress = function getNextAddress() {
    return this.provider.getNextAddress();
  };

  _proto.getNextChangeAddress = function getNextChangeAddress() {
    return this.provider.getNextChangeAddress();
  };

  _proto.signPset = function signPset(psetBase64) {
    return this.provider.signTransaction(psetBase64);
  };

  _proto.getAddresses = function getAddresses() {
    return this.provider.getAddresses();
  };

  _proto.getBlindingPrivateKey = function getBlindingPrivateKey(_) {
    throw new Error('Method not implemented.');
  };

  _proto.isAbleToSign = function isAbleToSign() {
    return true;
  };

  _proto.blindPset = function blindPset(_, __, ___, ____) {
    throw new Error('Method not implemented.');
  };

  return BrowserInject;
}(Identity);

/**
 * Create a P2MS redeemscript.
 * + conf address
 * + unconf address
 * @param keys co-signers public keys.
 * @param blindingKey
 * @param required number of signature required in multisig script.
 * @param network
 */

function p2msPayment(keys, blindingKey, required, network) {
  // first generate the unconfidential payment
  var multisigPayment = liquidjsLib.payments.p2wsh({
    redeem: liquidjsLib.payments.p2ms({
      m: parseInt(required.toString()),
      pubkeys: bip67sort(keys.map(function (key) {
        return key.publicKey;
      })),
      network: network
    }),
    network: network
  });
  if (!multisigPayment.address) throw new Error('Invalid payment'); // generate blinding key

  var _blindingKey$derive = blindingKey.derive(liquidjsLib.address.toOutputScript(multisigPayment.address, network)),
      publicKey = _blindingKey$derive.publicKey,
      privateKey = _blindingKey$derive.privateKey;

  if (!publicKey || !privateKey) throw new Error('something went wrong while generating blinding key pair');
  multisigPayment = liquidjsLib.payments.p2wsh({
    redeem: liquidjsLib.payments.p2ms({
      m: parseInt(required.toString()),
      pubkeys: bip67sort(keys.map(function (key) {
        return key.publicKey;
      })),
      network: network
    }),
    blindkey: publicKey,
    network: network
  });
  if (!multisigPayment.confidentialAddress || !multisigPayment.redeem || !multisigPayment.redeem.output) throw new Error('invalid payment');
  return {
    blindingPrivateKey: privateKey.toString('hex'),
    confidentialAddress: multisigPayment.confidentialAddress,
    witnessScript: multisigPayment.redeem.output.toString('hex')
  };
}
/**
 * Return a blinding key from a list of extended keys.
 * @param extendedKeys must be the first addresses of multi-sig stakeholders.
 */

function blindingKeyFromXPubs(extendedKeys, ecclib) {
  var chainCodes = extendedKeys.map(function (key) {
    return key.chainCode;
  });
  var seed = blindingKeyFromChainCode(chainCodes);
  return slip77.SLIP77Factory(ecclib).fromSeed(seed);
}
/**
 * Returns sha256("blinding_key" + xor(chaincodes)) as a blinding key for multisig wallet.
 * https://github.com/cryptoadvance/specter-desktop/blob/master/src/cryptoadvance/specter/liquid/wallet.py#L77-L85
 * @param chainCodes the co-signers xpubs chainCodes (from the first receiving address)
 */

function blindingKeyFromChainCode(chainCodes) {
  var prefix = Buffer.from('blinding_key');
  var chainCodesXOR = Buffer.alloc(32);

  for (var _iterator = _createForOfIteratorHelperLoose(chainCodes), _step; !(_step = _iterator()).done;) {
    var chainCode = _step.value;
    chainCodesXOR = xor(chainCodesXOR, chainCode);
  }

  return liquidjsLib.crypto.sha256(Buffer.concat([prefix, chainCodesXOR]));
} // a xor b


function xor(a, b) {
  if (a.length !== b.length) throw new Error('a.length !== b.length (xor)');
  var result = Buffer.alloc(a.length);

  for (var i = 0; i < a.length; i++) {
    result[i] = a[i] ^ b[i];
  }

  return result;
}

function bip67sort(array) {
  return array.sort(bip67compareFunction);
}

function bip67compareFunction(a, b) {
  return a.toString('hex') < b.toString('hex') ? -1 : 1;
}

var DEFAULT_BASE_DERIVATION_PATH = "m/48'/0'/0'/2'"; // --> bip48

var MultisigWatchOnly = /*#__PURE__*/function (_Identity) {
  _inheritsLoose(MultisigWatchOnly, _Identity);

  function MultisigWatchOnly(args) {
    var _this;

    _this = _Identity.call(this, args) || this;
    _this.nextIndex = 0;
    _this.nextChangeIndex = 0;
    checkIdentityType(args.type, exports.IdentityType.MultisigWatchOnly);
    checkRequiredSignature(args.opts.requiredSignatures, args.opts.cosigners.length);
    var cosignersPublicKeys = args.opts.cosigners.map(function (cosigner) {
      return cosignerToXPub(cosigner, _this.network, _this.ecclib);
    });
    cosignersPublicKeys.forEach(isValidXpub);
    _this.cosigners = cosignersPublicKeys.sort().map(function (xpub) {
      return BIP32Factory(_this.ecclib).fromBase58(xpub);
    });
    _this.blindingKeyMasterNode = blindingKeyFromXPubs(_this.cosigners, _this.ecclib);
    _this.requiredSignatures = args.opts.requiredSignatures;
    return _this;
  }

  var _proto = MultisigWatchOnly.prototype;

  _proto.getNextAddress = function getNextAddress() {
    var addr = this.getMultisigAddress(MultisigWatchOnly.EXTERNAL_INDEX, this.nextIndex);
    this.nextIndex++;
    return Promise.resolve(addr);
  };

  _proto.getNextChangeAddress = function getNextChangeAddress() {
    var addr = this.getMultisigAddress(MultisigWatchOnly.INTERNAL_INDEX, this.nextChangeIndex);
    this.nextChangeIndex++;
    return Promise.resolve(addr);
  };

  _proto.getAddresses = function getAddresses() {
    var _this2 = this;

    var externals = Array.from(Array(this.nextIndex).keys()).map(function (index) {
      return _this2.getMultisigAddress(MultisigWatchOnly.EXTERNAL_INDEX, index);
    });
    var internals = Array.from(Array(this.nextChangeIndex).keys()).map(function (index) {
      return _this2.getMultisigAddress(MultisigWatchOnly.INTERNAL_INDEX, index);
    });
    return Promise.resolve(externals.concat(internals));
  };

  _proto.getBlindingPrivateKey = function getBlindingPrivateKey(script) {
    var privKey = this.getBlindingKeyPair(script).privateKey;
    return Promise.resolve(privKey.toString('hex'));
  };

  _proto.getBlindingKeyPair = function getBlindingKeyPair(script) {
    var keys = this.blindingKeyMasterNode.derive(script);
    if (!keys.publicKey || !keys.privateKey) throw new Error('unable to generate blinding key pair');
    return {
      publicKey: keys.publicKey,
      privateKey: keys.privateKey
    };
  };

  _proto.isAbleToSign = function isAbleToSign() {
    return false;
  };

  _proto.signPset = function signPset(_) {
    throw new Error('WatchOnly Multisig Identity is not able to sign pset');
  };

  _proto.blindPset = function blindPset(psetBase64, outputsIndexToBlind, outputsPubKeysByIndex, inputsBlindingDataLike) {
    var _this3 = this;

    return _Identity.prototype.blindPsetWithBlindKeysGetter.call(this, function (script) {
      return _this3.getBlindingKeyPair(script.toString('hex'));
    }, psetBase64, outputsIndexToBlind, outputsPubKeysByIndex, inputsBlindingDataLike);
  };

  _proto.getMultisigAddress = function getMultisigAddress(change, index) {
    var keys = this.cosigners.map(function (cosigner) {
      return cosigner.derive(change).derive(index);
    });
    var payment = p2msPayment(keys, this.blindingKeyMasterNode, this.requiredSignatures, this.network);
    return _extends({}, payment, {
      derivationPath: change + "/" + index
    });
  };

  return MultisigWatchOnly;
}(Identity);
MultisigWatchOnly.EXTERNAL_INDEX = 0;
MultisigWatchOnly.INTERNAL_INDEX = 1; // change addresses

function checkRequiredSignature(required, cosignersLength) {
  if (required <= 0 || required > cosignersLength) {
    throw new Error("number of required signatures must be > 0 and <= " + cosignersLength);
  }
}

function cosignerToXPub(cosigner, network, ecclib) {
  if (typeof cosigner === 'string') return cosigner;
  var walletSeed = bip39.mnemonicToSeedSync(cosigner.mnemonic, cosigner.passphrase);
  var bip32 = BIP32Factory(ecclib);
  var baseNode = bip32.fromSeed(walletSeed, network).derivePath(cosigner.baseDerivationPath || DEFAULT_BASE_DERIVATION_PATH);
  return toXpub(bip32.fromPublicKey(baseNode.publicKey, baseNode.chainCode, network).toBase58());
}

var Multisig = /*#__PURE__*/function (_MultisigWatchOnly) {
  _inheritsLoose(Multisig, _MultisigWatchOnly);

  function Multisig(args) {
    var _this;

    checkIdentityType(args.type, exports.IdentityType.Multisig);
    checkMnemonic(args.opts.signer.mnemonic);
    var walletSeed = bip39.mnemonicToSeedSync(args.opts.signer.mnemonic, args.opts.signer.passphrase);
    var network = liquidjsLib.networks[args.chain];
    var masterPrivateKeyNode = BIP32Factory(args.ecclib).fromSeed(walletSeed, network);
    var baseNode = masterPrivateKeyNode.derivePath(args.opts.signer.baseDerivationPath || DEFAULT_BASE_DERIVATION_PATH);
    _this = _MultisigWatchOnly.call(this, _extends({}, args, {
      opts: _extends({}, args.opts, {
        cosigners: args.opts.cosigners.concat([args.opts.signer])
      }),
      type: exports.IdentityType.MultisigWatchOnly
    })) || this;
    _this.baseDerivationPath = args.opts.signer.baseDerivationPath || DEFAULT_BASE_DERIVATION_PATH;
    _this.baseNode = baseNode;
    _this.scriptToPath = {};
    return _this;
  }

  var _proto = Multisig.prototype;

  _proto.getNextAddress = /*#__PURE__*/function () {
    var _getNextAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var next;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _MultisigWatchOnly.prototype.getNextAddress.call(this);

            case 2:
              next = _context.sent;

              if (next.derivationPath) {
                _context.next = 5;
                break;
              }

              throw new Error('need derivation path to cache addresses');

            case 5:
              this.scriptToPath[this.toScript(next.confidentialAddress)] = next.derivationPath;
              return _context.abrupt("return", next);

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getNextAddress() {
      return _getNextAddress.apply(this, arguments);
    }

    return getNextAddress;
  }();

  _proto.getNextChangeAddress = /*#__PURE__*/function () {
    var _getNextChangeAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
      var next;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return _MultisigWatchOnly.prototype.getNextChangeAddress.call(this);

            case 2:
              next = _context2.sent;

              if (next.derivationPath) {
                _context2.next = 5;
                break;
              }

              throw new Error('need derivation path to cache addresses');

            case 5:
              this.scriptToPath[this.toScript(next.confidentialAddress)] = next.derivationPath;
              return _context2.abrupt("return", next);

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getNextChangeAddress() {
      return _getNextChangeAddress.apply(this, arguments);
    }

    return getNextChangeAddress;
  }();

  _proto.isAbleToSign = function isAbleToSign() {
    return true;
  };

  _proto.signPset = /*#__PURE__*/function () {
    var _signPset = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(psetBase64) {
      var pset, signInputPromises, index, input, derivationPath, privKey, signingKeyPair;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              pset = liquidjsLib.Psbt.fromBase64(psetBase64);
              signInputPromises = [];
              index = 0;

            case 3:
              if (!(index < pset.data.inputs.length)) {
                _context3.next = 16;
                break;
              }

              input = pset.data.inputs[index];

              if (!input.witnessUtxo) {
                _context3.next = 13;
                break;
              }

              derivationPath = this.scriptToPath[input.witnessUtxo.script.toString('hex')];

              if (!derivationPath) {
                _context3.next = 13;
                break;
              }

              // if there is an address generated for the input script: build the signing key pair.
              privKey = this.baseNode.derivePath(derivationPath).privateKey;

              if (privKey) {
                _context3.next = 11;
                break;
              }

              throw new Error('signing private key is undefined');

            case 11:
              signingKeyPair = ECPairFactory(this.ecclib).fromPrivateKey(privKey); // add the promise to array

              signInputPromises.push(pset.signInputAsync(index, signingKeyPair));

            case 13:
              index++;
              _context3.next = 3;
              break;

            case 16:
              _context3.next = 18;
              return Promise.all(signInputPromises);

            case 18:
              return _context3.abrupt("return", pset.toBase64());

            case 19:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function signPset(_x) {
      return _signPset.apply(this, arguments);
    }

    return signPset;
  }();

  _proto.getXPub = function getXPub() {
    return toXpub(BIP32Factory(this.ecclib).fromPublicKey(this.baseNode.publicKey, this.baseNode.chainCode, this.network).toBase58());
  };

  _proto.toScript = function toScript(addr) {
    return liquidjsLib.address.toOutputScript(addr, this.network).toString('hex');
  };

  return Multisig;
}(MultisigWatchOnly);

var throwErrorHandler = function throwErrorHandler(asset, need, has) {
  throw new Error("not enought funds to fill " + need + "sats of " + asset + " (amount selected: " + has + ")");
}; // makeChanges creates the change RecipientInterface if needed

var makeChanges = function makeChanges(changeAddressGetter) {
  return function (toSelect) {
    return function (selectedUtxos) {
      var recipients = [];
      toSelect.forEach(function (amount, asset) {
        var changeAmount = diff(selectedUtxos)(asset)(amount);

        if (changeAmount > 0) {
          // has change
          recipients.push({
            address: changeAddressGetter(asset),
            asset: asset,
            value: changeAmount
          });
        }
      });
      return recipients;
    };
  };
};

var diff = function diff(utxos) {
  return function (asset) {
    var sum = sumUtxos(asset)(utxos);
    return function (amount) {
      return sum - amount;
    };
  };
};

var sumUtxos = function sumUtxos(asset) {
  return function (utxos) {
    return utxos.filter(makeAssetFilter(asset)).reduce(function (sum, utxo) {
      return sum + getSats(utxo);
    }, 0);
  };
}; // coinSelect is used to select utxo until they fill the amount requested


var coinSelect = function coinSelect(compareFn) {
  return function (errorHandler) {
    return function (utxos) {
      return function (toSelect) {
        var selectors = [];
        var coinSelectorFilter = coinSelectUtxosFilter(compareFn)(errorHandler);
        toSelect.forEach(function (amount, asset) {
          selectors.push(coinSelectorFilter(asset)(amount));
        });
        return selectors.flatMap(function (fnSelect) {
          return fnSelect(utxos);
        });
      };
    };
  };
};
function reduceRecipients(recipients) {
  // - Sanitize recipient.value, it must be a number.
  // - If is not, try to coerce it into number.
  // - Throw error if at the end is still not a number.
  // We were getting 'value' as a string without typescript complaining.
  // See https://github.com/vulpemventures/ldk/issues/103
  for (var _iterator = _createForOfIteratorHelperLoose(recipients), _step; !(_step = _iterator()).done;) {
    var recipient = _step.value;

    if (typeof recipient.value !== 'number') {
      recipient.value = parseInt(recipient.value);

      if (typeof recipient.value !== 'number') {
        throw new Error("invalid '" + typeof recipient.value + "' type for recipient.value");
      }
    }
  }

  return recipients.reduce(recipientsReducer, new Map());
}

function recipientsReducer(results, next) {
  results.set(next.asset, (results.get(next.asset) || 0) + next.value);
  return results;
}

function makeAssetFilter(assetToFilter) {
  return function (u) {
    var asset = getAsset(u);
    return asset === assetToFilter;
  };
}

var coinSelectUtxosFilter = function coinSelectUtxosFilter(compareFn) {
  return function (errorHandler) {
    return function (asset) {
      return function (amount) {
        return function (utxos) {
          var amtSelected = 0;
          var assetsUtxos = utxos.filter(makeAssetFilter(asset));
          var selected = assetsUtxos.sort(compareFn).reduce(function (selected, next) {
            if (amtSelected <= amount) {
              selected.push(next);
              amtSelected += getSats(next);
            }

            return selected;
          }, []); // if not enougth amount is selected, use errorHandler

          if (amtSelected < amount) errorHandler(asset, amount, amtSelected);
          return selected;
        };
      };
    };
  };
};

var checkCoinSelect = function checkCoinSelect(recipients) {
  return function (selectedUtxos) {
    var inputs = selectedUtxos.map(function (u) {
      return {
        value: getSats(u) || 0,
        asset: getAsset(u) || ''
      };
    });
    return check(inputs)(recipients);
  };
};

var check = function check(inputs) {
  return function (outputs) {
    var groupByAsset = groupBy$1('asset');
    var inputsByAsset = groupByAsset(inputs);
    var outputsByAsset = groupByAsset(outputs);
    var inputsAssets = Object.keys(inputsByAsset).sort();
    var outputsAssets = Object.keys(outputsByAsset).sort();

    if (!inputsAssets.every(function (asset) {
      return outputsAssets.includes(asset);
    })) {
      throw new Error("inputs and outputs don't have the same assets. Inputs assets = " + inputsAssets + ", Outputs assets = " + outputsAssets);
    }

    for (var asset in inputsByAsset) {
      var sumInputs = sumNumbers(inputsByAsset[asset].map(function (_ref) {
        var value = _ref.value;
        return value;
      }));
      var sumOutputs = sumNumbers(outputsByAsset[asset].map(function (_ref2) {
        var value = _ref2.value;
        return value;
      }));

      if (sumInputs !== sumOutputs) {
        throw new Error("missing funds for asset " + asset + " (inputs: " + sumInputs + ", outputs: " + sumOutputs + ")");
      }
    }
  };
};

var sumNumbers = function sumNumbers(values) {
  return values.reduce(function (acc, current) {
    return acc + current;
  }, 0);
};

function groupBy$1(key) {
  return function (xs) {
    return xs.reduce(function (rv, x) {
      (rv[x[key]] = rv[x[key]] || []).push(x);
      return rv;
    }, {});
  };
}

var defaultCompareFn = function defaultCompareFn(a, b) {
  return getSats(a) - getSats(b);
};
/**
 * select utxo for outputs among unspents.
 * @param unspents a set of unspents.
 * @param recipients the outputs targetted by the coin selection
 */


function greedyCoinSelector(sortFn) {
  if (sortFn === void 0) {
    sortFn = defaultCompareFn;
  }

  return function (errorHandler) {
    if (errorHandler === void 0) {
      errorHandler = throwErrorHandler;
    }

    var coinSelectFn = coinSelect(sortFn)(errorHandler);
    return function (unspents, recipients, changeAddressGetter) {
      var makeChangesFn = makeChanges(changeAddressGetter);
      var recipientsMap = reduceRecipients(recipients);
      var selectedUtxos = coinSelectFn(unspents)(recipientsMap);
      var changeOutputs = makeChangesFn(recipientsMap)(selectedUtxos);
      return {
        selectedUtxos: selectedUtxos,
        changeOutputs: changeOutputs
      };
    };
  };
}

/**
 * Fetch the raw transaction by txid
 * @param txId txID to fetch
 * @param url esplora URL
 */

function fetchTxHex(_x, _x2) {
  return _fetchTxHex.apply(this, arguments);
}
/**
 * Fetch the transaction as TxInterface (with prevouts)
 * @param txId transaction's hash to fetch
 * @param url the esplora URL
 */

function _fetchTxHex() {
  _fetchTxHex = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(txId, url) {
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return axios.get(url + "/tx/" + txId + "/hex");

          case 2:
            return _context2.abrupt("return", _context2.sent.data);

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _fetchTxHex.apply(this, arguments);
}

function fetchTx(_x3, _x4) {
  return _fetchTx.apply(this, arguments);
}
/**
 * Fetch unspents for a given address.
 * @param address
 * @param url the esplora URL
 */

function _fetchTx() {
  _fetchTx = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(txId, url) {
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.t0 = esploraTxToTxInterface;
            _context3.next = 3;
            return axios.get(url + "/tx/" + txId);

          case 3:
            _context3.t1 = _context3.sent.data;
            _context3.t2 = url;
            return _context3.abrupt("return", (0, _context3.t0)(_context3.t1, _context3.t2));

          case 6:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _fetchTx.apply(this, arguments);
}

function fetchUtxos(_x5, _x6) {
  return _fetchUtxos.apply(this, arguments);
}

function _fetchUtxos() {
  _fetchUtxos = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(address, url) {
    var esploraUtxos;
    return runtime_1.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return axios.get(url + "/address/" + address + "/utxo");

          case 2:
            esploraUtxos = _context4.sent.data;
            return _context4.abrupt("return", Promise.all(esploraUtxos.map(outpointToUtxo(url))));

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _fetchUtxos.apply(this, arguments);
}

var outpointToUtxo = function outpointToUtxo(esploraURL) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(outpoint) {
      var prevoutHex, prevout;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return fetchTxHex(outpoint.txid, esploraURL);

            case 2:
              prevoutHex = _context.sent;
              prevout = liquidjsLib.Transaction.fromHex(prevoutHex).outs[outpoint.vout];
              return _context.abrupt("return", _extends({}, outpoint, {
                prevout: prevout
              }));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x7) {
      return _ref.apply(this, arguments);
    };
  }();
};
/**
 * Convert an esplora transaction to a TxInterface
 * @param esploraTx
 * @param explorerUrl
 */


function esploraTxToTxInterface(_x8, _x9) {
  return _esploraTxToTxInterface.apply(this, arguments);
} // util function for output mapping

function _esploraTxToTxInterface() {
  _esploraTxToTxInterface = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(esploraTx, explorerUrl) {
    var inputTxIds, inputVouts, _iterator2, _step2, input, prevoutTxHexs, prevoutAsOutput, txInputs, txHex, transaction, makeOutpoint, makeOutputFromTxout, txOutputs, tx;

    return runtime_1.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            inputTxIds = [];
            inputVouts = [];

            for (_iterator2 = _createForOfIteratorHelperLoose(esploraTx.vin); !(_step2 = _iterator2()).done;) {
              input = _step2.value;
              inputTxIds.push(input.txid);
              inputVouts.push(input.vout);
            }

            _context5.next = 5;
            return Promise.all(inputTxIds.map(function (txid, index) {
              if (!esploraTx.vin[index].is_pegin) return fetchTxHex(txid, explorerUrl);
              return Promise.resolve(undefined); // return undefined in case of pegin
            }));

          case 5:
            prevoutTxHexs = _context5.sent;
            prevoutAsOutput = prevoutTxHexs.map(function (hex, index) {
              if (!hex) return undefined;
              return makeOutput({
                txid: inputTxIds[index],
                vout: inputVouts[index]
              }, liquidjsLib.Transaction.fromHex(hex).outs[inputVouts[index]]);
            });
            txInputs = inputTxIds.map(function (txid, index) {
              return {
                prevout: prevoutAsOutput[index],
                txid: txid,
                vout: inputVouts[index],
                isPegin: esploraTx.vin[index].is_pegin
              };
            });
            _context5.next = 10;
            return fetchTxHex(esploraTx.txid, explorerUrl);

          case 10:
            txHex = _context5.sent;
            transaction = liquidjsLib.Transaction.fromHex(txHex);

            makeOutpoint = function makeOutpoint(index) {
              return {
                txid: esploraTx.txid,
                vout: index
              };
            };

            makeOutputFromTxout = function makeOutputFromTxout(txout, index) {
              return makeOutput(makeOutpoint(index), txout);
            };

            txOutputs = transaction.outs.map(makeOutputFromTxout);
            tx = {
              txid: esploraTx.txid,
              vin: txInputs,
              vout: txOutputs,
              fee: esploraTx.fee,
              status: {
                confirmed: esploraTx.status.confirmed,
                blockHash: esploraTx.status.block_hash,
                blockHeight: esploraTx.status.block_height,
                blockTime: esploraTx.status.block_time
              }
            };
            return _context5.abrupt("return", tx);

          case 17:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _esploraTxToTxInterface.apply(this, arguments);
}

function makeOutput(outpoint, txOutput) {
  return _extends({}, outpoint, {
    prevout: txOutput
  });
}
/**
 * Create unblinded explorer URL from blinding data
 * @param baseURL
 * @param txID
 * @param outputsBlinder
 */


function makeUnblindURL(baseURL, txID, outputsBlinder) {
  var outputsString = outputsBlinder.map(function (_ref2) {
    var value = _ref2.value,
        asset = _ref2.asset,
        assetBlinder = _ref2.assetBlinder,
        valueBlinder = _ref2.valueBlinder;
    return value + "," + asset + "," + valueBlinder + "," + assetBlinder;
  }).join(',');
  return baseURL + "/tx/" + txID + "#blinded=" + outputsString;
}
/**
 * Create explorer URL with unblinding data
 * @param tx transaction to create the link for
 * @param baseURL base web Explorer URL
 */

function getUnblindURLFromTx(tx, baseURL) {
  var outputsData = [];

  var reverseHex = function reverseHex(blinder) {
    return Buffer.from(blinder, 'hex').reverse().toString('hex');
  };

  for (var _iterator = _createForOfIteratorHelperLoose(tx.vout), _step; !(_step = _iterator()).done;) {
    var output = _step.value;

    if (output.prevout.script.length > 0 && isUnblindedOutput(output)) {
      outputsData.push({
        value: getSats(output),
        asset: getAsset(output),
        assetBlinder: reverseHex(output.unblindData.assetBlindingFactor.toString('hex')),
        valueBlinder: reverseHex(output.unblindData.valueBlindingFactor.toString('hex'))
      });
    }
  }

  return makeUnblindURL(baseURL, tx.txid, outputsData);
}

var UnblindError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(UnblindError, _Error);

  function UnblindError(txid, vout, blindingKey) {
    return _Error.call(this, "UnblindError output (" + txid + ":" + vout + ") with blind key " + blindingKey) || this;
  }

  return UnblindError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

/**
 * Return an async generator fetching and unblinding addresses' transactions
 * @param addresses
 * @param blindingKeyGetter
 * @param explorerUrl
 * @param skip optional, can be used to skip certain transaction
 */

function fetchAndUnblindTxsGenerator(_x, _x2, _x3, _x4) {
  return _fetchAndUnblindTxsGenerator.apply(this, arguments);
}
/**
 * Use FetchAndUnblindTxsGenerator to get all utxos for a set of addresses
 * @param addresses
 * @param blindingKeyGetter
 * @param explorerUrl
 * @param skip optional
 */

function _fetchAndUnblindTxsGenerator() {
  _fetchAndUnblindTxsGenerator = _wrapAsyncGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(addresses, blindingKeyGetter, explorerUrl, skip) {
    var txIDs, errors, _iterator, _step, address, txsGenerator, txIterator, tx, _yield$_awaitAsyncGen, unblindedTx, errs;

    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            txIDs = [];
            errors = [];
            _iterator = _createForOfIteratorHelperLoose(addresses);

          case 3:
            if ((_step = _iterator()).done) {
              _context2.next = 40;
              break;
            }

            address = _step.value;
            _context2.prev = 5;
            txsGenerator = fetchTxsGenerator(address, explorerUrl, skip);
            _context2.next = 9;
            return _awaitAsyncGenerator(txsGenerator.next());

          case 9:
            txIterator = _context2.sent;

          case 10:
            if (txIterator.done) {
              _context2.next = 31;
              break;
            }

            tx = txIterator.value;

            if (!txIDs.includes(tx.txid)) {
              _context2.next = 17;
              break;
            }

            _context2.next = 15;
            return _awaitAsyncGenerator(txsGenerator.next());

          case 15:
            txIterator = _context2.sent;
            return _context2.abrupt("continue", 10);

          case 17:
            _context2.next = 19;
            return _awaitAsyncGenerator(unblindTransaction(tx, /*#__PURE__*/function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(script) {
                return runtime_1.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        return _context.abrupt("return", blindingKeyGetter(script));

                      case 1:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function (_x8) {
                return _ref.apply(this, arguments);
              };
            }()));

          case 19:
            _yield$_awaitAsyncGen = _context2.sent;
            unblindedTx = _yield$_awaitAsyncGen.unblindedTx;
            errs = _yield$_awaitAsyncGen.errors;
            errors.push.apply(errors, errs);
            _context2.next = 25;
            return unblindedTx;

          case 25:
            txIDs.push(tx.txid);
            _context2.next = 28;
            return _awaitAsyncGenerator(txsGenerator.next());

          case 28:
            txIterator = _context2.sent;
            _context2.next = 10;
            break;

          case 31:
            _context2.next = 38;
            break;

          case 33:
            _context2.prev = 33;
            _context2.t0 = _context2["catch"](5);

            if (_context2.t0 instanceof Error) {
              errors.push(_context2.t0);
            }

            if (typeof _context2.t0 === 'string') {
              errors.push(new Error(_context2.t0));
            }

            errors.push(new Error('unknown error'));

          case 38:
            _context2.next = 3;
            break;

          case 40:
            return _context2.abrupt("return", {
              txIDs: txIDs,
              errors: errors
            });

          case 41:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[5, 33]]);
  }));
  return _fetchAndUnblindTxsGenerator.apply(this, arguments);
}

function fetchAndUnblindTxs(_x9, _x10, _x11, _x12) {
  return _fetchAndUnblindTxs.apply(this, arguments);
}
/**
 * Fetch all the txs associated to a given address and unblind them using the blindingPrivateKey.
 * @param address the confidential address
 * @param explorerUrl the Esplora URL API using to fetch blockchain data.
 */

function _fetchAndUnblindTxs() {
  _fetchAndUnblindTxs = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(addresses, blindingKeyGetter, explorerUrl, skip) {
    var generator, txs, iterator;
    return runtime_1.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            generator = fetchAndUnblindTxsGenerator(addresses, blindingKeyGetter, explorerUrl, skip);
            txs = [];
            _context4.next = 4;
            return generator.next();

          case 4:
            iterator = _context4.sent;

          case 5:
            if (iterator.done) {
              _context4.next = 12;
              break;
            }

            txs.push(iterator.value);
            _context4.next = 9;
            return generator.next();

          case 9:
            iterator = _context4.sent;
            _context4.next = 5;
            break;

          case 12:
            return _context4.abrupt("return", txs);

          case 13:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _fetchAndUnblindTxs.apply(this, arguments);
}

function fetchTxsGenerator(_x5, _x6, _x7) {
  return _fetchTxsGenerator.apply(this, arguments);
}
/**
 * takes the a TxInterface and try to transform BlindedOutputInterface to UnblindedOutputInterface (prevouts & outputs)
 * @param tx transaction to unblind
 * @param blindingPrivateKeys the privateKeys using to unblind the outputs.
 */


function _fetchTxsGenerator() {
  _fetchTxsGenerator = _wrapAsyncGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(address, explorerUrl, skip) {
    var lastSeenTxid, newTxs, numberOfTxs, txs, _iterator2, _step2, tx, transaction;

    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            lastSeenTxid = undefined;
            newTxs = [];
            numberOfTxs = 0;

          case 3:
            _context3.next = 5;
            return _awaitAsyncGenerator(fetch25newestTxsForAddress(address, explorerUrl, lastSeenTxid));

          case 5:
            newTxs = _context3.sent;

            if (!(newTxs.length === 0)) {
              _context3.next = 8;
              break;
            }

            return _context3.abrupt("break", 24);

          case 8:
            lastSeenTxid = newTxs[newTxs.length - 1].txid;
            numberOfTxs += newTxs.length; // convert them into txInterface

            txs = newTxs.map(function (tx) {
              return esploraTxToTxInterface(tx, explorerUrl);
            });
            _iterator2 = _createForOfIteratorHelperLoose(txs);

          case 12:
            if ((_step2 = _iterator2()).done) {
              _context3.next = 23;
              break;
            }

            tx = _step2.value;
            _context3.next = 16;
            return _awaitAsyncGenerator(tx);

          case 16:
            transaction = _context3.sent;

            if (!(skip != null && skip(transaction))) {
              _context3.next = 19;
              break;
            }

            return _context3.abrupt("continue", 21);

          case 19:
            _context3.next = 21;
            return transaction;

          case 21:
            _context3.next = 12;
            break;

          case 23:
            if (lastSeenTxid) {
              _context3.next = 3;
              break;
            }

          case 24:
            return _context3.abrupt("return", numberOfTxs);

          case 25:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _fetchTxsGenerator.apply(this, arguments);
}

function unblindTransaction(_x13, _x14) {
  return _unblindTransaction.apply(this, arguments);
}

function _unblindTransaction() {
  _unblindTransaction = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(tx, blindingPrivateKeyGetter) {
    var promises, errors, _loop, inputIndex, _loop2, outputIndex;

    return runtime_1.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            promises = [];
            errors = []; // try to unblind prevouts, if success replace blinded prevout by unblinded prevout

            _loop = function _loop(inputIndex) {
              var output = tx.vin[inputIndex].prevout;

              if (output && isConfidentialOutput(output.prevout)) {
                var promise = /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5() {
                    var blindingKey, unblinded;
                    return runtime_1.wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            _context5.next = 2;
                            return blindingPrivateKeyGetter(output.prevout.script.toString('hex'));

                          case 2:
                            blindingKey = _context5.sent;

                            if (!blindingKey) {
                              _context5.next = 14;
                              break;
                            }

                            _context5.prev = 4;
                            _context5.next = 7;
                            return unblindOutput(output, blindingKey);

                          case 7:
                            unblinded = _context5.sent;
                            tx.vin[inputIndex].prevout = unblinded;
                            _context5.next = 14;
                            break;

                          case 11:
                            _context5.prev = 11;
                            _context5.t0 = _context5["catch"](4);
                            errors.push(new UnblindError(tx.vin[inputIndex].txid, tx.vin[inputIndex].vout, blindingKey));

                          case 14:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5, null, [[4, 11]]);
                  }));

                  return function promise() {
                    return _ref2.apply(this, arguments);
                  };
                }();

                promises.push(promise());
              }
            };

            for (inputIndex = 0; inputIndex < tx.vin.length; inputIndex++) {
              _loop(inputIndex);
            } // try to unblind outputs


            _loop2 = function _loop2(outputIndex) {
              var output = tx.vout[outputIndex];

              if (!isUnblindedOutput(output)) {
                var promise = /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6() {
                    var blindingKey, unblinded;
                    return runtime_1.wrap(function _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            _context6.next = 2;
                            return blindingPrivateKeyGetter(output.prevout.script.toString('hex'));

                          case 2:
                            blindingKey = _context6.sent;

                            if (!blindingKey) {
                              _context6.next = 14;
                              break;
                            }

                            _context6.prev = 4;
                            _context6.next = 7;
                            return unblindOutput(output, blindingKey);

                          case 7:
                            unblinded = _context6.sent;
                            tx.vout[outputIndex] = unblinded;
                            _context6.next = 14;
                            break;

                          case 11:
                            _context6.prev = 11;
                            _context6.t0 = _context6["catch"](4);
                            errors.push(new UnblindError(tx.txid, outputIndex, blindingKey));

                          case 14:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee6, null, [[4, 11]]);
                  }));

                  return function promise() {
                    return _ref3.apply(this, arguments);
                  };
                }();

                promises.push(promise());
              }
            };

            for (outputIndex = 0; outputIndex < tx.vout.length; outputIndex++) {
              _loop2(outputIndex);
            }

            _context7.next = 8;
            return Promise.all(promises);

          case 8:
            return _context7.abrupt("return", {
              unblindedTx: tx,
              errors: errors
            });

          case 9:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _unblindTransaction.apply(this, arguments);
}

function fetch25newestTxsForAddress(_x15, _x16, _x17) {
  return _fetch25newestTxsForAddress.apply(this, arguments);
}

function _fetch25newestTxsForAddress() {
  _fetch25newestTxsForAddress = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(address, explorerUrl, lastSeenTxid) {
    var url, response;
    return runtime_1.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            url = explorerUrl + "/address/" + address + "/txs/chain";

            if (lastSeenTxid) {
              url += "/" + lastSeenTxid;
            }

            _context8.next = 4;
            return axios.get(url);

          case 4:
            response = _context8.sent;
            return _context8.abrupt("return", response.data);

          case 6:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return _fetch25newestTxsForAddress.apply(this, arguments);
}

/**
 * fetchAndUnblindUtxosGenerator returns the unblinded utxos associated with a set of addresses.
 * @param addressesAndBlindingKeys the set of addresses with blinding key (if confidential)
 * @param url esplora URL
 * @param skip optional, using to skip blinding step
 */

function fetchAndUnblindUtxosGenerator(_x, _x2, _x3, _x4) {
  return _fetchAndUnblindUtxosGenerator.apply(this, arguments);
} // Aggregate generator's result.

function _fetchAndUnblindUtxosGenerator() {
  _fetchAndUnblindUtxosGenerator = _wrapAsyncGenerator( /*#__PURE__*/runtime_1.mark(function _callee(ecclib, addressesAndBlindingKeys, url, skip) {
    var numberOfUtxos, errors, _iterator, _step, _step$value, confidentialAddress, blindingPrivateKey, blindingKeyPair, addressPublicKey, blindedUtxos, _iterator2, _step2, blindedUtxo;

    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            numberOfUtxos = 0;
            errors = []; // the generator repeats the process for each addresses

            _iterator = _createForOfIteratorHelperLoose(addressesAndBlindingKeys);

          case 3:
            if ((_step = _iterator()).done) {
              _context.next = 35;
              break;
            }

            _step$value = _step.value, confidentialAddress = _step$value.confidentialAddress, blindingPrivateKey = _step$value.blindingPrivateKey;
            _context.prev = 5;

            if (!(blindingPrivateKey.length > 0)) {
              _context.next = 11;
              break;
            }

            blindingKeyPair = ECPairFactory(ecclib).fromPrivateKey(Buffer.from(blindingPrivateKey, 'hex'));
            addressPublicKey = liquidjsLib.address.fromConfidential(confidentialAddress).blindingKey;

            if (blindingKeyPair.publicKey.equals(addressPublicKey)) {
              _context.next = 11;
              break;
            }

            throw new Error('wrong blinding private key');

          case 11:
            _context.next = 13;
            return _awaitAsyncGenerator(fetchUtxos(confidentialAddress, url));

          case 13:
            blindedUtxos = _context.sent;
            _iterator2 = _createForOfIteratorHelperLoose(blindedUtxos);

          case 15:
            if ((_step2 = _iterator2()).done) {
              _context.next = 26;
              break;
            }

            blindedUtxo = _step2.value;

            if (!(skip != null && skip(blindedUtxo))) {
              _context.next = 19;
              break;
            }

            return _context.abrupt("continue", 24);

          case 19:
            _context.next = 21;
            return _awaitAsyncGenerator(tryToUnblindUtxo(blindedUtxo, blindingPrivateKey));

          case 21:
            _context.next = 23;
            return _context.sent;

          case 23:
            numberOfUtxos++;

          case 24:
            _context.next = 15;
            break;

          case 26:
            _context.next = 33;
            break;

          case 28:
            _context.prev = 28;
            _context.t0 = _context["catch"](5);
            if (_context.t0 instanceof Error) errors.push(_context.t0);
            if (typeof _context.t0 === 'string') errors.push(new Error(_context.t0));
            errors.push(new Error('unknow error'));

          case 33:
            _context.next = 3;
            break;

          case 35:
            return _context.abrupt("return", {
              numberOfUtxos: numberOfUtxos,
              errors: errors
            });

          case 36:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[5, 28]]);
  }));
  return _fetchAndUnblindUtxosGenerator.apply(this, arguments);
}

function fetchAndUnblindUtxos(_x5, _x6, _x7, _x8) {
  return _fetchAndUnblindUtxos.apply(this, arguments);
}
/**
 * try to unblind the utxo with blindPrivKey. if unblind fails, return utxo
 * if unblind step success: set prevout & unblindData members in UtxoInterface result
 * @param utxo utxo to unblind
 * @param blindPrivKey the blinding private key using to unblind
 * @param url esplora endpoint URL
 */

function _fetchAndUnblindUtxos() {
  _fetchAndUnblindUtxos = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(ecclib, addressesAndBlindingKeys, url, skip) {
    var utxosGenerator, utxos, iterator;
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            utxosGenerator = fetchAndUnblindUtxosGenerator(ecclib, addressesAndBlindingKeys, url, skip);
            utxos = [];
            _context2.next = 4;
            return utxosGenerator.next();

          case 4:
            iterator = _context2.sent;

          case 5:
            if (iterator.done) {
              _context2.next = 12;
              break;
            }

            utxos.push(iterator.value);
            _context2.next = 9;
            return utxosGenerator.next();

          case 9:
            iterator = _context2.sent;
            _context2.next = 5;
            break;

          case 12:
            return _context2.abrupt("return", utxos);

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _fetchAndUnblindUtxos.apply(this, arguments);
}

function tryToUnblindUtxo(_x9, _x10) {
  return _tryToUnblindUtxo.apply(this, arguments);
}
/**
 * Reduce a set of transactions using a set of scripts
 * @param txs the wallet's transactions
 * @param walletScripts the set of scripts to use in order to filter tx's outputs
 * @param initialState initial utxos state (set in txs reducer) - optional (default: [])
 */

function _tryToUnblindUtxo() {
  _tryToUnblindUtxo = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(utxo, blindPrivKey) {
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            return _context3.abrupt("return", unblindOutput(utxo, blindPrivKey));

          case 4:
            _context3.prev = 4;
            _context3.t0 = _context3["catch"](0);
            throw new UnblindError(utxo.txid, utxo.vout, blindPrivKey);

          case 7:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[0, 4]]);
  }));
  return _tryToUnblindUtxo.apply(this, arguments);
}

function utxosFromTransactions(txs, walletScripts, initialState) {
  if (initialState === void 0) {
    initialState = [];
  }

  var orInfinity = function orInfinity(a) {
    return a ? a : Infinity;
  };

  var compareBlockHeight = function compareBlockHeight(a, b) {
    return orInfinity(a.status.blockHeight) - orInfinity(b.status.blockHeight) || 0;
  };

  var compareVin = function compareVin(a, b) {
    return a.vin.map(function (i) {
      return i.txid;
    }).includes(b.txid) ? 1 : -1;
  };

  var compare = function compare(a, b) {
    return compareBlockHeight(a, b) || compareVin(a, b);
  };

  return txs.sort(compare).reduce(function (utxoSet, tx, _) {
    var withoutSpentUtxo = removeInputsFromUtxos(utxoSet, tx.vin);
    return addOutputsToUtxos(withoutSpentUtxo, tx, walletScripts);
  }, initialState);
}

function addOutputsToUtxos(utxos, tx, walletScripts) {
  var isWalletOutput = function isWalletOutput(o) {
    return walletScripts.has(o.prevout.script.toString('hex'));
  };

  var walletOutputs = tx.vout.filter(isWalletOutput);
  return utxos.concat(walletOutputs);
}

function removeInputsFromUtxos(utxoSet, inputs) {
  var result = utxoSet;

  var _loop = function _loop() {
    var input = _step3.value;
    result = result.filter(function (u) {
      return !(u.txid === input.txid && u.vout === input.vout);
    });
  };

  for (var _iterator3 = _createForOfIteratorHelperLoose(inputs), _step3; !(_step3 = _iterator3()).done;) {
    _loop();
  }

  return result;
}

function utxosFetchGenerator(_x, _x2, _x3, _x4) {
  return _utxosFetchGenerator.apply(this, arguments);
}

function _utxosFetchGenerator() {
  _utxosFetchGenerator = _wrapAsyncGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(addresses, blindingKeyGetter, api, skip) {
    var numberOfUtxos, errors, utxos, _iterator4, _step4, utxo, privateBlindingKey, unblindedUtxo;

    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            numberOfUtxos = 0;
            errors = [];
            _context2.next = 4;
            return _awaitAsyncGenerator(api.fetchUtxos(addresses, skip));

          case 4:
            utxos = _context2.sent;
            _iterator4 = _createForOfIteratorHelperLoose(utxos);

          case 6:
            if ((_step4 = _iterator4()).done) {
              _context2.next = 33;
              break;
            }

            utxo = _step4.value;
            _context2.prev = 8;

            if (isConfidentialOutput(utxo.prevout)) {
              _context2.next = 12;
              break;
            }

            _context2.next = 12;
            return _extends({}, utxo, {
              unblindData: {
                asset: utxo.prevout.asset.slice(1),
                value: liquidjsLib.confidential.confidentialValueToSatoshi(utxo.prevout.value).toString(10),
                assetBlindingFactor: Buffer.alloc(32),
                valueBlindingFactor: Buffer.alloc(32)
              }
            });

          case 12:
            _context2.next = 14;
            return _awaitAsyncGenerator(blindingKeyGetter(utxo.prevout.script.toString('hex')));

          case 14:
            privateBlindingKey = _context2.sent;

            if (privateBlindingKey) {
              _context2.next = 17;
              break;
            }

            return _context2.abrupt("continue", 31);

          case 17:
            _context2.next = 19;
            return _awaitAsyncGenerator(tryToUnblindUtxo(utxo, privateBlindingKey));

          case 19:
            unblindedUtxo = _context2.sent;
            _context2.next = 22;
            return unblindedUtxo;

          case 22:
            numberOfUtxos++;
            _context2.next = 31;
            break;

          case 25:
            _context2.prev = 25;
            _context2.t0 = _context2["catch"](8);
            console.log(_context2.t0);

            if (_context2.t0 instanceof Error) {
              errors.push(_context2.t0);
            }

            if (typeof _context2.t0 === 'string') {
              errors.push(new Error(_context2.t0));
            }

            errors.push(new Error('unknown error'));

          case 31:
            _context2.next = 6;
            break;

          case 33:
            return _context2.abrupt("return", {
              numberOfUtxos: numberOfUtxos,
              errors: errors
            });

          case 34:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[8, 25]]);
  }));
  return _utxosFetchGenerator.apply(this, arguments);
}

function txsFetchGenerator(_x5, _x6, _x7, _x8) {
  return _txsFetchGenerator.apply(this, arguments);
}

function _txsFetchGenerator() {
  _txsFetchGenerator = _wrapAsyncGenerator( /*#__PURE__*/runtime_1.mark(function _callee(addresses, blindingKeyGetter, api, skip) {
    var txIDs, errors, transactions, _iterator3, _step3, tx, _yield$_awaitAsyncGen, unblindedTx, errs;

    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            txIDs = [];
            errors = [];
            _context.next = 4;
            return _awaitAsyncGenerator(api.fetchTxs(addresses, skip));

          case 4:
            transactions = _context.sent;
            _iterator3 = _createForOfIteratorHelperLoose(transactions);

          case 6:
            if ((_step3 = _iterator3()).done) {
              _context.next = 27;
              break;
            }

            tx = _step3.value;
            _context.prev = 8;
            _context.next = 11;
            return _awaitAsyncGenerator(unblindTransaction(tx, blindingKeyGetter));

          case 11:
            _yield$_awaitAsyncGen = _context.sent;
            unblindedTx = _yield$_awaitAsyncGen.unblindedTx;
            errs = _yield$_awaitAsyncGen.errors;
            errors.push.apply(errors, errs);
            _context.next = 17;
            return unblindedTx;

          case 17:
            txIDs.push(tx.txid);
            _context.next = 25;
            break;

          case 20:
            _context.prev = 20;
            _context.t0 = _context["catch"](8);

            if (_context.t0 instanceof Error) {
              errors.push(_context.t0);
            }

            if (typeof _context.t0 === 'string') {
              errors.push(new Error(_context.t0));
            }

            errors.push(new Error('unknown error'));

          case 25:
            _context.next = 6;
            break;

          case 27:
            return _context.abrupt("return", {
              txIDs: txIDs,
              errors: errors
            });

          case 28:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[8, 20]]);
  }));
  return _txsFetchGenerator.apply(this, arguments);
}

function fetchAllTxs(_x9, _x10, _x11, _x12) {
  return _fetchAllTxs.apply(this, arguments);
}

function _fetchAllTxs() {
  _fetchAllTxs = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(addresses, blindingKeyGetter, api, skip) {
    var txs, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, tx;

    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            txs = [];
            _iteratorAbruptCompletion = false;
            _didIteratorError = false;
            _context3.prev = 3;
            _iterator = _asyncIterator(txsFetchGenerator(addresses, blindingKeyGetter, api, skip));

          case 5:
            _context3.next = 7;
            return _iterator.next();

          case 7:
            if (!(_iteratorAbruptCompletion = !(_step = _context3.sent).done)) {
              _context3.next = 13;
              break;
            }

            tx = _step.value;
            txs.push(tx);

          case 10:
            _iteratorAbruptCompletion = false;
            _context3.next = 5;
            break;

          case 13:
            _context3.next = 19;
            break;

          case 15:
            _context3.prev = 15;
            _context3.t0 = _context3["catch"](3);
            _didIteratorError = true;
            _iteratorError = _context3.t0;

          case 19:
            _context3.prev = 19;
            _context3.prev = 20;

            if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
              _context3.next = 24;
              break;
            }

            _context3.next = 24;
            return _iterator["return"]();

          case 24:
            _context3.prev = 24;

            if (!_didIteratorError) {
              _context3.next = 27;
              break;
            }

            throw _iteratorError;

          case 27:
            return _context3.finish(24);

          case 28:
            return _context3.finish(19);

          case 29:
            return _context3.abrupt("return", txs);

          case 30:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[3, 15, 19, 29], [20,, 24, 28]]);
  }));
  return _fetchAllTxs.apply(this, arguments);
}

function fetchAllUtxos(_x13, _x14, _x15, _x16) {
  return _fetchAllUtxos.apply(this, arguments);
}

function _fetchAllUtxos() {
  _fetchAllUtxos = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(addresses, blindingKeyGetter, api, skip) {
    var utxos, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, utxo;

    return runtime_1.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            utxos = [];
            _iteratorAbruptCompletion2 = false;
            _didIteratorError2 = false;
            _context4.prev = 3;
            _iterator2 = _asyncIterator(utxosFetchGenerator(addresses, blindingKeyGetter, api, skip));

          case 5:
            _context4.next = 7;
            return _iterator2.next();

          case 7:
            if (!(_iteratorAbruptCompletion2 = !(_step2 = _context4.sent).done)) {
              _context4.next = 13;
              break;
            }

            utxo = _step2.value;
            utxos.push(utxo);

          case 10:
            _iteratorAbruptCompletion2 = false;
            _context4.next = 5;
            break;

          case 13:
            _context4.next = 19;
            break;

          case 15:
            _context4.prev = 15;
            _context4.t0 = _context4["catch"](3);
            _didIteratorError2 = true;
            _iteratorError2 = _context4.t0;

          case 19:
            _context4.prev = 19;
            _context4.prev = 20;

            if (!(_iteratorAbruptCompletion2 && _iterator2["return"] != null)) {
              _context4.next = 24;
              break;
            }

            _context4.next = 24;
            return _iterator2["return"]();

          case 24:
            _context4.prev = 24;

            if (!_didIteratorError2) {
              _context4.next = 27;
              break;
            }

            throw _iteratorError2;

          case 27:
            return _context4.finish(24);

          case 28:
            return _context4.finish(19);

          case 29:
            return _context4.abrupt("return", utxos);

          case 30:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[3, 15, 19, 29], [20,, 24, 28]]);
  }));
  return _fetchAllUtxos.apply(this, arguments);
}

/**
 * Esplora is the ChainAPI implmentation for regular esplora instance
 * Esplora also exports extra methods specific to esplora instance
 */

var Electrs = /*#__PURE__*/function () {
  function Electrs(url, axiosIns) {
    this.electrsURL = url;
    this.axios = axiosIns != null ? axiosIns : axios.create();
  }

  Electrs.fromURL = function fromURL(url) {
    return new Electrs(url);
  };

  var _proto = Electrs.prototype;

  _proto.addressesHasBeenUsed = /*#__PURE__*/function () {
    var _addressesHasBeenUsed = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(addresses) {
      var _this = this;

      var hasBeenUsed;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              hasBeenUsed = /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(address) {
                  var data;
                  return runtime_1.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.prev = 0;
                          _context.next = 3;
                          return axios.get(_this.electrsURL + "/address/" + address + "/txs");

                        case 3:
                          data = _context.sent.data;
                          return _context.abrupt("return", data.length > 0);

                        case 7:
                          _context.prev = 7;
                          _context.t0 = _context["catch"](0);
                          return _context.abrupt("return", false);

                        case 10:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, null, [[0, 7]]);
                }));

                return function hasBeenUsed(_x2) {
                  return _ref.apply(this, arguments);
                };
              }();

              return _context2.abrupt("return", Promise.all(addresses.map(hasBeenUsed)));

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function addressesHasBeenUsed(_x) {
      return _addressesHasBeenUsed.apply(this, arguments);
    }

    return addressesHasBeenUsed;
  }();

  _proto.fetchUtxos = /*#__PURE__*/function () {
    var _fetchUtxos = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(addresses, skip) {
      var _this2 = this;

      var reqs, responses, resolvedResponses, utxos;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              reqs = addresses.map(function (address) {
                return _this2.axios.get(_this2.electrsURL + "/address/" + address + "/utxo");
              });
              _context3.next = 3;
              return Promise.allSettled(reqs);

            case 3:
              responses = _context3.sent;
              resolvedResponses = responses.map(function (r) {
                return r.status === 'fulfilled' ? r.value.data : [];
              });
              utxos = resolvedResponses.map(function (r) {
                return r ? r : [];
              });
              return _context3.abrupt("return", Promise.all(utxos.flat().filter(function (u) {
                return skip ? !skip(u) : true;
              }).map(this.outpointToUtxo())));

            case 7:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function fetchUtxos(_x3, _x4) {
      return _fetchUtxos.apply(this, arguments);
    }

    return fetchUtxos;
  }();

  _proto.fetchTxs = /*#__PURE__*/function () {
    var _fetchTxs = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(addresses, skip) {
      var _this3 = this;

      var esploraTxs, txs;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return Promise.all(addresses.map(this.fetchAllTxsForAddress()));

            case 2:
              esploraTxs = _context4.sent;
              txs = esploraTxs.flat().filter(function (tx) {
                return skip ? !skip(tx) : true;
              }).map(esploraTxToTxInterface$1(function (ids) {
                return _this3.fetchTxsHex(ids);
              }));
              return _context4.abrupt("return", Promise.all(txs));

            case 5:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function fetchTxs(_x5, _x6) {
      return _fetchTxs.apply(this, arguments);
    }

    return fetchTxs;
  }();

  _proto.fetchTxHex = /*#__PURE__*/function () {
    var _fetchTxHex = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(txid) {
      var h;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.axios.get(this.electrsURL + "/tx/" + txid + "/hex");

            case 2:
              h = _context5.sent.data;
              return _context5.abrupt("return", h);

            case 4:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function fetchTxHex(_x7) {
      return _fetchTxHex.apply(this, arguments);
    }

    return fetchTxHex;
  }();

  _proto.fetchTxsHex = /*#__PURE__*/function () {
    var _fetchTxsHex = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(txids) {
      var _this4 = this;

      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              return _context7.abrupt("return", Promise.all(txids.map( /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(txid) {
                  return runtime_1.wrap(function _callee6$(_context6) {
                    while (1) {
                      switch (_context6.prev = _context6.next) {
                        case 0:
                          _context6.t0 = txid;
                          _context6.next = 3;
                          return _this4.fetchTxHex(txid);

                        case 3:
                          _context6.t1 = _context6.sent;
                          return _context6.abrupt("return", {
                            txid: _context6.t0,
                            hex: _context6.t1
                          });

                        case 5:
                        case "end":
                          return _context6.stop();
                      }
                    }
                  }, _callee6);
                }));

                return function (_x9) {
                  return _ref2.apply(this, arguments);
                };
              }())));

            case 1:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    function fetchTxsHex(_x8) {
      return _fetchTxsHex.apply(this, arguments);
    }

    return fetchTxsHex;
  }();

  _proto.fetchTx = /*#__PURE__*/function () {
    var _fetchTx = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(txid) {
      var _this5 = this;

      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              _context8.t0 = esploraTxToTxInterface$1(function (ids) {
                return _this5.fetchTxsHex(ids);
              });
              _context8.next = 3;
              return this.axios.get(this.electrsURL + "/tx/" + txid);

            case 3:
              _context8.t1 = _context8.sent.data;
              return _context8.abrupt("return", (0, _context8.t0)(_context8.t1));

            case 5:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function fetchTx(_x10) {
      return _fetchTx.apply(this, arguments);
    }

    return fetchTx;
  }();

  _proto.fetchAllTxsForAddress = function fetchAllTxsForAddress() {
    var _this6 = this;

    return /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(address) {
        var lastSeenTxid, txs, nextTxs;
        return runtime_1.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                lastSeenTxid = undefined;
                txs = [];

              case 2:
                _context9.next = 4;
                return _this6.fetch25newestTxsForAddress(address, lastSeenTxid);

              case 4:
                nextTxs = _context9.sent;

                if (!(nextTxs.length === 0)) {
                  _context9.next = 7;
                  break;
                }

                return _context9.abrupt("break", 12);

              case 7:
                txs.push.apply(txs, nextTxs);

                if (!(nextTxs.length < 25)) {
                  _context9.next = 10;
                  break;
                }

                return _context9.abrupt("break", 12);

              case 10:
                lastSeenTxid = nextTxs[nextTxs.length - 1].txid;

              case 11:
                if (lastSeenTxid) {
                  _context9.next = 2;
                  break;
                }

              case 12:
                return _context9.abrupt("return", txs);

              case 13:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));

      return function (_x11) {
        return _ref3.apply(this, arguments);
      };
    }();
  };

  _proto.fetch25newestTxsForAddress = /*#__PURE__*/function () {
    var _fetch25newestTxsForAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(address, lastSeenTxid) {
      var url, response;
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              url = this.electrsURL + "/address/" + address + "/txs/chain";

              if (lastSeenTxid) {
                url += "/" + lastSeenTxid;
              }

              _context10.next = 4;
              return this.axios.get(url);

            case 4:
              response = _context10.sent;
              return _context10.abrupt("return", response.data);

            case 6:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function fetch25newestTxsForAddress(_x12, _x13) {
      return _fetch25newestTxsForAddress.apply(this, arguments);
    }

    return fetch25newestTxsForAddress;
  }();

  _proto.outpointToUtxo = function outpointToUtxo() {
    var _this7 = this;

    return /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(outpoint) {
        var prevoutHex, prevout;
        return runtime_1.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return _this7.fetchTxHex(outpoint.txid);

              case 2:
                prevoutHex = _context11.sent;
                prevout = liquidjsLib.Transaction.fromHex(prevoutHex).outs[outpoint.vout];
                return _context11.abrupt("return", _extends({}, outpoint, {
                  prevout: prevout
                }));

              case 5:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11);
      }));

      return function (_x14) {
        return _ref4.apply(this, arguments);
      };
    }();
  };

  return Electrs;
}(); // https://electrs-batch-server.vulpem.com/

var ElectrsBatchServer = /*#__PURE__*/function (_Electrs) {
  _inheritsLoose(ElectrsBatchServer, _Electrs);

  function ElectrsBatchServer(batchServerURL, electrsURL, axiosIns) {
    var _this8;

    _this8 = _Electrs.call(this, electrsURL, axiosIns) || this;
    _this8.batchServerURL = batchServerURL;
    _this8.electrsURL = electrsURL;
    return _this8;
  }

  ElectrsBatchServer.fromURL = function fromURL(_) {
    throw new Error('Not implemented: use Electrs.fromURL or ElectrsBatchServer.fromURLs instead');
  };

  ElectrsBatchServer.fromURLs = function fromURLs(url, electrsUrl) {
    return new ElectrsBatchServer(url, electrsUrl);
  };

  var _proto2 = ElectrsBatchServer.prototype;

  _proto2.addressesHasBeenUsed = /*#__PURE__*/function () {
    var _addressesHasBeenUsed2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(addresses) {
      var response, results, _iterator, _step, transaction;

      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return this.axios.post(this.batchServerURL + "/addresses/transactions", {
                addresses: addresses
              });

            case 2:
              response = _context12.sent;
              results = [];

              for (_iterator = _createForOfIteratorHelperLoose(response.data); !(_step = _iterator()).done;) {
                transaction = _step.value.transaction;
                results.push(transaction.length > 0);
              }

              return _context12.abrupt("return", results);

            case 6:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function addressesHasBeenUsed(_x15) {
      return _addressesHasBeenUsed2.apply(this, arguments);
    }

    return addressesHasBeenUsed;
  }();

  _proto2.fetchUtxos = /*#__PURE__*/function () {
    var _fetchUtxos2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13(addresses, skip) {
      var response, utxos, _iterator2, _step2, utxo;

      return runtime_1.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              _context13.next = 2;
              return this.axios.post(this.batchServerURL + "/addresses/utxo", {
                addresses: addresses
              });

            case 2:
              response = _context13.sent;

              if (!(response.status !== 200)) {
                _context13.next = 5;
                break;
              }

              throw new Error("Error fetching utxos: " + response.status);

            case 5:
              if (!(!response.data || !Array.isArray(response.data))) {
                _context13.next = 7;
                break;
              }

              throw new Error('Invalid response from batch server');

            case 7:
              utxos = [];
              _iterator2 = _createForOfIteratorHelperLoose(response.data);

            case 9:
              if ((_step2 = _iterator2()).done) {
                _context13.next = 18;
                break;
              }

              utxo = _step2.value.utxo;

              if (Array.isArray(utxo)) {
                _context13.next = 13;
                break;
              }

              return _context13.abrupt("continue", 16);

            case 13:
              if (!(utxo.length === 0)) {
                _context13.next = 15;
                break;
              }

              return _context13.abrupt("continue", 16);

            case 15:
              utxos.push.apply(utxos, utxo);

            case 16:
              _context13.next = 9;
              break;

            case 18:
              _context13.next = 20;
              return Promise.all(utxos.filter(function (u) {
                return skip ? !skip(u) : true;
              }).map(_Electrs.prototype.outpointToUtxo.call(this)));

            case 20:
              return _context13.abrupt("return", _context13.sent);

            case 21:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13, this);
    }));

    function fetchUtxos(_x16, _x17) {
      return _fetchUtxos2.apply(this, arguments);
    }

    return fetchUtxos;
  }();

  _proto2.fetchTxsHex = /*#__PURE__*/function () {
    var _fetchTxsHex2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(txids) {
      var response;
      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return this.axios.post(this.batchServerURL + "/transactions/hex", {
                txids: txids
              });

            case 2:
              response = _context14.sent;
              return _context14.abrupt("return", response.data || []);

            case 4:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, this);
    }));

    function fetchTxsHex(_x18) {
      return _fetchTxsHex2.apply(this, arguments);
    }

    return fetchTxsHex;
  }();

  _proto2.fetchTxs = /*#__PURE__*/function () {
    var _fetchTxs2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(addresses, skip) {
      var _this9 = this;

      var response, promises, _iterator3, _step3, transaction;

      return runtime_1.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              _context15.next = 2;
              return this.axios.post(this.batchServerURL + "/addresses/transactions", {
                addresses: addresses
              });

            case 2:
              response = _context15.sent;
              promises = [];
              _iterator3 = _createForOfIteratorHelperLoose(response.data);

            case 5:
              if ((_step3 = _iterator3()).done) {
                _context15.next = 12;
                break;
              }

              transaction = _step3.value.transaction;

              if (!(transaction.length === 0)) {
                _context15.next = 9;
                break;
              }

              return _context15.abrupt("continue", 10);

            case 9:
              promises.push.apply(promises, transaction.filter(function (tx) {
                return skip ? !skip(tx) : true;
              }).map(esploraTxToTxInterface$1(function (ids) {
                return _this9.fetchTxsHex(ids);
              })));

            case 10:
              _context15.next = 5;
              break;

            case 12:
              return _context15.abrupt("return", Promise.all(promises));

            case 13:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15, this);
    }));

    function fetchTxs(_x19, _x20) {
      return _fetchTxs2.apply(this, arguments);
    }

    return fetchTxs;
  }();

  return ElectrsBatchServer;
}(Electrs); // util function for output mapping

function makeOutput$1(outpoint, txOutput) {
  return _extends({}, outpoint, {
    prevout: txOutput
  });
}

function esploraTxToTxInterface$1(fetchTxFn) {
  return /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16(esploraTx) {
      var _transactions$find;

      var transactions, makePrevout, txInputs, txHex, transaction, makeOutpoint, makeOutputFromTxout, txOutputs, tx;
      return runtime_1.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              _context16.next = 2;
              return fetchTxFn([].concat(esploraTx.vin.filter(function (input) {
                return !input.is_pegin;
              }).map(function (i) {
                return i.txid;
              }), [esploraTx.txid]));

            case 2:
              transactions = _context16.sent;

              makePrevout = function makePrevout(_ref6) {
                var txid = _ref6.txid,
                    vout = _ref6.vout;
                var hex = transactions == null ? void 0 : transactions.find(function (t) {
                  return t.txid === txid;
                });
                if (!hex) throw new Error("Could not find tx " + txid);
                var prevout = liquidjsLib.Transaction.fromHex(hex.hex).outs[vout];
                return makeOutput$1({
                  txid: txid,
                  vout: vout
                }, prevout);
              };

              txInputs = esploraTx.vin.map(function (input) {
                return {
                  prevout: input.is_pegin ? undefined : makePrevout(input),
                  txid: input.txid,
                  vout: input.vout,
                  isPegin: input.is_pegin
                };
              });
              txHex = transactions == null ? void 0 : (_transactions$find = transactions.find(function (t) {
                return t.txid === esploraTx.txid;
              })) == null ? void 0 : _transactions$find.hex;

              if (txHex) {
                _context16.next = 8;
                break;
              }

              throw new Error("Could not find tx " + esploraTx.txid);

            case 8:
              transaction = liquidjsLib.Transaction.fromHex(txHex);

              makeOutpoint = function makeOutpoint(index) {
                return {
                  txid: esploraTx.txid,
                  vout: index
                };
              };

              makeOutputFromTxout = function makeOutputFromTxout(txout, index) {
                return makeOutput$1(makeOutpoint(index), txout);
              };

              txOutputs = transaction.outs.map(makeOutputFromTxout);
              tx = {
                txid: esploraTx.txid,
                vin: txInputs,
                vout: txOutputs,
                fee: esploraTx.fee,
                status: {
                  confirmed: esploraTx.status.confirmed,
                  blockHash: esploraTx.status.block_hash,
                  blockHeight: esploraTx.status.block_height,
                  blockTime: esploraTx.status.block_time
                }
              };
              return _context16.abrupt("return", tx);

            case 14:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16);
    }));

    return function (_x21) {
      return _ref5.apply(this, arguments);
    };
  }();
}

function craftSingleRecipientPset(unspents, recipient, coinSelector, changeAddressByAsset, substractFeeFromRecipient, satsPerByte) {
  if (substractFeeFromRecipient === void 0) {
    substractFeeFromRecipient = false;
  }

  if (satsPerByte === void 0) {
    satsPerByte = DEFAULT_SATS_PER_BYTE;
  }

  var network = liquidjsLib.address.getNetwork(recipient.address);
  var substractScenario = substractFeeFromRecipient && recipient.asset === network.assetHash;
  var firstSelection = coinSelector(throwErrorHandler)(unspents, [recipient], changeAddressByAsset);
  var fee = createFeeOutput(firstSelection.selectedUtxos.length, // Change outputs + 1 recipient + 1 fee
  firstSelection.changeOutputs.length + 2, satsPerByte, network.assetHash);
  var errorHandler = throwErrorHandler;

  if (substractScenario) {
    errorHandler = function errorHandler(asset, need, has) {
      if (asset === recipient.asset) {
        recipient.value = has - fee.value;
        return;
      } // do not throw error if not enougt fund with recipient's asset.


      throwErrorHandler(asset, need, has);
    };
  }

  var _coinSelector = coinSelector(errorHandler)(unspents, [recipient, fee], changeAddressByAsset),
      selectedUtxos = _coinSelector.selectedUtxos,
      changeOutputs = _coinSelector.changeOutputs;

  var outs = [recipient].concat(changeOutputs, [fee]);
  checkCoinSelect(outs)(selectedUtxos);
  return addToTx(new liquidjsLib.Psbt({
    network: network
  }).toBase64(), selectedUtxos, outs);
}
var DEFAULT_SATS_PER_BYTE = 0.1;

function validateAndProcess(args) {
  if (!args.satsPerByte) {
    args.satsPerByte = DEFAULT_SATS_PER_BYTE;
  }

  if (!args.errorHandler) {
    args.errorHandler = throwErrorHandler;
  }

  if (!args.addFee) {
    args.addFee = false;
  }

  if (args.addFee && args.satsPerByte < 0.1) {
    throw new Error('satsPerByte minimum value is 0.1');
  }

  if (args.recipients.length === 0) {
    throw new Error('need a least one recipient output to build the transaction');
  }

  if (args.unspents.length === 0) {
    throw new Error('need at least one unspent to fund the transaction');
  }

  return args;
}
/**
 * buildTx selects utxos among unspents to fill outputs' requirements,
 * then it adds the associated inputs and outputs to the tx.
 * finally it returns the new pset base64 encoded.
 * @param args buildTxArgs wraps arguments
 */


function craftMultipleRecipientsPset(args) {
  // validate and deconstruct args object
  var _validateAndProcess = validateAndProcess(args),
      changeAddressByAsset = _validateAndProcess.changeAddressByAsset,
      coinSelector = _validateAndProcess.coinSelector,
      psetBase64 = _validateAndProcess.psetBase64,
      recipients = _validateAndProcess.recipients,
      unspents = _validateAndProcess.unspents,
      addFee = _validateAndProcess.addFee,
      satsPerByte = _validateAndProcess.satsPerByte,
      errorHandler = _validateAndProcess.errorHandler;

  var firstSelection = coinSelector(errorHandler)(unspents, recipients, changeAddressByAsset); // if not fee, just add selected unspents as inputs and specified outputs + change outputs to pset

  if (!addFee) {
    var _outs = recipients.concat(firstSelection.changeOutputs);

    checkCoinSelect(_outs)(firstSelection.selectedUtxos);
    return addToTx(psetBase64, firstSelection.selectedUtxos, _outs);
  } // otherwise, handle the fee output


  var fee = createFeeOutputFromPset(psetBase64, firstSelection, recipients, satsPerByte);

  var _coinSelector2 = coinSelector(errorHandler)(unspents, [].concat(recipients, [fee]), changeAddressByAsset),
      changeOutputs = _coinSelector2.changeOutputs,
      selectedUtxos = _coinSelector2.selectedUtxos;

  var outs = [].concat(recipients, changeOutputs, [fee]); // check that input amount = output amount and input assets = output assets

  checkCoinSelect(outs)(selectedUtxos);
  return addToTx(psetBase64, selectedUtxos, outs);
}

function createFeeOutputFromPset(psetBase64, firstSelection, recipients, satsPerByte) {
  var pset = decodePset(psetBase64);
  var nbInputs = pset.data.inputs.length + firstSelection.selectedUtxos.length + 1;
  var nbOutputs = pset.data.outputs.length + recipients.length + firstSelection.changeOutputs.length + 1;
  var feeAssetHash = liquidjsLib.address.getNetwork(recipients[0].address).assetHash;
  var fee = createFeeOutput(nbInputs, nbOutputs, satsPerByte, feeAssetHash);
  return fee;
} // this function create a recipient interface for Fee output using tx size estimation


function createFeeOutput(numInputs, numOutputs, satsPerByte, assetHash) {
  var sizeEstimation = estimateTxSize(numInputs, numOutputs);
  var feeEstimation = Math.ceil(sizeEstimation * satsPerByte);
  return {
    asset: assetHash,
    value: feeEstimation,
    address: ''
  };
}
function addToTx(psetBase64, unspents, recipients) {
  var pset = decodePset(psetBase64);
  var nonce = Buffer.alloc(1);

  for (var _iterator = _createForOfIteratorHelperLoose(recipients), _step; !(_step = _iterator()).done;) {
    var _step$value = _step.value,
        asset = _step$value.asset,
        value = _step$value.value,
        address = _step$value.address;
    var script = address === '' ? Buffer.alloc(0) : liquidjsLib.address.toOutputScript(address);
    pset.addOutput({
      asset: liquidjsLib.AssetHash.fromHex(asset, false).bytes,
      value: liquidjsLib.confidential.satoshiToConfidentialValue(value),
      script: script,
      nonce: nonce
    });
  }

  for (var _iterator2 = _createForOfIteratorHelperLoose(unspents), _step2; !(_step2 = _iterator2()).done;) {
    var unspent = _step2.value;
    pset.addInput({
      hash: unspent.txid,
      index: unspent.vout,
      witnessUtxo: unspent.prevout
    });
  }

  return pset.toBase64();
} // estimate segwit transaction size in bytes depending on number of inputs and outputs

function estimateTxSize(numInputs, numOutputs) {
  var base = calcTxSize(false, numInputs, numOutputs, false);
  var total = calcTxSize(true, numInputs, numOutputs, true);
  var weight = base * 3 + total;
  var vsize = (weight + 3) / 4;
  return vsize;
}

function calcTxSize(withWitness, numInputs, numOutputs, isConfidential) {
  var inputsSize = calcInputsSize(withWitness, numInputs);
  var outputsSize = calcOutputsSize(isConfidential, numOutputs);
  return 9 + varIntSerializeSize(numOutputs) + varIntSerializeSize(numInputs) + inputsSize + outputsSize;
}

function calcInputsSize(withWitness, numInputs) {
  // prevout hash + prevout index
  var size = (32 + 8) * numInputs;

  if (withWitness) {
    // scriptsig + pubkey
    size += numInputs * (72 + 33);
  }

  return size;
}

function calcOutputsSize(isConfidential, numOutputs) {
  // asset + value + empty nonce
  var baseOutputSize = 33 + 33 + 1;
  var size = baseOutputSize * numOutputs;

  if (isConfidential) {
    // rangeproof + surjectionproof + 32 bytes for nonce
    size += (4174 + 67 + 32) * numOutputs;
  } // fee asset + fee empty nonce + fee value


  size += 33 + 1 + 9;
  return size;
}

function varIntSerializeSize(val) {
  var maxUINT16 = 65535;
  var maxUINT32 = 4294967295;

  if (val < 0xfd) {
    return 1;
  }

  if (val <= maxUINT16) {
    return 3;
  }

  if (val <= maxUINT32) {
    return 5;
  }

  return 9;
}

/**
 * Implementation of Wallet Interface.
 * @member network type of network (regtest...)
 * @member addresses list of AddressInterface.
 * @method createTx init empty PSET.
 * @method updateTx update a PSET with outputs and inputs (for Swap tx).
 */

var Wallet = /*#__PURE__*/function () {
  function Wallet(unspents, network) {
    this.network = network;
    this.unspents = unspents;
  }
  /**
   * Returns an empty liquidjs lib Psbt instance.
   */


  var _proto = Wallet.prototype;

  _proto.createTx = function createTx() {
    var pset = new liquidjsLib.Psbt({
      network: this.network
    });
    return pset.toBase64();
  };

  _proto.buildTx = function buildTx(psetBase64, recipients, coinSelector, changeAddressByAsset, addFee, satsPerByte) {
    var args = {
      psetBase64: psetBase64,
      recipients: recipients,
      coinSelector: coinSelector,
      changeAddressByAsset: changeAddressByAsset,
      addFee: addFee,
      satsPerByte: satsPerByte,
      unspents: this.unspents
    };
    return craftMultipleRecipientsPset(args);
  };

  _proto.sendTx = function sendTx(recipient, coinSelector, changeAddressByAsset, substractFee, satsPerByte) {
    if (substractFee === void 0) {
      substractFee = false;
    }

    if (satsPerByte === void 0) {
      satsPerByte = DEFAULT_SATS_PER_BYTE;
    }

    return craftSingleRecipientPset(this.unspents, recipient, coinSelector, changeAddressByAsset, substractFee, satsPerByte);
  };

  return Wallet;
}();
/**
 * Factory: list of addresses --to--> Wallet
 * @param addresses a list of addressInterface.
 * @param explorerUrl the esplora endpoint used to fetch addresses's utxos
 * @param network network type
 */

function walletFromAddresses(_x, _x2, _x3, _x4) {
  return _walletFromAddresses.apply(this, arguments);
}

function _walletFromAddresses() {
  _walletFromAddresses = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(ecclib, addresses, explorerUrl, network) {
    var utxos;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return fetchAndUnblindUtxos(ecclib, addresses, explorerUrl);

          case 2:
            utxos = _context.sent;
            return _context.abrupt("return", walletFromCoins(utxos, network));

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _walletFromAddresses.apply(this, arguments);
}

function walletFromCoins(coins, network) {
  return new Wallet(coins, getNetwork(network));
}

/**
 * reduces the set of unspents in order to compute sats grouped by assets.
 * @param unspents the utxos to reduce
 */

function balances(unspents) {
  var unspentsByAsset = groupBy(unspents, getAsset);
  var balances = {};

  for (var _i = 0, _Object$entries = Object.entries(unspentsByAsset); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _Object$entries[_i],
        asset = _Object$entries$_i[0],
        utxos = _Object$entries$_i[1];
    balances[asset] = sumSats(utxos);
  }

  return balances;
}

function sumSats(unspents) {
  return unspents.reduce(function (acc, utxo) {
    return acc + getSats(utxo);
  }, 0);
}

/**
 * iterates through pset's inputs and try to find the prevout blinders.
 * @param pset the unsigned pset to blind
 * @param utxos a set of coins (should contain all the pset prevouts to build the whole map)
 * @returns a map inputIndex => blinders data which can be used as input of blindOutputByIndex.
 */

function inputBlindingDataMap(pset, utxos) {
  var inputBlindingData = new Map();

  var txidToBuffer = function txidToBuffer(txid) {
    return Buffer.from(txid, 'hex').reverse();
  };

  var index = -1;

  var _loop = function _loop() {
    var input = _step.value;
    index++;
    var utxo = utxos.find(function (u) {
      return txidToBuffer(u.txid).equals(input.hash) && u.vout === input.index;
    }); // only add unblind data if the prevout of the input is confidential

    if (utxo && utxo.unblindData && isConfidentialOutput(utxo.prevout)) {
      inputBlindingData.set(index, utxo.unblindData);
    }
  };

  for (var _iterator = _createForOfIteratorHelperLoose(psetToUnsignedTx(pset).ins), _step; !(_step = _iterator()).done;) {
    _loop();
  }

  return inputBlindingData;
}
/**
 * find the blinding public key associated with output script using a set of addresses.
 * @param pset the unsigned pset to blind
 * @param outputAddresses a set of addresses used to craft the pset outputs.
 * @returns the blinding public mapped to output index. Can be used as input in blindOutputByIndex.
 */

function outputBlindingPubkeysMap(pset, outputAddresses) {
  var outPubkeys = new Map();

  for (var _iterator2 = _createForOfIteratorHelperLoose(outputAddresses), _step2; !(_step2 = _iterator2()).done;) {
    var outAddress = _step2.value;
    var index = outputIndexFromAddress(pset, outAddress);
    if (index === -1) continue;

    if (isConfidentialAddress(outAddress)) {
      outPubkeys.set(index, blindingKeyFromAddress(outAddress));
    }
  }

  return outPubkeys;
}

function outputIndexFromAddress(tx, addressToFind) {
  var utx = psetToUnsignedTx(tx);
  var recipientScript = liquidjsLib.address.toOutputScript(addressToFind);
  return utx.outs.findIndex(function (out) {
    return out.script.equals(recipientScript);
  });
}

function isConfidentialAddress(addr) {
  try {
    liquidjsLib.address.fromConfidential(addr);
    return true;
  } catch (ignore) {
    return false;
  }
}

function blindingKeyFromAddress(addr) {
  return liquidjsLib.address.fromConfidential(addr).blindingKey;
}

var BLOCKSTREAM_ESPLORA_ENDPOINT = 'https://blockstream.info/liquid/api';
function restorerFromEsplora(identity, getAddress) {
  return /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(_ref) {
      var _ref$esploraURL, esploraURL, _ref$gapLimit, gapLimit, restoreFunc, restorerExternal, restorerInternal, _yield$Promise$all, lastUsedExternalIndex, lastUsedInternalIndex;

      return runtime_1.wrap(function _callee2$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _ref$esploraURL = _ref.esploraURL, esploraURL = _ref$esploraURL === void 0 ? BLOCKSTREAM_ESPLORA_ENDPOINT : _ref$esploraURL, _ref$gapLimit = _ref.gapLimit, gapLimit = _ref$gapLimit === void 0 ? 20 : _ref$gapLimit;

              restoreFunc = /*#__PURE__*/function () {
                var _ref3 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(getAddrFunc) {
                  var counter, next, maxIndex, _loop, _ret;

                  return runtime_1.wrap(function _callee$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          counter = 0;
                          next = 0;
                          maxIndex = undefined;
                          _loop = /*#__PURE__*/runtime_1.mark(function _loop() {
                            var cpyNext, addrs, hasBeenUsedArray, indexInArray, _iterator, _step, hasBeenUsed;

                            return runtime_1.wrap(function _loop$(_context) {
                              while (1) {
                                switch (_context.prev = _context.next) {
                                  case 0:
                                    cpyNext = next; // generate a set of addresses from next to (next + gapLimit - 1)

                                    _context.next = 3;
                                    return Promise.all(Array.from(Array(gapLimit).keys()).map(function (i) {
                                      return i + cpyNext;
                                    }).map(getAddrFunc));

                                  case 3:
                                    addrs = _context.sent;
                                    _context.next = 6;
                                    return Promise.all(addrs.map(function (a) {
                                      return addressHasBeenUsed(a, esploraURL);
                                    }));

                                  case 6:
                                    hasBeenUsedArray = _context.sent;
                                    indexInArray = 0;
                                    _iterator = _createForOfIteratorHelperLoose(hasBeenUsedArray);

                                  case 9:
                                    if ((_step = _iterator()).done) {
                                      _context.next = 22;
                                      break;
                                    }

                                    hasBeenUsed = _step.value;

                                    if (!hasBeenUsed) {
                                      _context.next = 16;
                                      break;
                                    }

                                    maxIndex = indexInArray + next;
                                    counter = 0;
                                    _context.next = 19;
                                    break;

                                  case 16:
                                    counter++;

                                    if (!(counter === gapLimit)) {
                                      _context.next = 19;
                                      break;
                                    }

                                    return _context.abrupt("return", {
                                      v: maxIndex
                                    });

                                  case 19:
                                    indexInArray++;

                                  case 20:
                                    _context.next = 9;
                                    break;

                                  case 22:
                                    next += gapLimit; // increase next

                                  case 23:
                                  case "end":
                                    return _context.stop();
                                }
                              }
                            }, _loop);
                          });

                        case 4:
                          if (!(counter < gapLimit)) {
                            _context2.next = 11;
                            break;
                          }

                          return _context2.delegateYield(_loop(), "t0", 6);

                        case 6:
                          _ret = _context2.t0;

                          if (!(typeof _ret === "object")) {
                            _context2.next = 9;
                            break;
                          }

                          return _context2.abrupt("return", _ret.v);

                        case 9:
                          _context2.next = 4;
                          break;

                        case 11:
                          return _context2.abrupt("return", maxIndex);

                        case 12:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee);
                }));

                return function restoreFunc(_x2) {
                  return _ref3.apply(this, arguments);
                };
              }();

              restorerExternal = restoreFunc(function (index) {
                return Promise.resolve(getAddress(false, index));
              });
              restorerInternal = restoreFunc(function (index) {
                return Promise.resolve(getAddress(true, index));
              });
              _context3.next = 6;
              return Promise.all([restorerExternal, restorerInternal]);

            case 6:
              _yield$Promise$all = _context3.sent;
              lastUsedExternalIndex = _yield$Promise$all[0];
              lastUsedInternalIndex = _yield$Promise$all[1];
              return _context3.abrupt("return", restorerFromState(identity)({
                lastUsedExternalIndex: lastUsedExternalIndex,
                lastUsedInternalIndex: lastUsedInternalIndex
              }));

            case 10:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }();
}

function addressHasBeenUsed(_x3, _x4) {
  return _addressHasBeenUsed.apply(this, arguments);
}
/**
 * build an async esplora restorer for a specific mnemonic
 * @param mnemonicToRestore
 */


function _addressHasBeenUsed() {
  _addressHasBeenUsed = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(address, esploraURL) {
    var data;
    return runtime_1.wrap(function _callee4$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return axios.get(esploraURL + "/address/" + address + "/txs");

          case 3:
            data = _context5.sent.data;
            return _context5.abrupt("return", data.length > 0);

          case 7:
            _context5.prev = 7;
            _context5.t0 = _context5["catch"](0);
            return _context5.abrupt("return", false);

          case 10:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee4, null, [[0, 7]]);
  }));
  return _addressHasBeenUsed.apply(this, arguments);
}

function mnemonicRestorerFromEsplora(mnemonicToRestore) {
  return restorerFromEsplora(mnemonicToRestore, function (isChange, index) {
    return mnemonicToRestore.getAddress(isChange, index).address.confidentialAddress;
  });
}
/**
 * build an async esplora restorer for a specific masterPubKey
 * @param toRestore
 */

function masterPubKeyRestorerFromEsplora(toRestore) {
  return restorerFromEsplora(toRestore, function (isChange, index) {
    return toRestore.getAddress(isChange, index).address.confidentialAddress;
  });
}
/**
 * build an async esplora restorer for a MultisigWatchOnly
 * @param toRestore
 */

function multisigWatchOnlyFromEsplora(toRestore) {
  return restorerFromEsplora(toRestore, function (isChange, index) {
    return toRestore.getMultisigAddress(isChange ? MultisigWatchOnly.INTERNAL_INDEX : MultisigWatchOnly.EXTERNAL_INDEX, index).confidentialAddress;
  });
}
/**
 * build an async esplora restorer for a Multisig
 * @param toRestore
 */

function multisigFromEsplora(toRestore) {
  return restorerFromEsplora(toRestore, function (isChange, index) {
    return toRestore.getMultisigAddress(isChange ? MultisigWatchOnly.INTERNAL_INDEX : MultisigWatchOnly.EXTERNAL_INDEX, index).confidentialAddress;
  });
}
function restorerFromState(identity) {
  return /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(_ref4) {
      var lastUsedExternalIndex, lastUsedInternalIndex, promises, i, promise, _i, _promise;

      return runtime_1.wrap(function _callee3$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              lastUsedExternalIndex = _ref4.lastUsedExternalIndex, lastUsedInternalIndex = _ref4.lastUsedInternalIndex;
              promises = [];

              if (lastUsedExternalIndex !== undefined) {
                for (i = 0; i <= lastUsedExternalIndex; i++) {
                  promise = identity.getNextAddress();
                  promises.push(promise);
                }
              }

              if (lastUsedInternalIndex !== undefined) {
                for (_i = 0; _i <= lastUsedInternalIndex; _i++) {
                  _promise = identity.getNextChangeAddress();
                  promises.push(_promise);
                }
              }

              _context4.next = 6;
              return Promise.all(promises);

            case 6:
              return _context4.abrupt("return", identity);

            case 7:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee3);
    }));

    return function (_x5) {
      return _ref5.apply(this, arguments);
    };
  }();
}
/**
 * create a restorer from state for a given mnemonic
 * @param toRestore
 */

function mnemonicRestorerFromState(toRestore) {
  return restorerFromState(toRestore);
}
/**
 * create a restorer from state for a given mnemonic
 * @param toRestore
 */

function masterPubKeyRestorerFromState(toRestore) {
  return restorerFromState(toRestore);
}

function makeRestorerFromChainAPI(id, getAddress) {
  return /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(_ref) {
      var gapLimit, api, restoreFunc, restorerExternal, restorerInternal, _yield$Promise$all, lastUsedExternalIndex, lastUsedInternalIndex;

      return runtime_1.wrap(function _callee2$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              gapLimit = _ref.gapLimit, api = _ref.api;

              restoreFunc = /*#__PURE__*/function () {
                var _ref3 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(getAddrFunc) {
                  var counter, next, maxIndex, _loop, _ret;

                  return runtime_1.wrap(function _callee$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          counter = 0;
                          next = 0;
                          maxIndex = undefined;
                          _loop = /*#__PURE__*/runtime_1.mark(function _loop() {
                            var cpyNext, addrs, hasBeenUsedArray, indexInArray, _iterator, _step, hasBeenUsed;

                            return runtime_1.wrap(function _loop$(_context) {
                              while (1) {
                                switch (_context.prev = _context.next) {
                                  case 0:
                                    cpyNext = next; // generate a set of addresses from next to (next + gapLimit - 1)

                                    _context.next = 3;
                                    return Promise.all(Array.from(Array(gapLimit).keys()).map(function (i) {
                                      return i + cpyNext;
                                    }).map(getAddrFunc));

                                  case 3:
                                    addrs = _context.sent;
                                    _context.next = 6;
                                    return api.addressesHasBeenUsed(addrs);

                                  case 6:
                                    hasBeenUsedArray = _context.sent;
                                    indexInArray = 0;
                                    _iterator = _createForOfIteratorHelperLoose(hasBeenUsedArray);

                                  case 9:
                                    if ((_step = _iterator()).done) {
                                      _context.next = 22;
                                      break;
                                    }

                                    hasBeenUsed = _step.value;

                                    if (!hasBeenUsed) {
                                      _context.next = 16;
                                      break;
                                    }

                                    maxIndex = indexInArray + next;
                                    counter = 0;
                                    _context.next = 19;
                                    break;

                                  case 16:
                                    counter++;

                                    if (!(counter === gapLimit)) {
                                      _context.next = 19;
                                      break;
                                    }

                                    return _context.abrupt("return", {
                                      v: maxIndex
                                    });

                                  case 19:
                                    indexInArray++;

                                  case 20:
                                    _context.next = 9;
                                    break;

                                  case 22:
                                    next += gapLimit; // increase next

                                  case 23:
                                  case "end":
                                    return _context.stop();
                                }
                              }
                            }, _loop);
                          });

                        case 4:
                          if (!(counter < gapLimit)) {
                            _context2.next = 11;
                            break;
                          }

                          return _context2.delegateYield(_loop(), "t0", 6);

                        case 6:
                          _ret = _context2.t0;

                          if (!(typeof _ret === "object")) {
                            _context2.next = 9;
                            break;
                          }

                          return _context2.abrupt("return", _ret.v);

                        case 9:
                          _context2.next = 4;
                          break;

                        case 11:
                          return _context2.abrupt("return", maxIndex);

                        case 12:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee);
                }));

                return function restoreFunc(_x2) {
                  return _ref3.apply(this, arguments);
                };
              }();

              restorerExternal = restoreFunc(function (index) {
                return Promise.resolve(getAddress(false, index));
              });
              restorerInternal = restoreFunc(function (index) {
                return Promise.resolve(getAddress(true, index));
              });
              _context3.next = 6;
              return Promise.all([restorerExternal, restorerInternal]);

            case 6:
              _yield$Promise$all = _context3.sent;
              lastUsedExternalIndex = _yield$Promise$all[0];
              lastUsedInternalIndex = _yield$Promise$all[1];
              return _context3.abrupt("return", restorerFromState(id)({
                lastUsedExternalIndex: lastUsedExternalIndex,
                lastUsedInternalIndex: lastUsedInternalIndex
              }));

            case 10:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }();
}

function mnemonicRestorerFromChain(mnemonicToRestore) {
  return makeRestorerFromChainAPI(mnemonicToRestore, function (isChange, index) {
    return mnemonicToRestore.getAddress(isChange, index).address.confidentialAddress;
  });
}

var OPS = liquidjsLib.script.OPS;
var NEED_PARAMS_OPCODES = [OPS.OP_PUSHDATA1, OPS.OP_PUSHDATA2, OPS.OP_PUSHDATA4, OPS.OP_1NEGATE, OPS.OP_RESERVED, OPS.OP_IF, OPS.OP_VERIF, OPS.OP_VERNOTIF, OPS.OP_ELSE, OPS.OP_ENDIF, OPS.OP_VERIFY, OPS.OP_TOALTSTACK, OPS.OP_FROMALTSTACK, OPS.OP_2DROP, OPS.OP_2DUP, OPS.OP_3DUP, OPS.OP_2OVER, OPS.OP_2ROT, OPS.OP_2SWAP, OPS.OP_NIP, OPS.OP_OVER, OPS.OP_PICK, OPS.OP_ROLL, OPS.OP_ROT, OPS.OP_SWAP, OPS.OP_TUCK, OPS.OP_CAT, OPS.OP_SUBSTR, OPS.OP_SUBSTR_LAZY, OPS.OP_LEFT, OPS.OP_RIGHT, OPS.OP_SIZE, OPS.OP_INVERT, OPS.OP_AND, OPS.OP_OR, OPS.OP_XOR, OPS.OP_EQUAL, OPS.OP_EQUALVERIFY, OPS.OP_RESERVED1, OPS.OP_RESERVED2, OPS.OP_1ADD, OPS.OP_1SUB, OPS.OP_2MUL, OPS.OP_2DIV, OPS.OP_NEGATE, OPS.OP_ABS, OPS.OP_NOT, OPS.OP_0NOTEQUAL, OPS.OP_ADD, OPS.OP_SUB, OPS.OP_MUL, OPS.OP_DIV, OPS.OP_MOD, OPS.OP_LSHIFT, OPS.OP_RSHIFT, OPS.OP_BOOLAND, OPS.OP_BOOLOR, OPS.OP_NUMEQUAL, OPS.OP_NUMEQUALVERIFY, OPS.OP_NUMNOTEQUAL, OPS.OP_LESSTHAN, OPS.OP_GREATERTHAN, OPS.OP_LESSTHANOREQUAL, OPS.OP_GREATERTHANOREQUAL, OPS.OP_MIN, OPS.OP_MAX, OPS.OP_WITHIN, OPS.OP_RIPEMD160, OPS.OP_SHA1, OPS.OP_SHA256, OPS.OP_HASH160, OPS.OP_HASH256, OPS.OP_CODESEPARATOR, OPS.OP_CHECKMULTISIG, OPS.OP_CHECKMULTISIGVERIFY, OPS.OP_DETERMINISTICRANDOM, OPS.OP_SHA256INITIALIZE, OPS.OP_SHA256UPDATE, OPS.OP_SHA256FINALIZE, OPS.OP_ADD64, OPS.OP_SUB64, OPS.OP_MUL64, OPS.OP_DIV64, OPS.OP_NEG64, OPS.OP_LESSTHAN64, OPS.OP_LESSTHANOREQUAL64, OPS.OP_GREATERTHAN64, OPS.OP_GREATERTHANOREQUAL64, OPS.OP_SCRIPTNUMTOLE64, OPS.OP_LE64TOSCRIPTNUM, OPS.OP_LE32TOLE64, OPS.OP_ECMULSCALARVERIFY, OPS.OP_TWEAKVERIFY, OPS.OP_PUBKEYHASH, OPS.OP_PUBKEY, OPS.OP_INVALIDOPCODE];
var INTROSPECTION_OPCODES = [OPS.OP_INSPECTINPUTOUTPOINT, OPS.OP_INSPECTINPUTASSET, OPS.OP_INSPECTINPUTVALUE, OPS.OP_INSPECTINPUTSCRIPTPUBKEY, OPS.OP_INSPECTINPUTSEQUENCE, OPS.OP_INSPECTINPUTISSUANCE, OPS.OP_PUSHCURRENTINPUTINDEX, OPS.OP_INSPECTOUTPUTASSET, OPS.OP_INSPECTOUTPUTVALUE, OPS.OP_INSPECTOUTPUTNONCE, OPS.OP_INSPECTOUTPUTSCRIPTPUBKEY, OPS.OP_INSPECTVERSION, OPS.OP_INSPECTLOCKTIME, OPS.OP_INSPECTNUMINPUTS, OPS.OP_INSPECTNUMOUTPUTS];

function validatePosition(stack, pos) {
  return !(pos < 0 || pos >= stack.length);
}

function mergeNeeds() {
  for (var _len = arguments.length, needs = new Array(_len), _key = 0; _key < _len; _key++) {
    needs[_key] = arguments[_key];
  }

  return {
    sigs: needs.reduce(function (acc, need) {
      return acc.concat(need.sigs);
    }, []),
    hasIntrospection: needs.reduce(function (acc, need) {
      return acc || need.hasIntrospection;
    }, false),
    needParameters: needs.reduce(function (acc, need) {
      return acc || need.needParameters;
    }, false)
  };
}

var needParametersAnalyser = function needParametersAnalyser(stack) {
  return function (pos) {
    if (!validatePosition(stack, pos)) throw new Error('Invalid position (NEED PARAM OPCODE)');
    return {
      sigs: [],
      hasIntrospection: false,
      needParameters: true
    };
  };
};

var introspectionAnalyzer = function introspectionAnalyzer(stack) {
  return function (pos) {
    if (!validatePosition(stack, pos)) throw new Error('invalid position (INTROSPECTION OPCODE)');
    return {
      sigs: [],
      hasIntrospection: true,
      needParameters: false
    };
  };
};

var checksigAnalyzer = function checksigAnalyzer(stack) {
  return function (pos) {
    if (!validatePosition(stack, pos)) throw new Error('invalid position (CHECKSIG)');

    if (!validatePosition(stack, pos - 1)) {
      return {
        sigs: [],
        hasIntrospection: false,
        needParameters: true
      };
    }

    var pubkey = stack[pos - 1];
    return {
      sigs: [{
        pubkey: pubkey.toString('hex')
      }],
      hasIntrospection: false,
      needParameters: false
    };
  };
};

var hex = function hex(n) {
  return Buffer.of(n).toString('hex');
};

var ANALYZERS_BY_OPCODE = /*#__PURE__*/new Map().set( /*#__PURE__*/hex(OPS.OP_CHECKSIG), checksigAnalyzer);
INTROSPECTION_OPCODES.forEach(function (op) {
  return ANALYZERS_BY_OPCODE.set(hex(op), introspectionAnalyzer);
});
NEED_PARAMS_OPCODES.forEach(function (op) {
  return ANALYZERS_BY_OPCODE.set(hex(op), needParametersAnalyser);
});

function decompileScript(b) {
  var _stack$map;

  var stack = liquidjsLib.script.decompile(b);
  if (stack === null) throw new Error('malformed script');
  return (_stack$map = stack == null ? void 0 : stack.map(function (s) {
    return Buffer.isBuffer(s) ? s : Buffer.of(s);
  })) != null ? _stack$map : [];
}
/**
 * Analyze a script to know what it need as input
 * @param scriptHex must be a valid Elements script
 * @returns an object describing how to build the script inputs
 */


function analyse(scriptHex) {
  var scriptBuffer = Buffer.from(scriptHex, 'hex');
  var stack = decompileScript(scriptBuffer);
  var needs = {
    sigs: [],
    hasIntrospection: false,
    needParameters: false
  };

  for (var i = 0; i < stack.length; i++) {
    var elem = stack[i].toString('hex');
    var analyser = ANALYZERS_BY_OPCODE.get(elem);
    if (!analyser) continue;
    needs = mergeNeeds(needs, analyser(stack)(i));
  }

  return needs;
}
function analyzeTapscriptTree(tree) {
  var _extends2;

  if (!tree) return {};

  var children = _extends({}, tree.left ? analyzeTapscriptTree(tree.left) : {}, tree.right ? analyzeTapscriptTree(tree.right) : {});

  if (tree.scriptHex) return _extends({}, children, (_extends2 = {}, _extends2[tree.scriptHex] = analyse(tree.scriptHex), _extends2));
  return children;
}

var TypeAST;

(function (TypeAST) {
  TypeAST[TypeAST["SCRIPT"] = 0] = "SCRIPT";
  TypeAST[TypeAST["TREE"] = 1] = "TREE";
  TypeAST[TypeAST["HEX"] = 2] = "HEX";
  TypeAST[TypeAST["KEY"] = 3] = "KEY";
})(TypeAST || (TypeAST = {}));

var ScriptType;

(function (ScriptType) {
  ScriptType["ELTR"] = "eltr";
  ScriptType["ASM"] = "asm";
  ScriptType["RAW"] = "raw";
})(ScriptType || (ScriptType = {}));

var numOfChildren = /*#__PURE__*/new Map().set(ScriptType.ELTR, 2).set(ScriptType.ASM, 1).set(ScriptType.RAW, 1);
var withoutEccCompilers = /*#__PURE__*/new Map([[ScriptType.RAW, compileRAW], [ScriptType.ASM, compileASM]]);

function compileFromEcc(ecc) {
  // map cmd to compile functions
  var compilers = withoutEccCompilers.set(ScriptType.ELTR, makeCompileELTR(liquidjsLib.bip341.BIP341Factory(ecc)));
  return function (ast) {
    return compileScript(ast, compilers, true);
  };
}

var DescriptorsCompilerFactory = function DescriptorsCompilerFactory(ecc) {
  return {
    compile: compileFromEcc(ecc)
  };
};

function checkScriptNode(ast, scriptType) {
  if (ast.type !== TypeAST.SCRIPT) {
    throw new Error('Expected script node');
  }

  if (ast.value !== scriptType) {
    throw new Error("Expected " + scriptType + " script");
  }

  if (ast.children.length !== numOfChildren.get(ast.value)) {
    throw new Error("Expected script node " + ast.type + " with " + numOfChildren.get(ast.value) + " of children");
  }
}

function compileHEX(ast) {
  if (ast.type !== TypeAST.HEX) {
    throw new Error('Expected hex node');
  }

  if (typeof ast.value !== 'string') throw new Error('Expected hex node with string value');
  var script = Buffer.from(ast.value, 'hex');
  return {
    scriptPubKey: function scriptPubKey() {
      return script;
    }
  };
} // 'raw' node


function compileRAW(ast) {
  checkScriptNode(ast, ScriptType.RAW);
  return compileHEX(ast.children[0]);
} // 'asm' node, which is a subset of raw


function compileASM(ast) {
  checkScriptNode(ast, ScriptType.ASM);
  return compileHEX(ast.children[0]);
} // this is not a ScriptCompileFunction
// recursive way to get all the leaves of the tree


function compileTREE(ast) {
  if (ast.type !== TypeAST.TREE) {
    throw new Error('Expected tree node');
  }

  var leaves = [];

  if (ast.children.length < 1 || ast.children.length > 2) {
    throw new Error('Expected tree node with 1 or 2 leaves');
  }

  for (var _iterator = _createForOfIteratorHelperLoose(ast.children), _step; !(_step = _iterator()).done;) {
    var child = _step.value;

    switch (child.type) {
      case TypeAST.SCRIPT:
        leaves.push({
          scriptHex: compileScript(child, withoutEccCompilers) // we do not expect any toplevel compilers so we can use withoutEccCompilers
          .scriptPubKey().toString('hex')
        });
        break;

      case TypeAST.TREE:
        leaves.push.apply(leaves, compileTREE(child));
        break;

      default:
        throw new Error("Expected tree node with children of type " + TypeAST.SCRIPT + " or " + TypeAST.TREE);
    }
  }

  return leaves;
}

function compileKEY(ast) {
  if (ast.type !== TypeAST.KEY) {
    throw new Error('Expected key node');
  }

  if (typeof ast.value !== 'string' && ast.value.length === 64) throw new Error('Expected key (64 hex chars)');
  return Buffer.from(ast.value, 'hex');
}

function makeCompileELTR(bip341lib) {
  return function (ast) {
    checkScriptNode(ast, ScriptType.ELTR);

    if (ast.children[0].type !== TypeAST.KEY) {
      throw new Error('Expected KEY as first argument of eltr');
    }

    if (ast.children[1].type !== TypeAST.TREE) {
      throw new Error('Expected TREE as second argument of eltr');
    }

    var internalKey = compileKEY(ast.children[0]);
    var leaves = compileTREE(ast.children[1]);
    var tree = liquidjsLib.bip341.toHashTree(leaves, true); // this is a trick for the bip341 functions (accept only prefixed keys)

    var prefixedInternalKey = Buffer.concat([Buffer.of(0x00), internalKey]); // segwit v1 scriptPubKey

    var _scriptPubKey = bip341lib.taprootOutputScript(prefixedInternalKey, tree);

    return {
      witnesses: function witnesses(leafScript) {
        var leaf = leaves.find(function (l) {
          return l.scriptHex === leafScript;
        });

        if (!leaf) {
          throw new Error('Could not find leaf script for script ' + leafScript);
        }

        var path = liquidjsLib.bip341.findScriptPath(tree, liquidjsLib.bip341.tapLeafHash(leaf));
        return bip341lib.taprootSignScriptStack(prefixedInternalKey, leaf, tree.hash, path);
      },
      scriptPubKey: function scriptPubKey() {
        return _scriptPubKey;
      },
      taprootHashTree: tree,
      taprootInternalKey: internalKey.toString('hex')
    };
  };
}

var topLevelOnly = [ScriptType.RAW, ScriptType.ELTR]; // main compile function

function compileScript(ast, compilersMap, isTop) {
  if (isTop === void 0) {
    isTop = false;
  }

  var compileFunction = compilersMap.get(ast.value);

  if (!compileFunction) {
    throw new Error("node type: " + ast.type + " is not a descriptor");
  }

  if (!isTop && topLevelOnly.includes(ast.value)) {
    throw new Error("node type: " + ast.value + " is a top level only descriptor");
  }

  return compileFunction(ast);
}

var hexRegExp = /^([A-Fa-f0-9]{2})+/;
function readHex(text) {
  return readWithRegExp(hexRegExp, text);
}

function readWithRegExp(regexp, text) {
  var match = text.match(regexp);

  if (!match) {
    return ['', text];
  }

  return [match[0], text.slice(match[0].length)];
}

function readUntil(text, _char) {
  var index = text.indexOf(_char);

  if (index === -1) {
    throw new Error("Expected " + _char);
  }

  return [text.slice(0, index), text.slice(index)];
}

var EXPECT_TOKEN = function EXPECT_TOKEN(token, got) {
  return new Error("Expected \"" + token + "\" got \"" + got + "\"");
};

function cmd(type) {
  return type.toString();
}

function compose() {
  for (var _len = arguments.length, parsers = new Array(_len), _key = 0; _key < _len; _key++) {
    parsers[_key] = arguments[_key];
  }

  return function (text) {
    var result;
    var remainingText = text.trimStart();

    for (var _iterator = _createForOfIteratorHelperLoose(parsers), _step; !(_step = _iterator()).done;) {
      var parser = _step.value;

      var _parser = parser(remainingText),
          child = _parser[0],
          _text = _parser[1];

      if (child) {
        if (result) {
          result.children.push(child);
        } else {
          result = child;
        }
      }

      remainingText = _text.trimStart();
    }

    return [result, remainingText];
  };
}

function oneOf() {
  for (var _len2 = arguments.length, parsers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    parsers[_key2] = arguments[_key2];
  }

  var errors = [];
  return function (text) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(parsers), _step2; !(_step2 = _iterator2()).done;) {
      var parser = _step2.value;

      try {
        return parser(text);
      } catch (e) {
        // ignore
        if (e instanceof Error) {
          errors.push(e);
        }
      }
    }

    throw new Error("one of: " + errors.map(function (e) {
      return e.message;
    }).join(', '));
  };
}

var parseHEX = function parseHEX(text) {
  var _readHex = readHex(text),
      hex = _readHex[0],
      remainingText = _readHex[1];

  return [{
    type: TypeAST.HEX,
    value: hex,
    children: []
  }, remainingText];
};

var parseKEY = function parseKEY(text) {
  var _readHex2 = readHex(text),
      hex = _readHex2[0],
      remainingText = _readHex2[1];

  if (hex.length !== 64) {
    throw EXPECT_TOKEN('key (hex string with len=64)', hex);
  }

  return [{
    type: TypeAST.KEY,
    value: hex,
    children: []
  }, remainingText];
};

var parseASMScript = function parseASMScript(text) {
  var _readUntil = readUntil(text, ')'),
      str = _readUntil[0],
      remainingText = _readUntil[1];

  var asmScript = liquidjsLib.script.fromASM(str);
  return [{
    type: TypeAST.HEX,
    value: asmScript.toString('hex'),
    children: []
  }, remainingText];
}; // parse a token, does not create any AST node


var parseToken = function parseToken(token) {
  return function (text) {
    if (text.startsWith(token)) {
      return [undefined, text.slice(token.length)];
    }

    throw EXPECT_TOKEN(token, text.slice(0, token.length));
  };
};

var parseTreeToken = function parseTreeToken(text) {
  var _parseToken = parseToken('{')(text),
      remainingText = _parseToken[1];

  return [{
    type: TypeAST.TREE,
    value: undefined,
    children: []
  }, remainingText];
};

var parseEndTreeToken = /*#__PURE__*/parseToken('}'); // tree parser

var parseTREE = function parseTREE(text) {
  if (text.startsWith('{')) {
    return compose(parseTreeToken, parseTREE, oneOf(compose(parseComma, parseTREE, parseEndTreeToken), parseEndTreeToken))(text);
  }

  return parseSCRIPT(text);
};

var parseScriptToken = function parseScriptToken(type) {
  return function (text) {
    var res = compose(parseToken(cmd(type)), parseToken('('))(text);
    return [{
      type: TypeAST.SCRIPT,
      value: type,
      children: []
    }, res[1]];
  };
};

var parseEndCmd = /*#__PURE__*/parseToken(')');
var parseComma = /*#__PURE__*/parseToken(',');
var parseSCRIPT = function parseSCRIPT(text) {
  return oneOf(parseASM, parseRAW, parseELTR)(text);
};
var parseRAW = /*#__PURE__*/compose( /*#__PURE__*/parseScriptToken(ScriptType.RAW), // raw(
parseHEX, // hex of any length
parseEndCmd // ')'
);
var parseELTR = /*#__PURE__*/compose( /*#__PURE__*/parseScriptToken(ScriptType.ELTR), // eltr(
parseKEY, // 64 hex chars
parseComma, // ','
parseTREE, // TREE
parseEndCmd // ')'
);
var parseASM = /*#__PURE__*/compose( /*#__PURE__*/parseScriptToken(ScriptType.ASM), // asm(
parseASMScript, // opcodes
parseEndCmd // ')'
);

var namespaceRegexp = /*#__PURE__*/new RegExp('[$][a-zA-Z0-9|@_.-]+', 'g');

function replaceAll(str, find, replace) {
  return str.split(find).join(replace);
}

function findNamespaces(text) {
  var namespaces = Array.from(new Set(text.match(namespaceRegexp)));
  if (!namespaces) return [];
  return namespaces.map(function (n) {
    return n.slice(1);
  }); // remove the '$' token
}
function processNamespaces(ctx, text) {
  var namespaces = findNamespaces(text);
  if (!namespaces.length) return text;
  var processedText = text;

  for (var _iterator = _createForOfIteratorHelperLoose(namespaces), _step; !(_step = _iterator()).done;) {
    var _ctx$get;

    var namespace = _step.value;
    var namespacePublicKey = (_ctx$get = ctx.get(namespace)) == null ? void 0 : _ctx$get.pubkey;
    if (!namespacePublicKey) throw new Error("Could not find namespace context: " + namespace);
    processedText = replaceAll(processedText, '$' + namespace, namespacePublicKey);
  }

  return processedText;
}
function preprocessor(ctx, text) {
  return processNamespaces(ctx.namespaces, text);
}

/**
 * evaluate a template string and return witness scripts and redeem script associated with it
 * @param ctx used to replace xpubs with their current derivated public keys
 * @param template the string to evaluate
 **/

function makeEvaluateDescriptor(ecc) {
  var compile = DescriptorsCompilerFactory(ecc).compile;
  return function (ctx, template) {
    var processedTemplate = preprocessor(ctx, template);

    var _parseSCRIPT = parseSCRIPT(processedTemplate),
        ast = _parseSCRIPT[0];

    if (!ast) throw new Error('Failed to parse template');
    return compile(ast);
  };
}
/**
 * validate can be used without a context object to validate the parsability of a template string
 * @param template the template string to validate
 * @returns true if template is OK, false otherwise
 */

function validate(template) {
  var namespaces = findNamespaces(template);

  if (namespaces.length > 0) {
    var fakeKey = Buffer.alloc(32).toString('hex');
    var fakeCtx = {
      namespaces: new Map()
    };

    for (var _iterator = _createForOfIteratorHelperLoose(namespaces), _step; !(_step = _iterator()).done;) {
      var namespace = _step.value;
      fakeCtx.namespaces.set(namespace, {
        pubkey: fakeKey
      });
    }

    template = preprocessor(fakeCtx, template);
  }

  try {
    var _parseSCRIPT2 = parseSCRIPT(template),
        ast = _parseSCRIPT2[0];

    if (!ast) return false;
    return true;
  } catch (e) {
    return false;
  }
}

Object.keys(liquidjsLib).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return liquidjsLib[k];
    }
  });
});
exports.BLOCKSTREAM_ESPLORA_ENDPOINT = BLOCKSTREAM_ESPLORA_ENDPOINT;
exports.BrowserInject = BrowserInject;
exports.BufferMap = BufferMap;
exports.DEFAULT_BASE_DERIVATION_PATH = DEFAULT_BASE_DERIVATION_PATH;
exports.DEFAULT_SATS_PER_BYTE = DEFAULT_SATS_PER_BYTE;
exports.Electrs = Electrs;
exports.ElectrsBatchServer = ElectrsBatchServer;
exports.Identity = Identity;
exports.MasterPublicKey = MasterPublicKey;
exports.Mnemonic = Mnemonic;
exports.Multisig = Multisig;
exports.MultisigWatchOnly = MultisigWatchOnly;
exports.PrivateKey = PrivateKey;
exports.Wallet = Wallet;
exports.addToTx = addToTx;
exports.analyse = analyse;
exports.analyzeTapscriptTree = analyzeTapscriptTree;
exports.balances = balances;
exports.checkIdentityType = checkIdentityType;
exports.checkMnemonic = checkMnemonic;
exports.craftMultipleRecipientsPset = craftMultipleRecipientsPset;
exports.craftSingleRecipientPset = craftSingleRecipientPset;
exports.createFeeOutput = createFeeOutput;
exports.decodePset = decodePset;
exports.esploraTxToTxInterface = esploraTxToTxInterface;
exports.estimateTxSize = estimateTxSize;
exports.fetchAllTxs = fetchAllTxs;
exports.fetchAllUtxos = fetchAllUtxos;
exports.fetchAndUnblindTxs = fetchAndUnblindTxs;
exports.fetchAndUnblindTxsGenerator = fetchAndUnblindTxsGenerator;
exports.fetchAndUnblindUtxos = fetchAndUnblindUtxos;
exports.fetchAndUnblindUtxosGenerator = fetchAndUnblindUtxosGenerator;
exports.fetchTx = fetchTx;
exports.fetchTxHex = fetchTxHex;
exports.fetchUtxos = fetchUtxos;
exports.fromAssetHash = fromAssetHash;
exports.fromXpub = fromXpub;
exports.getAsset = getAsset;
exports.getIndexFromAddress = getIndexFromAddress;
exports.getNetwork = getNetwork;
exports.getSats = getSats;
exports.getScripts = getScripts;
exports.getUnblindURLFromTx = getUnblindURLFromTx;
exports.greedyCoinSelector = greedyCoinSelector;
exports.groupBy = groupBy;
exports.inputBlindingDataMap = inputBlindingDataMap;
exports.isConfidentialOutput = isConfidentialOutput;
exports.isUnblindedOutput = isUnblindedOutput;
exports.isValidAmount = isValidAmount;
exports.isValidExtendedBlindKey = isValidExtendedBlindKey;
exports.isValidXpub = isValidXpub;
exports.makeEvaluateDescriptor = makeEvaluateDescriptor;
exports.makeUnblindURL = makeUnblindURL;
exports.masterPubKeyRestorerFromEsplora = masterPubKeyRestorerFromEsplora;
exports.masterPubKeyRestorerFromState = masterPubKeyRestorerFromState;
exports.mnemonicRestorerFromChain = mnemonicRestorerFromChain;
exports.mnemonicRestorerFromEsplora = mnemonicRestorerFromEsplora;
exports.mnemonicRestorerFromState = mnemonicRestorerFromState;
exports.multisigFromEsplora = multisigFromEsplora;
exports.multisigWatchOnlyFromEsplora = multisigWatchOnlyFromEsplora;
exports.outputBlindingPubkeysMap = outputBlindingPubkeysMap;
exports.privateBlindKeyGetter = privateBlindKeyGetter;
exports.psetToUnsignedHex = psetToUnsignedHex;
exports.psetToUnsignedTx = psetToUnsignedTx;
exports.restorerFromEsplora = restorerFromEsplora;
exports.restorerFromState = restorerFromState;
exports.toAssetHash = toAssetHash;
exports.toNumber = toNumber;
exports.toOutpoint = toOutpoint;
exports.toXpub = toXpub;
exports.tryToUnblindUtxo = tryToUnblindUtxo;
exports.txsFetchGenerator = txsFetchGenerator;
exports.unblindOutput = unblindOutput;
exports.unblindTransaction = unblindTransaction;
exports.utxosFetchGenerator = utxosFetchGenerator;
exports.utxosFromTransactions = utxosFromTransactions;
exports.validate = validate;
exports.walletFromAddresses = walletFromAddresses;
exports.walletFromCoins = walletFromCoins;
//# sourceMappingURL=ldk.cjs.development.js.map
