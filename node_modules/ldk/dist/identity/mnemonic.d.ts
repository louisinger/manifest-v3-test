import { BIP32Interface } from 'bip32';
import { BlindingDataLike } from 'liquidjs-lib/src/psbt';
import { Slip77Interface } from 'slip77';
import { IdentityInterface, IdentityOpts } from './identity';
import { MasterPublicKey } from './masterpubkey';
export interface MnemonicOpts {
    mnemonic: string;
    passphrase?: string;
    language?: string;
    baseDerivationPath?: string;
}
/**
 * @class Mnemonic
 * Get a mnemonic as parameter to set up an HD Wallet.
 * @member masterPrivateKeyNode a BIP32 node computed from the seed, used to generate signing key pairs.
 * @member masterBlindingKeyNode a SLIP77 node computed from the seed, used to generate the blinding key pairs.
 * @member derivationPath the base derivation path.
 * @member index the next index used to derive the base node (for signing key pairs).
 * @member scriptToAddressCache a map scriptPubKey --> address generation.
 */
export declare class Mnemonic extends MasterPublicKey implements IdentityInterface {
    readonly mnemonic: string;
    readonly masterPrivateKeyNode: BIP32Interface;
    readonly masterBlindingKeyNode: Slip77Interface;
    masterPublicKey: string;
    masterBlindingKey: string;
    constructor(args: IdentityOpts<MnemonicOpts>);
    blindPset(psetBase64: string, outputsToBlind: number[], outputsPubKeys?: Map<number, string>, inputsBlindingDataLike?: Map<number, BlindingDataLike>): Promise<string>;
    isAbleToSign(): boolean;
    /**
     * return the next keypair derivated from the baseNode.
     * increment the private member index +1.
     */
    private derivePath;
    signPset(psetBase64: string): Promise<string>;
    static Random(chain: IdentityOpts<any>['chain'], ecclib: IdentityOpts<any>['ecclib'], baseDerivationPath?: string): Mnemonic;
}
