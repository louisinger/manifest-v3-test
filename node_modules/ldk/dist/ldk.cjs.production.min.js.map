{"version":3,"file":"ldk.cjs.production.min.js","sources":["../node_modules/regenerator-runtime/runtime.js","../src/utils.ts","../src/types.ts","../src/identity/identity.ts","../src/identity/masterpubkey.ts","../src/identity/mnemonic.ts","../src/identity/privatekey.ts","../src/identity/browserinject.ts","../src/p2ms.ts","../src/identity/multisigWatchOnly.ts","../src/identity/multisig.ts","../src/coinselection/utils.ts","../src/coinselection/greedy.ts","../src/explorer/esplora.ts","../src/error/unblind-error.ts","../src/explorer/transaction.ts","../src/explorer/utxos.ts","../src/explorer/chainsync.ts","../src/explorer/api.ts","../src/transaction.ts","../src/wallet.ts","../src/balance.ts","../src/blinding.ts","../src/restorer/mnemonic-restorer.ts","../src/script-analyser.ts","../src/descriptors/ast.ts","../src/descriptors/utils.ts","../src/descriptors/parser.ts","../src/descriptors/preprocessing.ts","../src/descriptors/index.ts","../src/restorer/chainsync.ts"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import { setDefaultWordlist, validateMnemonic } from 'bip39';\nimport b58 from 'bs58check';\nimport {\n  Psbt,\n  Transaction,\n  confidential,\n  networks,\n  address,\n} from 'liquidjs-lib';\nimport { Network } from 'liquidjs-lib/src/networks';\nimport {\n  AddressInterface,\n  Outpoint,\n  Output,\n  IdentityType,\n  NetworkString,\n  UnblindedOutput,\n} from './types';\n\nconst ZERO = Buffer.alloc(32);\n\nexport function toAssetHash(x: Buffer): string {\n  const withoutFirstByte = x.slice(1);\n  return (withoutFirstByte.reverse() as Buffer).toString('hex');\n}\n\nexport function fromAssetHash(x: string): Buffer {\n  return Buffer.concat([\n    Buffer.from('01', 'hex'), //prefix for unconfidential asset\n    Buffer.from(x, 'hex').reverse(),\n  ]);\n}\n\nexport function toNumber(x: Buffer): number {\n  return confidential.confidentialValueToSatoshi(x);\n}\n\nexport function isValidAmount(amount: number): boolean {\n  if (amount <= 0 || !Number.isSafeInteger(amount)) return false;\n  return true;\n}\n\n/**\n * The unblind output function's result interface.\n */\nexport interface UnblindResult {\n  asset: Buffer;\n  // in satoshis\n  value: number;\n}\n\nconst emptyNonce: Buffer = Buffer.from('0x00', 'hex');\n\nfunction bufferNotEmptyOrNull(buffer?: Buffer): boolean {\n  return buffer != null && buffer.length > 0;\n}\n\n/**\n * Checks if a given output is a confidential one.\n * @param output the ouput to check.\n */\nexport function isConfidentialOutput({\n  rangeProof,\n  surjectionProof,\n  nonce,\n}: any): boolean {\n  return (\n    bufferNotEmptyOrNull(rangeProof) &&\n    bufferNotEmptyOrNull(surjectionProof) &&\n    nonce !== emptyNonce\n  );\n}\n\nexport class BufferMap<T> {\n  private map: Map<string, T>;\n\n  constructor() {\n    this.map = new Map<string, T>();\n  }\n\n  private bufferToStringPrimitive(buffer: Buffer): string {\n    return buffer.toString('hex').valueOf();\n  }\n\n  get(key: Buffer): T | undefined {\n    return this.map.get(this.bufferToStringPrimitive(key));\n  }\n\n  set(key: Buffer, value: T): this {\n    this.map.set(this.bufferToStringPrimitive(key), value);\n    return this;\n  }\n\n  values(): T[] {\n    return Array.from(this.map.values());\n  }\n}\n\n// This has been taken from https://github.com/Casa/xpub-converter/blob/master/js/xpubConvert.js\n/*\n  This script uses version bytes as described in SLIP-132\n  https://github.com/satoshilabs/slips/blob/master/slip-0132.md\n*/\nconst prefixes = new Map([\n  ['xpub', '0488b21e'],\n  ['ypub', '049d7cb2'],\n  ['Ypub', '0295b43f'],\n  ['zpub', '04b24746'],\n  ['Zpub', '02aa7ed3'],\n  ['tpub', '043587cf'],\n  ['upub', '044a5262'],\n  ['Upub', '024289ef'],\n  ['vpub', '045f1cf6'],\n  ['Vpub', '02575483'],\n]);\n\n/*\n * This function takes an extended public key (with any version bytes, it doesn't need to be an xpub)\n * and converts it to an extended public key formatted with the desired version bytes\n * @param xpub: an extended public key in base58 format. Example: xpub6CpihtY9HVc1jNJWCiXnRbpXm5BgVNKqZMsM4XqpDcQigJr6AHNwaForLZ3kkisDcRoaXSUms6DJNhxFtQGeZfWAQWCZQe1esNetx5Wqe4M\n * @param targetFormat: a string representing the desired prefix; must exist in the \"prefixes\" mapping defined above. Example: Zpub\n */\nfunction changeVersionBytes(xpub: string, targetFormat: string) {\n  if (!prefixes.has(targetFormat)) {\n    return 'Invalid target version';\n  }\n\n  // trim whitespace\n  xpub = xpub.trim();\n\n  try {\n    let data = b58.decode(xpub);\n    data = data.slice(4);\n    data = Buffer.concat([\n      Buffer.from(prefixes.get(targetFormat)!, 'hex'),\n      data,\n    ]);\n    return b58.encode(data);\n  } catch (err) {\n    throw new Error(\n      \"Invalid extended public key! Please double check that you didn't accidentally paste extra data.\"\n    );\n  }\n}\n\nexport function fromXpub(xub: string, chain: NetworkString) {\n  const format = chain === 'liquid' ? 'zpub' : 'vpub';\n  return changeVersionBytes(xub, format);\n}\n\nexport function toXpub(anyPub: string) {\n  return changeVersionBytes(anyPub, 'xpub');\n}\n\nconst extendedPubKeyRegexp = /[a-z]pub[a-km-zA-HJ-NP-Z1-9]{100,108}$/;\nconst masterBlindKeyRegexp = /[0-9a-fA-F]{64}$/;\n\nexport function isValidXpub(xpub: string): boolean {\n  return extendedPubKeyRegexp.test(xpub);\n}\n\nexport function isValidExtendedBlindKey(masterBlind: string): boolean {\n  return masterBlindKeyRegexp.test(masterBlind);\n}\n\nexport function psetToUnsignedHex(psetBase64: string): string {\n  let pset: Psbt;\n  try {\n    pset = Psbt.fromBase64(psetBase64);\n  } catch (ignore) {\n    throw new Error('Invalid pset');\n  }\n\n  return pset.data.globalMap.unsignedTx.toBuffer().toString('hex');\n}\n\nexport function psetToUnsignedTx(ptx: string): Transaction {\n  return Transaction.fromHex(psetToUnsignedHex(ptx));\n}\n\nexport function toOutpoint({ txid, vout }: Output): Outpoint {\n  return { txid, vout };\n}\n\nexport function getNetwork(str?: NetworkString): Network {\n  return str ? (networks as Record<string, Network>)[str] : networks.liquid;\n}\n\n/**\n * Compute the blinding data for a given output\n * @param utxo blinded utxo\n * @param blindPrivKey blinding private key\n */\nexport async function unblindOutput(\n  utxo: Output,\n  blindPrivKey: string\n): Promise<UnblindedOutput> {\n  if (!isConfidentialOutput(utxo.prevout)) {\n    return {\n      ...utxo,\n      unblindData: {\n        asset: utxo.prevout.asset.slice(1),\n        value: confidential\n          .confidentialValueToSatoshi(utxo.prevout.value)\n          .toString(10),\n        assetBlindingFactor: ZERO,\n        valueBlindingFactor: ZERO,\n      },\n    };\n  }\n\n  const unblindData = await confidential.unblindOutputWithKey(\n    utxo.prevout,\n    Buffer.from(blindPrivKey, 'hex')\n  );\n\n  return {\n    ...utxo,\n    unblindData,\n  };\n}\n\n// util function that parse a derivation path and return the index\nexport function getIndexFromAddress(addr: AddressInterface) {\n  if (!addr.derivationPath) {\n    throw new Error('need derivation path to be defined');\n  }\n\n  const derivationPathSplitted = addr.derivationPath.split('/');\n\n  return parseInt(derivationPathSplitted[derivationPathSplitted.length - 1]);\n}\n\n// throws an error if actual is not expect\nexport function checkIdentityType(actual: IdentityType, expect: IdentityType) {\n  if (actual !== expect)\n    throw new Error(\n      `Incorrect Identity type: need ${expect} and get ${actual}.`\n    );\n}\n\nexport function checkMnemonic(mnemonic: string, language?: string) {\n  if (language) setDefaultWordlist(language);\n  if (!validateMnemonic(mnemonic)) throw new Error('Mnemonic is not valid.');\n}\n\nexport function decodePset(psetBase64: string): Psbt {\n  let pset: Psbt;\n  try {\n    pset = Psbt.fromBase64(psetBase64);\n  } catch (ignore) {\n    throw new Error('Invalid pset');\n  }\n  return pset;\n}\n\nexport function getScripts(addresses: AddressInterface[]): Set<string> {\n  return new Set(\n    addresses.map(a =>\n      address.toOutputScript(a.confidentialAddress).toString('hex')\n    )\n  );\n}\n\nexport function groupBy<T extends Record<string, any>>(\n  xs: T[],\n  key: (t: T) => string\n): Record<string, T[]> {\n  return xs.reduce(function(rv, x) {\n    const k = key(x);\n    const row = rv[k] ?? [];\n    rv[k] = [...row, x];\n    return rv;\n  }, {} as Record<string, T[]>);\n}\n","import { TxOutput, confidential } from 'liquidjs-lib';\nimport { isConfidentialOutput } from './utils';\n\n/**\n * Enumeration of all the Identity types.\n */\nexport enum IdentityType {\n  PrivateKey = 1,\n  Mnemonic,\n  MasterPublicKey,\n  Inject,\n  Ledger,\n  Trezor,\n  MultisigWatchOnly,\n  Multisig,\n}\n\n/**\n * Defines the shape of the object returned by the getAdresses's method.\n * @member confidentialAddress the confidential address.\n * @member blindingPrivateKey the blinding private key associated to the confidential address.\n */\nexport interface AddressInterface {\n  confidentialAddress: string;\n  blindingPrivateKey: string;\n  derivationPath?: string;\n  publicKey?: string;\n  [key: string]: any;\n}\n\n// define a type using to implement change's address strategy\nexport type ChangeAddressFromAssetGetter = (asset: string) => string;\n\n// define function that takes a script as input and returns a blinding key (or undefined)\nexport type BlindingKeyGetter = (script: string) => string | undefined;\nexport type BlindingKeyGetterAsync = (\n  script: string\n) => Promise<string | undefined>;\n\nexport interface RecipientInterface {\n  value: number;\n  asset: string;\n  address: string;\n}\n\nexport interface Outpoint {\n  txid: string;\n  vout: number;\n}\n\nexport type Output = Outpoint & {\n  prevout: TxOutput;\n};\n\nexport type UnblindedOutput = Output & {\n  unblindData: confidential.UnblindOutputResult;\n};\n\nexport function isUnblindedOutput(output: Output): output is UnblindedOutput {\n  return (output as UnblindedOutput).unblindData !== undefined;\n}\n\nexport function getSats(output: Output | UnblindedOutput): number {\n  if (isUnblindedOutput(output)) return parseInt(output.unblindData.value, 10);\n  if (!isConfidentialOutput(output.prevout)) {\n    return confidential.confidentialValueToSatoshi(output.prevout.value);\n  }\n\n  throw new Error(\n    'cannot get value for confidential output, need unblinded one'\n  );\n}\n\nexport function getAsset(output: Output | UnblindedOutput): string {\n  if (isUnblindedOutput(output)) {\n    const asset = Buffer.from(output.unblindData.asset).reverse();\n    return asset.toString('hex');\n  }\n\n  if (!isConfidentialOutput(output.prevout)) {\n    const asset = Buffer.from(output.prevout.asset)\n      .slice(1)\n      .reverse();\n    return asset.toString('hex');\n  }\n\n  throw new Error(\n    'cannot get asset for confidential output, need unblinded one'\n  );\n}\n\nexport interface InputInterface {\n  txid: string;\n  vout: number;\n  prevout?: Output | UnblindedOutput;\n  isPegin: boolean;\n}\n\nexport interface TxInterface {\n  txid: string;\n  fee: number;\n  status: {\n    confirmed: boolean;\n    blockHeight?: number;\n    blockHash?: string;\n    blockTime?: number;\n  };\n  vin: InputInterface[];\n  vout: (Output | UnblindedOutput)[];\n}\n\nexport type CoinSelectorErrorFn = (\n  asset: string,\n  need: number,\n  has: number\n) => void;\n\nexport type MultisigPayment = AddressInterface & {\n  witnessScript: string;\n};\n\nexport interface HDSignerMultisig {\n  mnemonic: string;\n  passphrase?: string;\n  baseDerivationPath?: string;\n}\n\nexport type XPub = string;\n\nexport type CosignerMultisig = XPub | HDSignerMultisig; // xpub or signer\n\nexport type NetworkString = 'regtest' | 'testnet' | 'liquid';\n","import { TinySecp256k1Interface as ecpairTinySecp256k1Interface } from 'ecpair';\nimport { TinySecp256k1Interface as slip77TinySecp256k1Interface } from 'slip77';\nimport { TinySecp256k1Interface as bip32TinySecp256k1Interface } from 'bip32';\nimport { Transaction, networks, confidential, TxOutput } from 'liquidjs-lib';\nimport { Network } from 'liquidjs-lib/src/networks';\nimport { BlindingDataLike, Psbt } from 'liquidjs-lib/src/psbt';\nimport {\n  AddressInterface,\n  BlindingKeyGetterAsync,\n  NetworkString,\n} from '../types';\nimport { IdentityType } from '../types';\nimport { isConfidentialOutput, psetToUnsignedHex, decodePset } from '../utils';\n\nexport type TinySecp256k1Interface = bip32TinySecp256k1Interface &\n  slip77TinySecp256k1Interface &\n  ecpairTinySecp256k1Interface;\n\n/**\n * The identity interface.\n * @member network the network type (regtest, liquid...)\n * @member type the Identity type @see IdentityType\n * @method signPset take a base64 pset, sign it, and returns the result base64 encoded.\n * @method getAddresses returns all the generated addresses (and their blindkey if confidential).\n */\nexport interface IdentityInterface {\n  network: Network;\n  type: IdentityType;\n  getNextAddress(\n    constructorParams?: Record<string, string | number>\n  ): Promise<AddressInterface>;\n  getNextChangeAddress(\n    constructorParams?: Record<string, string | number>\n  ): Promise<AddressInterface>;\n  signPset(psetBase64: string): Promise<string>;\n  getAddresses(): Promise<AddressInterface[]>;\n  getBlindingPrivateKey(script: string): Promise<string>;\n  isAbleToSign(): boolean;\n  blindPset(\n    // the pset to blind\n    psetBase64: string,\n    // the output to blind, specifided by output index\n    outputsIndexToBlind: number[],\n    // optional: an outputs index to hex encoded blinding pub key\n    // only useful for non-wallet outputs\n    outputsPubKeysByIndex?: Map<number, string>,\n    // BlindingDataLike to use to blind the outputs by input index\n    inputsBlindingDataLike?: Map<number, BlindingDataLike>\n  ): Promise<string>;\n}\n\n/**\n * Identity constructors options.\n * @member chain the blockchain type of the identity.\n * @member type the identity type @see IdentityType .\n * @member value the data used to create the Identity. depends of the type.\n */\nexport interface IdentityOpts<optsT> {\n  chain: NetworkString;\n  type: number;\n  opts: optsT;\n  ecclib: TinySecp256k1Interface;\n}\n\n/**\n * Abstract class for Identity.\n */\nexport class Identity {\n  network: Network;\n  type: IdentityType;\n  ecclib: TinySecp256k1Interface;\n\n  constructor(args: IdentityOpts<any>) {\n    if (!args.chain || !networks.hasOwnProperty(args.chain)) {\n      throw new Error('Network is missing or not valid');\n    }\n\n    if (!args.type || !(args.type in IdentityType)) {\n      throw new Error('Type is missing or not valid');\n    }\n\n    this.network = (networks as Record<string, Network>)[args.chain];\n    this.type = args.type;\n    this.ecclib = args.ecclib;\n  }\n\n  async blindPsetWithBlindKeysGetter(\n    getBlindingKeyPair: (\n      script: Buffer\n    ) => { publicKey: Buffer; privateKey: Buffer },\n    psetBase64: string,\n    outputsToBlind: number[],\n    outputsPubKeys?: Map<number, string>,\n    inputsBlindingDataLike?: Map<number, BlindingDataLike>\n  ): Promise<string> {\n    const inputsData = new Map<number, BlindingDataLike>();\n    const outputsKeys = new Map<number, Buffer>();\n\n    const pset = decodePset(psetBase64);\n    const transaction = Transaction.fromHex(psetToUnsignedHex(psetBase64));\n\n    // set the outputs map\n    for (const index of outputsToBlind) {\n      if (outputsPubKeys?.has(index)) {\n        const pubKey = Buffer.from(outputsPubKeys.get(index)!, 'hex');\n        outputsKeys.set(index, pubKey);\n        continue;\n      }\n\n      const { script } = transaction.outs[index];\n      const pubKey = getBlindingKeyPair(script).publicKey;\n      outputsKeys.set(index, pubKey);\n    }\n\n    // set the inputs map\n    for (let index = 0; index < pset.data.inputs.length; index++) {\n      const input = pset.data.inputs[index];\n      let script: Buffer | undefined = undefined;\n\n      // continue if the input witness is unconfidential\n      if (input.witnessUtxo) {\n        if (!isConfidentialOutput(input.witnessUtxo)) {\n          continue;\n        }\n\n        script = input.witnessUtxo.script;\n      }\n\n      if (input.nonWitnessUtxo) {\n        const vout = transaction.ins[index].index;\n        const witness = Transaction.fromBuffer(input.nonWitnessUtxo).outs[vout];\n        if (!isConfidentialOutput(witness)) {\n          continue;\n        }\n\n        script = witness.script;\n      }\n\n      // check if blindingDataLike is specified\n      if (inputsBlindingDataLike?.has(index)) {\n        inputsData.set(index, inputsBlindingDataLike.get(index));\n        continue;\n      }\n\n      if (!script) {\n        throw new Error('no witness script for input #' + index);\n      }\n\n      // else, get the private blinding key and use it as blindingDataLike\n      const privKey = getBlindingKeyPair(script).privateKey;\n      const blinders = await confidential.unblindOutputWithKey(\n        input.witnessUtxo as TxOutput,\n        privKey\n      );\n\n      inputsData.set(index, blinders);\n    }\n\n    const blinded = await pset.blindOutputsByIndex(\n      Psbt.ECCKeysGenerator(this.ecclib),\n      inputsData,\n      outputsKeys\n    );\n\n    return blinded.toBase64();\n  }\n}\n\nexport function privateBlindKeyGetter(\n  identity: IdentityInterface\n): BlindingKeyGetterAsync {\n  return async (script: string) => {\n    return identity.getBlindingPrivateKey(script);\n  };\n}\n","import BIP32Factory, { BIP32Interface } from 'bip32';\nimport { BlindingDataLike, payments } from 'liquidjs-lib';\nimport { SLIP77Factory, Slip77Interface } from 'slip77';\nimport { AddressInterface, IdentityType } from '../types';\nimport {\n  checkIdentityType,\n  isValidExtendedBlindKey,\n  isValidXpub,\n} from '../utils';\nimport { Identity, IdentityInterface, IdentityOpts } from './identity';\n\nexport interface MasterPublicKeyOpts {\n  masterPublicKey: string;\n  masterBlindingKey: string;\n  baseDerivationPath?: string;\n}\n\ninterface AddressInterfaceExtended {\n  address: AddressInterface;\n  publicKey: string;\n}\n\nexport class MasterPublicKey extends Identity implements IdentityInterface {\n  protected static INITIAL_BASE_PATH = \"m/84'/0'/0'\";\n  static INITIAL_INDEX = 0;\n\n  private index: number = MasterPublicKey.INITIAL_INDEX;\n  private changeIndex: number = MasterPublicKey.INITIAL_INDEX;\n  protected scriptToAddressCache: Record<string, AddressInterfaceExtended> = {};\n  private baseDerivationPath: string;\n\n  readonly masterPublicKeyNode: BIP32Interface;\n  readonly masterBlindingKeyNode: Slip77Interface;\n\n  constructor(args: IdentityOpts<MasterPublicKeyOpts>) {\n    super(args);\n\n    // check the identity type\n    checkIdentityType(args.type, IdentityType.MasterPublicKey);\n\n    // validate xpub\n    if (!isValidXpub(args.opts.masterPublicKey)) {\n      throw new Error('Master public key is not valid');\n    }\n    // validate master blinding key\n    if (!isValidExtendedBlindKey(args.opts.masterBlindingKey)) {\n      throw new Error('Master blinding key is not valid');\n    }\n\n    this.masterPublicKeyNode = BIP32Factory(args.ecclib).fromBase58(\n      args.opts.masterPublicKey\n    );\n    this.masterBlindingKeyNode = SLIP77Factory(\n      args.ecclib\n    ).fromMasterBlindingKey(args.opts.masterBlindingKey);\n    this.baseDerivationPath =\n      args.opts.baseDerivationPath || MasterPublicKey.INITIAL_BASE_PATH;\n  }\n\n  async blindPset(\n    psetBase64: string,\n    outputsToBlind: number[],\n    outputsPubKeys?: Map<number, string>,\n    inputsBlindingDataLike?: Map<number, BlindingDataLike>\n  ): Promise<string> {\n    return super.blindPsetWithBlindKeysGetter(\n      (script: Buffer) => this.getBlindingKeyPair(script.toString('hex'), true),\n      psetBase64,\n      outputsToBlind,\n      outputsPubKeys,\n      inputsBlindingDataLike\n    );\n  }\n\n  isAbleToSign(): boolean {\n    return false;\n  }\n\n  /**\n   * return the next public key derivated from the baseNode.\n   * increment the private member index +1.\n   */\n  private derivePublicKeyWithIndex(isChange: boolean, index: number): Buffer {\n    const changeIndex = isChange ? 1 : 0;\n    const baseNode = this.masterPublicKeyNode.derive(changeIndex);\n    const child: BIP32Interface = baseNode.derive(index);\n    return child.publicKey;\n  }\n\n  /**\n   * Derives the script given as parameter to a keypair (SLIP77).\n   * @param scriptPubKey script to derive.\n   */\n  protected getBlindingKeyPair(\n    scriptPubKey: string,\n    checkScript = false\n  ): { publicKey: Buffer; privateKey: Buffer } {\n    if (checkScript) {\n      const addressInterface = this.scriptToAddressCache[scriptPubKey];\n      if (!addressInterface) {\n        throw new Error(`unknow blinding key for script ${scriptPubKey}`);\n      }\n    }\n\n    const { publicKey, privateKey } = this.masterBlindingKeyNode.derive(\n      scriptPubKey\n    );\n    return { publicKey: publicKey!, privateKey: privateKey! };\n  }\n\n  private scriptFromPublicKey(publicKey: Buffer): string {\n    return payments\n      .p2wpkh({\n        pubkey: publicKey,\n        network: this.network,\n      })\n      .output!.toString('hex');\n  }\n\n  private createConfidentialAddress(\n    signingPublicKey: Buffer,\n    blindingPublicKey: Buffer\n  ): string {\n    return payments.p2wpkh({\n      pubkey: signingPublicKey,\n      blindkey: blindingPublicKey,\n      network: this.network,\n    }).confidentialAddress!;\n  }\n\n  // store the generation inside local cache\n  persistAddressToCache(address: AddressInterfaceExtended): void {\n    const publicKeyBuffer = Buffer.from(address.publicKey, 'hex');\n    const script = this.scriptFromPublicKey(publicKeyBuffer);\n\n    this.scriptToAddressCache[script] = address;\n  }\n\n  getAddress(isChange: boolean, index: number): AddressInterfaceExtended {\n    // get the next key pair\n    const publicKey = this.derivePublicKeyWithIndex(isChange, index);\n    // use the public key to compute the scriptPubKey\n    const script = this.scriptFromPublicKey(publicKey);\n    // generate the blindKeyPair from the scriptPubKey\n    const blindingKeyPair = this.getBlindingKeyPair(script);\n    // with blindingPublicKey & signingPublicKey, generate the confidential address\n    const confidentialAddress = this.createConfidentialAddress(\n      publicKey,\n      blindingKeyPair.publicKey\n    );\n    // create the address generation object\n    const path = `${this.baseDerivationPath}/${isChange ? 1 : 0}/${index}`;\n    const newAddressGeneration: AddressInterfaceExtended = {\n      address: {\n        confidentialAddress: confidentialAddress!,\n        blindingPrivateKey: blindingKeyPair.privateKey!.toString('hex'),\n        derivationPath: path,\n        publicKey: publicKey.toString('hex'),\n      },\n      publicKey: publicKey.toString('hex'),\n    };\n    // return the generation data\n    return newAddressGeneration;\n  }\n\n  async getNextAddress(): Promise<AddressInterface> {\n    const addr = this.getAddress(false, this.index);\n    this.persistAddressToCache(addr);\n    this.index = this.index + 1;\n    return addr.address;\n  }\n\n  async getNextChangeAddress(): Promise<AddressInterface> {\n    const addr = this.getAddress(true, this.changeIndex);\n    this.persistAddressToCache(addr);\n    this.changeIndex = this.changeIndex + 1;\n    return addr.address;\n  }\n\n  async getBlindingPrivateKey(script: string): Promise<string> {\n    return this.getBlindingKeyPair(script).privateKey.toString('hex');\n  }\n\n  signPset(_: string): Promise<string> {\n    throw new Error(\n      'MasterPublicKey is a watch only identity. Use Mnemonic to sign transactions'\n    );\n  }\n\n  // returns all the addresses generated\n  async getAddresses(): Promise<AddressInterface[]> {\n    return Object.values(this.scriptToAddressCache).map(\n      addrExtended => addrExtended.address\n    );\n  }\n\n  getXPub(): string {\n    return this.masterPublicKeyNode.toBase58();\n  }\n}\n","import BIP32Factory, { BIP32Interface } from 'bip32';\nimport * as bip39 from 'bip39';\nimport { Psbt, networks } from 'liquidjs-lib';\nimport { Network } from 'liquidjs-lib/src/networks';\nimport { BlindingDataLike } from 'liquidjs-lib/src/psbt';\nimport { SLIP77Factory, Slip77Interface } from 'slip77';\n\nimport { IdentityType } from '../types';\nimport { checkIdentityType, checkMnemonic, toXpub } from '../utils';\n\nimport { IdentityInterface, IdentityOpts } from './identity';\nimport { MasterPublicKey } from './masterpubkey';\nimport ECPairFactory from 'ecpair';\n\nexport interface MnemonicOpts {\n  mnemonic: string;\n  passphrase?: string;\n  language?: string;\n  baseDerivationPath?: string;\n}\n\n/**\n * @class Mnemonic\n * Get a mnemonic as parameter to set up an HD Wallet.\n * @member masterPrivateKeyNode a BIP32 node computed from the seed, used to generate signing key pairs.\n * @member masterBlindingKeyNode a SLIP77 node computed from the seed, used to generate the blinding key pairs.\n * @member derivationPath the base derivation path.\n * @member index the next index used to derive the base node (for signing key pairs).\n * @member scriptToAddressCache a map scriptPubKey --> address generation.\n */\nexport class Mnemonic extends MasterPublicKey implements IdentityInterface {\n  readonly mnemonic: string;\n  readonly masterPrivateKeyNode: BIP32Interface;\n  readonly masterBlindingKeyNode: Slip77Interface;\n\n  public masterPublicKey: string;\n  public masterBlindingKey: string;\n\n  constructor(args: IdentityOpts<MnemonicOpts>) {\n    checkIdentityType(args.type, IdentityType.Mnemonic);\n    // check set the language if it is different of the default language.\n    // the \"language exists check\" is delegated to `bip39.setDefaultWordlist` function.\n    bip39.setDefaultWordlist(args.opts.language || 'english');\n    checkMnemonic(args.opts.mnemonic);\n\n    // retreive the wallet's seed from mnemonic\n    const walletSeed = bip39.mnemonicToSeedSync(\n      args.opts.mnemonic,\n      args.opts.passphrase\n    );\n    // generate the master private key from the wallet seed\n    const network = (networks as Record<string, Network>)[args.chain];\n    const bip32 = BIP32Factory(args.ecclib);\n    const masterPrivateKeyNode = bip32.fromSeed(walletSeed, network);\n\n    // compute and expose the masterPublicKey in this.masterPublicKey\n    const masterPublicKey = toXpub(\n      masterPrivateKeyNode\n        .derivePath(\n          args.opts.baseDerivationPath || MasterPublicKey.INITIAL_BASE_PATH\n        )\n        .neutered()\n        .toBase58()\n    );\n\n    // generate the master blinding key from the seed\n    const masterBlindingKeyNode = SLIP77Factory(args.ecclib).fromSeed(\n      walletSeed\n    );\n    const masterBlindingKey = masterBlindingKeyNode.masterKey.toString('hex');\n\n    super({\n      ...args,\n      type: IdentityType.MasterPublicKey,\n      opts: {\n        masterPublicKey,\n        masterBlindingKey,\n        baseDerivationPath: args.opts.baseDerivationPath,\n      },\n    });\n\n    this.masterBlindingKey = masterBlindingKey;\n    this.masterBlindingKeyNode = masterBlindingKeyNode;\n    this.masterPublicKey = masterPublicKey;\n    this.masterPrivateKeyNode = masterPrivateKeyNode;\n    this.mnemonic = args.opts.mnemonic;\n  }\n\n  async blindPset(\n    psetBase64: string,\n    outputsToBlind: number[],\n    outputsPubKeys?: Map<number, string>,\n    inputsBlindingDataLike?: Map<number, BlindingDataLike>\n  ): Promise<string> {\n    return super.blindPsetWithBlindKeysGetter(\n      (script: Buffer) =>\n        super.getBlindingKeyPair(script.toString('hex'), true),\n      psetBase64,\n      outputsToBlind,\n      outputsPubKeys,\n      inputsBlindingDataLike\n    );\n  }\n\n  isAbleToSign(): boolean {\n    return true;\n  }\n\n  /**\n   * return the next keypair derivated from the baseNode.\n   * increment the private member index +1.\n   */\n  private derivePath(\n    derivationPath: string\n  ): { publicKey: Buffer; privateKey: Buffer } {\n    if (!this.ecclib)\n      throw new Error('ecclib is missing, cannot derive public key');\n\n    const wif: string = this.masterPrivateKeyNode\n      .derivePath(derivationPath)\n      .toWIF();\n    const { publicKey, privateKey } = ECPairFactory(this.ecclib).fromWIF(\n      wif,\n      this.network\n    );\n    return { publicKey: publicKey!, privateKey: privateKey! };\n  }\n\n  async signPset(psetBase64: string): Promise<string> {\n    if (!this.ecclib) throw new Error('ecclib is missing, cannot sign pset');\n\n    const pset = Psbt.fromBase64(psetBase64);\n    const signInputPromises: Promise<void>[] = [];\n\n    for (let index = 0; index < pset.data.inputs.length; index++) {\n      const input = pset.data.inputs[index];\n      if (input.witnessUtxo) {\n        const addressGeneration = this.scriptToAddressCache[\n          input.witnessUtxo.script.toString('hex')\n        ];\n\n        if (addressGeneration) {\n          // if there is an address generated for the input script: build the signing key pair.\n          const privateKeyBuffer = this.derivePath(\n            addressGeneration.address.derivationPath!\n          ).privateKey;\n          const signingKeyPair = ECPairFactory(this.ecclib).fromPrivateKey(\n            privateKeyBuffer\n          );\n          // add the promise to array\n          signInputPromises.push(pset.signInputAsync(index, signingKeyPair));\n        }\n      }\n    }\n    // wait that all signing promise resolved\n    await Promise.all(signInputPromises);\n    // return the signed pset, base64 encoded.\n    return pset.toBase64();\n  }\n\n  static Random(\n    chain: IdentityOpts<any>['chain'],\n    ecclib: IdentityOpts<any>['ecclib'],\n    baseDerivationPath?: string\n  ): Mnemonic {\n    const randomMnemonic = bip39.generateMnemonic();\n    return new Mnemonic({\n      chain,\n      ecclib,\n      type: IdentityType.Mnemonic,\n      opts: {\n        mnemonic: randomMnemonic,\n        baseDerivationPath,\n      },\n    });\n  }\n}\n","import ECPairFactory, { ECPairInterface } from 'ecpair';\nimport { Psbt, payments } from 'liquidjs-lib';\nimport { BlindingDataLike } from 'liquidjs-lib/src/psbt';\nimport { AddressInterface, IdentityType } from '../types';\nimport { checkIdentityType } from '../utils';\nimport { Identity, IdentityInterface, IdentityOpts } from './identity';\n\n/**\n * This interface describes the shape of the value arguments used in contructor.\n * @member signingKeyWIF a valid private key WIF encoded.\n * @member blindingKeyWIF a valid private key WIF encoded.\n */\nexport interface PrivateKeyOpts {\n  signingKeyWIF: string;\n  blindingKeyWIF: string;\n}\n\n/**\n * The PrivateKey Identity takes a WIF and modelize a user using his private key.\n * @member signingKeyPair private, the key pair used to sign inputs.\n * @member blindingKeyPair private, the key pair used to blind outputs.\n * @member confidentialAddress private, the confidential address generated from keypairs.\n * @member blindingPrivateKey private, the blinding private key associated with the confidential address.\n * @member scriptPubKey private, the scriptPubKey associated to the confidential address.\n * @method signPset sign all the inputs when it's possible (scriptPubKey = input's script).\n * @method getAddresses return an array of one element containing the blindingPrivateKey & the confidentialAddress.\n */\nexport class PrivateKey extends Identity implements IdentityInterface {\n  private signingKeyPair: ECPairInterface;\n  private blindingKeyPair: ECPairInterface;\n\n  private confidentialAddress: string;\n  private blindingPrivateKey: string;\n  private scriptPubKey: Buffer;\n\n  constructor(args: IdentityOpts<PrivateKeyOpts>) {\n    super(args);\n\n    // checks the args type.\n    checkIdentityType(args.type, IdentityType.PrivateKey);\n\n    // decode signing key pair from WIF\n    this.signingKeyPair = this.decodeFromWif(args.opts.signingKeyWIF);\n\n    // decode blinding key pair from WIF\n    this.blindingKeyPair = this.decodeFromWif(args.opts.blindingKeyWIF);\n\n    // create payment\n    const p2wpkh = payments.p2wpkh({\n      pubkey: this.signingKeyPair.publicKey,\n      blindkey: this.blindingKeyPair.publicKey,\n      network: this.network,\n    });\n\n    // store data inside private fields.\n    this.confidentialAddress = p2wpkh.confidentialAddress!;\n    this.blindingPrivateKey = this.blindingKeyPair.privateKey!.toString('hex');\n    this.scriptPubKey = p2wpkh.output!;\n  }\n\n  async blindPset(\n    psetBase64: string,\n    outputsToBlind: number[],\n    outputsPubKeys?: Map<number, string>,\n    inputsBlindingDataLike?: Map<number, BlindingDataLike>\n  ): Promise<string> {\n    return super.blindPsetWithBlindKeysGetter(\n      (script: Buffer) => this.getBlindingKeyPair(script),\n      psetBase64,\n      outputsToBlind,\n      outputsPubKeys,\n      inputsBlindingDataLike\n    );\n  }\n\n  private getBlindingKeyPair(\n    script: Buffer\n  ): { publicKey: Buffer; privateKey: Buffer } {\n    if (!script.equals(this.scriptPubKey)) {\n      throw new Error(script + ' is unknown by the PrivateKey Identity');\n    }\n\n    return {\n      publicKey: this.blindingKeyPair.publicKey,\n      privateKey: this.blindingKeyPair.privateKey!,\n    };\n  }\n\n  isAbleToSign(): boolean {\n    return true;\n  }\n\n  private decodeFromWif(wif: string): ECPairInterface {\n    return ECPairFactory(this.ecclib).fromWIF(wif, this.network);\n  }\n\n  private getAddress(): AddressInterface {\n    return {\n      confidentialAddress: this.confidentialAddress,\n      blindingPrivateKey: this.blindingPrivateKey,\n      derivationPath: undefined,\n      publicKey: this.signingKeyPair.publicKey.toString('hex'),\n    };\n  }\n\n  async getNextAddress(): Promise<AddressInterface> {\n    return this.getAddress();\n  }\n\n  async getNextChangeAddress(): Promise<AddressInterface> {\n    return this.getAddress();\n  }\n\n  async getBlindingPrivateKey(script: string): Promise<string> {\n    const scriptPubKeyBuffer = Buffer.from(script, 'hex');\n    if (!scriptPubKeyBuffer.equals(this.scriptPubKey)) {\n      throw new Error('The script is not PrivateKey.scriptPubKey.');\n    }\n\n    return this.blindingPrivateKey;\n  }\n\n  /**\n   * iterate through inputs and sign when it's possible, then returns the signed pset (base64 encoded).\n   * @param psetBase64 the base64 encoded pset.\n   */\n  async signPset(psetBase64: string): Promise<string> {\n    const pset = Psbt.fromBase64(psetBase64);\n    const indexOfInputs: number[] = [];\n\n    for (let index = 0; index < pset.data.inputs.length; index++) {\n      const input = pset.data.inputs[index];\n      if (input.witnessUtxo) {\n        if (input.witnessUtxo.script.equals(this.scriptPubKey)) {\n          indexOfInputs.push(index);\n        }\n      } else {\n        indexOfInputs.push(index);\n      }\n    }\n\n    // sign all the inputs asynchronously\n    await Promise.all(\n      indexOfInputs.map((index: number) =>\n        pset.signInputAsync(index, this.signingKeyPair)\n      )\n    );\n\n    return pset.toBase64();\n  }\n\n  /**\n   * for private key: only returns one confidential address & the associated blindingPrivKey.\n   */\n  async getAddresses(): Promise<AddressInterface[]> {\n    return [\n      {\n        confidentialAddress: this.confidentialAddress,\n        blindingPrivateKey: this.blindingPrivateKey,\n        derivationPath: undefined,\n        publicKey: this.signingKeyPair.publicKey.toString('hex'),\n      },\n    ];\n  }\n}\n","import { BlindingDataLike } from 'liquidjs-lib/src/psbt';\nimport { AddressInterface, IdentityType } from '../types';\nimport { checkIdentityType } from '../utils';\nimport { Identity, IdentityInterface, IdentityOpts } from './identity';\n\n/**\n * This interface describes the shape of the value arguments used in contructor.\n * @member windowProvider a valid property of the browser's window object where to lookup the injected provider\n */\nexport interface InjectOpts {\n  windowProvider: string;\n}\n\nexport interface BrowserInjectProviderInterface {\n  getNextAddress: () => Promise<AddressInterface>;\n  getNextChangeAddress: () => Promise<AddressInterface>;\n  getAddresses: () => Promise<AddressInterface[]>;\n  signTransaction: (psetBase64: string) => Promise<string>;\n}\n\nexport class BrowserInject extends Identity implements IdentityInterface {\n  // here we force MarinaProvider since there aren't other Liquid injected API specification available as TypeScript interface yet.\n  protected provider: BrowserInjectProviderInterface;\n\n  constructor(args: IdentityOpts<InjectOpts>) {\n    super(args);\n\n    // checks the args type.\n    checkIdentityType(args.type, IdentityType.Inject);\n\n    //checks if we are in the brower and if the provider is injected in the dom\n    if (\n      window === undefined ||\n      (window as any)[args.opts.windowProvider] === undefined\n    ) {\n      throw new Error(\n        'The value.windowProvider of IdentityOpts is not valid or the script is to injected in the window'\n      );\n    }\n\n    // the provider must implement BrowserInjectProviderInterface\n    this.provider = (window as any)[args.opts.windowProvider];\n  }\n\n  getNextAddress(): Promise<AddressInterface> {\n    return this.provider.getNextAddress();\n  }\n  getNextChangeAddress(): Promise<AddressInterface> {\n    return this.provider.getNextChangeAddress();\n  }\n  signPset(psetBase64: string): Promise<string> {\n    return this.provider.signTransaction(psetBase64);\n  }\n  getAddresses(): Promise<AddressInterface[]> {\n    return this.provider.getAddresses();\n  }\n  getBlindingPrivateKey(_: string): Promise<string> {\n    throw new Error('Method not implemented.');\n  }\n  isAbleToSign(): boolean {\n    return true;\n  }\n  blindPset(\n    _: string,\n    __: number[],\n    ___?: Map<number, string>,\n    ____?: Map<number, BlindingDataLike>\n  ): Promise<string> {\n    throw new Error('Method not implemented.');\n  }\n}\n","import { BIP32Interface } from 'bip32';\nimport { networks, payments, crypto, address } from 'liquidjs-lib';\nimport { SLIP77Factory, Slip77Interface, TinySecp256k1Interface } from 'slip77';\nimport { MultisigPayment } from './types';\n\n/**\n * Create a P2MS redeemscript.\n * + conf address\n * + unconf address\n * @param keys co-signers public keys.\n * @param blindingKey\n * @param required number of signature required in multisig script.\n * @param network\n */\nexport function p2msPayment(\n  keys: BIP32Interface[],\n  blindingKey: Slip77Interface,\n  required: number,\n  network: networks.Network\n): MultisigPayment {\n  // first generate the unconfidential payment\n  let multisigPayment = payments.p2wsh({\n    redeem: payments.p2ms({\n      m: parseInt(required.toString()), // this is a trick in case of the input returns a string at runtime\n      pubkeys: bip67sort(keys.map(key => key.publicKey)),\n      network,\n    }),\n    network,\n  });\n\n  if (!multisigPayment.address) throw new Error('Invalid payment');\n\n  // generate blinding key\n  const { publicKey, privateKey } = blindingKey.derive(\n    address.toOutputScript(multisigPayment.address, network)\n  );\n  if (!publicKey || !privateKey)\n    throw new Error('something went wrong while generating blinding key pair');\n\n  multisigPayment = payments.p2wsh({\n    redeem: payments.p2ms({\n      m: parseInt(required.toString()), // this is a trick in case of the input returns a string at runtime\n      pubkeys: bip67sort(keys.map(key => key.publicKey)),\n      network,\n    }),\n    blindkey: publicKey,\n    network,\n  });\n\n  if (\n    !multisigPayment.confidentialAddress ||\n    !multisigPayment.redeem ||\n    !multisigPayment.redeem.output\n  )\n    throw new Error('invalid payment');\n\n  return {\n    blindingPrivateKey: privateKey.toString('hex'),\n    confidentialAddress: multisigPayment.confidentialAddress,\n    witnessScript: multisigPayment.redeem.output.toString('hex'),\n  };\n}\n\n/**\n * Return a blinding key from a list of extended keys.\n * @param extendedKeys must be the first addresses of multi-sig stakeholders.\n */\nexport function blindingKeyFromXPubs(\n  extendedKeys: BIP32Interface[],\n  ecclib: TinySecp256k1Interface\n): Slip77Interface {\n  const chainCodes = extendedKeys.map(key => key.chainCode);\n  const seed = blindingKeyFromChainCode(chainCodes);\n  return SLIP77Factory(ecclib).fromSeed(seed);\n}\n\n/**\n * Returns sha256(\"blinding_key\" + xor(chaincodes)) as a blinding key for multisig wallet.\n * https://github.com/cryptoadvance/specter-desktop/blob/master/src/cryptoadvance/specter/liquid/wallet.py#L77-L85\n * @param chainCodes the co-signers xpubs chainCodes (from the first receiving address)\n */\nfunction blindingKeyFromChainCode(chainCodes: Buffer[]): Buffer {\n  const prefix = Buffer.from('blinding_key');\n  let chainCodesXOR = Buffer.alloc(32);\n  for (const chainCode of chainCodes) {\n    chainCodesXOR = xor(chainCodesXOR, chainCode);\n  }\n\n  return crypto.sha256(Buffer.concat([prefix, chainCodesXOR]));\n}\n\n// a xor b\nfunction xor(a: Buffer, b: Buffer): Buffer {\n  if (a.length !== b.length) throw new Error('a.length !== b.length (xor)');\n\n  const result = Buffer.alloc(a.length);\n  for (let i = 0; i < a.length; i++) {\n    result[i] = a[i] ^ b[i];\n  }\n\n  return result;\n}\n\nexport function bip67sort(array: Buffer[]) {\n  return array.sort(bip67compareFunction);\n}\n\nfunction bip67compareFunction(a: Buffer, b: Buffer): number {\n  return a.toString('hex') < b.toString('hex') ? -1 : 1;\n}\n","import BIP32Factory, { BIP32Interface, TinySecp256k1Interface } from 'bip32';\nimport { mnemonicToSeedSync } from 'bip39';\nimport { networks } from 'liquidjs-lib';\nimport { BlindingDataLike } from 'liquidjs-lib/src/psbt';\nimport { Slip77Interface } from 'slip77';\nimport { blindingKeyFromXPubs, p2msPayment } from '../p2ms';\nimport {\n  AddressInterface,\n  MultisigPayment,\n  CosignerMultisig,\n  XPub,\n} from '../types';\nimport { IdentityType } from '../types';\nimport { checkIdentityType, isValidXpub, toXpub } from '../utils';\nimport { IdentityInterface, IdentityOpts } from './identity';\nimport { Identity } from './identity';\n\nexport const DEFAULT_BASE_DERIVATION_PATH = \"m/48'/0'/0'/2'\"; // --> bip48\n\n/**\n * the public keys required to sign are defined by cosignersPublicKeys (xpub)\n * the required number of signature must be < length of cosigners xpubs\n */\nexport interface MultisigWatchOnlyOpts {\n  cosigners: CosignerMultisig[];\n  requiredSignatures: number;\n}\n\nexport class MultisigWatchOnly extends Identity implements IdentityInterface {\n  private nextIndex = 0;\n  private nextChangeIndex = 0;\n\n  static EXTERNAL_INDEX = 0;\n  static INTERNAL_INDEX = 1; // change addresses\n\n  cosigners: BIP32Interface[];\n  blindingKeyMasterNode: Slip77Interface;\n  requiredSignatures: number;\n\n  constructor(args: IdentityOpts<MultisigWatchOnlyOpts>) {\n    super(args);\n    checkIdentityType(args.type, IdentityType.MultisigWatchOnly);\n    checkRequiredSignature(\n      args.opts.requiredSignatures,\n      args.opts.cosigners.length\n    );\n\n    const cosignersPublicKeys = args.opts.cosigners.map(cosigner =>\n      cosignerToXPub(cosigner, this.network, this.ecclib)\n    );\n    cosignersPublicKeys.forEach(isValidXpub);\n\n    this.cosigners = cosignersPublicKeys\n      .sort()\n      .map(xpub => BIP32Factory(this.ecclib).fromBase58(xpub));\n    this.blindingKeyMasterNode = blindingKeyFromXPubs(\n      this.cosigners,\n      this.ecclib\n    );\n\n    this.requiredSignatures = args.opts.requiredSignatures;\n  }\n\n  getNextAddress() {\n    const addr = this.getMultisigAddress(\n      MultisigWatchOnly.EXTERNAL_INDEX,\n      this.nextIndex\n    );\n    this.nextIndex++;\n    return Promise.resolve(addr);\n  }\n\n  getNextChangeAddress() {\n    const addr = this.getMultisigAddress(\n      MultisigWatchOnly.INTERNAL_INDEX,\n      this.nextChangeIndex\n    );\n    this.nextChangeIndex++;\n    return Promise.resolve(addr);\n  }\n\n  getAddresses(): Promise<AddressInterface[]> {\n    const externals = Array.from(Array(this.nextIndex).keys()).map(index =>\n      this.getMultisigAddress(MultisigWatchOnly.EXTERNAL_INDEX, index)\n    );\n    const internals = Array.from(\n      Array(this.nextChangeIndex).keys()\n    ).map(index =>\n      this.getMultisigAddress(MultisigWatchOnly.INTERNAL_INDEX, index)\n    );\n\n    return Promise.resolve(externals.concat(internals));\n  }\n\n  getBlindingPrivateKey(script: string): Promise<string> {\n    const privKey = this.getBlindingKeyPair(script).privateKey;\n    return Promise.resolve(privKey.toString('hex'));\n  }\n\n  private getBlindingKeyPair(script: string) {\n    const keys = this.blindingKeyMasterNode.derive(script);\n    if (!keys.publicKey || !keys.privateKey)\n      throw new Error('unable to generate blinding key pair');\n    return { publicKey: keys.publicKey, privateKey: keys.privateKey };\n  }\n\n  isAbleToSign(): boolean {\n    return false;\n  }\n\n  signPset(_: string): Promise<string> {\n    throw new Error('WatchOnly Multisig Identity is not able to sign pset');\n  }\n\n  blindPset(\n    psetBase64: string,\n    outputsIndexToBlind: number[],\n    outputsPubKeysByIndex?: Map<number, string>,\n    inputsBlindingDataLike?: Map<number, BlindingDataLike>\n  ): Promise<string> {\n    return super.blindPsetWithBlindKeysGetter(\n      (script: Buffer) => this.getBlindingKeyPair(script.toString('hex')),\n      psetBase64,\n      outputsIndexToBlind,\n      outputsPubKeysByIndex,\n      inputsBlindingDataLike\n    );\n  }\n\n  getMultisigAddress(change: number, index: number): MultisigPayment {\n    const keys = this.cosigners.map(cosigner =>\n      cosigner.derive(change).derive(index)\n    );\n\n    const payment = p2msPayment(\n      keys,\n      this.blindingKeyMasterNode,\n      this.requiredSignatures,\n      this.network\n    );\n\n    return { ...payment, derivationPath: `${change}/${index}` };\n  }\n}\n\nfunction checkRequiredSignature(required: number, cosignersLength: number) {\n  if (required <= 0 || required > cosignersLength) {\n    throw new Error(\n      `number of required signatures must be > 0 and <= ${cosignersLength}`\n    );\n  }\n}\n\nfunction cosignerToXPub(\n  cosigner: CosignerMultisig,\n  network: networks.Network,\n  ecclib: TinySecp256k1Interface\n): XPub {\n  if (typeof cosigner === 'string') return cosigner;\n  const walletSeed = mnemonicToSeedSync(cosigner.mnemonic, cosigner.passphrase);\n  const bip32 = BIP32Factory(ecclib);\n  const baseNode = bip32\n    .fromSeed(walletSeed, network)\n    .derivePath(cosigner.baseDerivationPath || DEFAULT_BASE_DERIVATION_PATH);\n  return toXpub(\n    bip32\n      .fromPublicKey(baseNode.publicKey, baseNode.chainCode, network)\n      .toBase58()\n  );\n}\n","import BIP32Factory, { BIP32Interface } from 'bip32';\nimport { mnemonicToSeedSync } from 'bip39';\nimport ECPairFactory from 'ecpair';\nimport { address, networks, Psbt } from 'liquidjs-lib';\nimport { Network } from 'liquidjs-lib/src/networks';\nimport { IdentityType, HDSignerMultisig } from '../types';\nimport { checkIdentityType, checkMnemonic, toXpub } from '../utils';\nimport { IdentityInterface, IdentityOpts } from './identity';\nimport {\n  DEFAULT_BASE_DERIVATION_PATH,\n  MultisigWatchOnly,\n  MultisigWatchOnlyOpts,\n} from './multisigWatchOnly';\n\nexport type MultisigOpts = {\n  signer: HDSignerMultisig;\n} & MultisigWatchOnlyOpts;\n\nexport class Multisig extends MultisigWatchOnly implements IdentityInterface {\n  readonly baseDerivationPath: string;\n  readonly baseNode: BIP32Interface;\n  readonly scriptToPath: Record<string, string>;\n\n  constructor(args: IdentityOpts<MultisigOpts>) {\n    checkIdentityType(args.type, IdentityType.Multisig);\n    checkMnemonic(args.opts.signer.mnemonic);\n\n    const walletSeed = mnemonicToSeedSync(\n      args.opts.signer.mnemonic,\n      args.opts.signer.passphrase\n    );\n    const network = (networks as Record<string, Network>)[args.chain];\n    const masterPrivateKeyNode = BIP32Factory(args.ecclib).fromSeed(\n      walletSeed,\n      network\n    );\n\n    const baseNode = masterPrivateKeyNode.derivePath(\n      args.opts.signer.baseDerivationPath || DEFAULT_BASE_DERIVATION_PATH\n    );\n\n    super({\n      ...args,\n      opts: {\n        ...args.opts,\n        cosigners: args.opts.cosigners.concat([args.opts.signer]),\n      },\n      type: IdentityType.MultisigWatchOnly,\n    });\n\n    this.baseDerivationPath =\n      args.opts.signer.baseDerivationPath || DEFAULT_BASE_DERIVATION_PATH;\n    this.baseNode = baseNode;\n    this.scriptToPath = {};\n  }\n\n  async getNextAddress() {\n    const next = await super.getNextAddress();\n    if (!next.derivationPath)\n      throw new Error('need derivation path to cache addresses');\n    this.scriptToPath[this.toScript(next.confidentialAddress)] =\n      next.derivationPath;\n    return next;\n  }\n\n  async getNextChangeAddress() {\n    const next = await super.getNextChangeAddress();\n    if (!next.derivationPath)\n      throw new Error('need derivation path to cache addresses');\n    this.scriptToPath[this.toScript(next.confidentialAddress)] =\n      next.derivationPath;\n    return next;\n  }\n\n  isAbleToSign(): boolean {\n    return true;\n  }\n\n  async signPset(psetBase64: string): Promise<string> {\n    const pset = Psbt.fromBase64(psetBase64);\n    const signInputPromises: Promise<void>[] = [];\n\n    for (let index = 0; index < pset.data.inputs.length; index++) {\n      const input = pset.data.inputs[index];\n      if (input.witnessUtxo) {\n        const derivationPath = this.scriptToPath[\n          input.witnessUtxo.script.toString('hex')\n        ];\n\n        if (derivationPath) {\n          // if there is an address generated for the input script: build the signing key pair.\n          const privKey = this.baseNode.derivePath(derivationPath).privateKey;\n          if (!privKey) throw new Error('signing private key is undefined');\n          const signingKeyPair = ECPairFactory(this.ecclib).fromPrivateKey(\n            privKey\n          );\n          // add the promise to array\n          signInputPromises.push(pset.signInputAsync(index, signingKeyPair));\n        }\n      }\n    }\n    // wait that all signing promise resolved\n    await Promise.all(signInputPromises);\n    // return the signed pset, base64 encoded.\n    return pset.toBase64();\n  }\n\n  getXPub(): string {\n    return toXpub(\n      BIP32Factory(this.ecclib)\n        .fromPublicKey(\n          this.baseNode.publicKey,\n          this.baseNode.chainCode,\n          this.network\n        )\n        .toBase58()\n    );\n  }\n\n  private toScript(addr: string) {\n    return address.toOutputScript(addr, this.network).toString('hex');\n  }\n}\n","import {\n  ChangeAddressFromAssetGetter,\n  CoinSelectorErrorFn,\n  RecipientInterface,\n  UnblindedOutput,\n  getSats,\n  getAsset,\n} from '../types';\nimport { CompareUtxoFn } from './greedy';\n\nexport const throwErrorHandler: CoinSelectorErrorFn = (\n  asset: string,\n  need: number,\n  has: number\n) => {\n  throw new Error(\n    `not enought funds to fill ${need}sats of ${asset} (amount selected: ${has})`\n  );\n};\n\n// makeChanges creates the change RecipientInterface if needed\nexport const makeChanges = (\n  changeAddressGetter: ChangeAddressFromAssetGetter\n) => (toSelect: Map<string, number>) => (\n  selectedUtxos: UnblindedOutput[]\n): RecipientInterface[] => {\n  const recipients: RecipientInterface[] = [];\n  toSelect.forEach((amount: number, asset: string) => {\n    const changeAmount = diff(selectedUtxos)(asset)(amount);\n    if (changeAmount > 0) {\n      // has change\n      recipients.push({\n        address: changeAddressGetter(asset),\n        asset,\n        value: changeAmount,\n      });\n    }\n  });\n  return recipients;\n};\n\nconst diff = (utxos: UnblindedOutput[]) => (asset: string) => {\n  const sum = sumUtxos(asset)(utxos);\n  return (amount: number) => sum - amount;\n};\n\nconst sumUtxos = (asset: string) => (utxos: UnblindedOutput[]): number =>\n  utxos\n    .filter(makeAssetFilter(asset))\n    .reduce((sum: number, utxo: UnblindedOutput) => sum + getSats(utxo), 0);\n\n// coinSelect is used to select utxo until they fill the amount requested\nexport const coinSelect = (compareFn: CompareUtxoFn) => (\n  errorHandler: CoinSelectorErrorFn\n) => (utxos: UnblindedOutput[]) => (toSelect: Map<string, number>) => {\n  const selectors: ((utxos: UnblindedOutput[]) => UnblindedOutput[])[] = [];\n  const coinSelectorFilter = coinSelectUtxosFilter(compareFn)(errorHandler);\n  toSelect.forEach((amount: number, asset: string) => {\n    selectors.push(coinSelectorFilter(asset)(amount));\n  });\n  return selectors.flatMap(fnSelect => fnSelect(utxos));\n};\n\nexport function reduceRecipients(recipients: RecipientInterface[]) {\n  // - Sanitize recipient.value, it must be a number.\n  // - If is not, try to coerce it into number.\n  // - Throw error if at the end is still not a number.\n  // We were getting 'value' as a string without typescript complaining.\n  // See https://github.com/vulpemventures/ldk/issues/103\n  for (const recipient of recipients) {\n    if (typeof recipient.value !== 'number') {\n      recipient.value = parseInt(recipient.value);\n      if (typeof recipient.value !== 'number') {\n        throw new Error(\n          `invalid '${typeof recipient.value}' type for recipient.value`\n        );\n      }\n    }\n  }\n  return recipients.reduce(recipientsReducer, new Map<string, number>());\n}\n\nfunction recipientsReducer(\n  results: Map<string, number>,\n  next: RecipientInterface\n) {\n  results.set(next.asset, (results.get(next.asset) || 0) + next.value);\n  return results;\n}\n\nfunction makeAssetFilter(assetToFilter: string) {\n  return function(u: UnblindedOutput) {\n    const asset = getAsset(u);\n    return asset === assetToFilter;\n  };\n}\n\nconst coinSelectUtxosFilter = (compareFn: CompareUtxoFn) => (\n  errorHandler: CoinSelectorErrorFn\n) => (asset: string) => (amount: number) => (\n  utxos: UnblindedOutput[]\n): UnblindedOutput[] => {\n  let amtSelected = 0;\n  const assetsUtxos = utxos.filter(makeAssetFilter(asset));\n\n  const selected = assetsUtxos\n    .sort(compareFn)\n    .reduce((selected: UnblindedOutput[], next: UnblindedOutput) => {\n      if (amtSelected <= amount) {\n        selected.push(next);\n        amtSelected += getSats(next);\n      }\n      return selected;\n    }, []);\n\n  // if not enougth amount is selected, use errorHandler\n  if (amtSelected < amount) errorHandler(asset, amount, amtSelected);\n  return selected;\n};\n\nexport const checkCoinSelect = (recipients: RecipientInterface[]) => (\n  selectedUtxos: UnblindedOutput[]\n) => {\n  const inputs = selectedUtxos.map(u => ({\n    value: getSats(u) || 0,\n    asset: getAsset(u) || '',\n  }));\n  return check(inputs)(recipients);\n};\n\nconst check = (inputs: { asset: string; value: number }[]) => (\n  outputs: { asset: string; value: number }[]\n) => {\n  const groupByAsset = groupBy<{ asset: string; value: number }, string>(\n    'asset'\n  );\n  const inputsByAsset = groupByAsset(inputs);\n  const outputsByAsset = groupByAsset(outputs);\n  const inputsAssets = Object.keys(inputsByAsset).sort();\n  const outputsAssets = Object.keys(outputsByAsset).sort();\n\n  if (!inputsAssets.every((asset: string) => outputsAssets.includes(asset))) {\n    throw new Error(\n      `inputs and outputs don't have the same assets. Inputs assets = ${inputsAssets}, Outputs assets = ${outputsAssets}`\n    );\n  }\n\n  for (const asset in inputsByAsset) {\n    const sumInputs = sumNumbers(\n      inputsByAsset[asset].map(({ value }) => value)\n    );\n    const sumOutputs = sumNumbers(\n      outputsByAsset[asset].map(({ value }) => value)\n    );\n\n    if (sumInputs !== sumOutputs) {\n      throw new Error(\n        `missing funds for asset ${asset} (inputs: ${sumInputs}, outputs: ${sumOutputs})`\n      );\n    }\n  }\n};\n\nconst sumNumbers = (values: number[]) =>\n  values.reduce(function(acc, current) {\n    return acc + current;\n  }, 0);\n\nfunction groupBy<\n  T extends Record<string, any>,\n  R extends string | number | symbol\n>(key: string) {\n  return (xs: T[]): Record<R, T[]> => {\n    return xs.reduce(function(rv: Record<any, T[]>, x: T) {\n      (rv[x[key]] = rv[x[key]] || []).push(x);\n      return rv;\n    }, {});\n  };\n}\n","import {\n  ChangeAddressFromAssetGetter,\n  RecipientInterface,\n  getSats,\n  UnblindedOutput,\n} from './../types';\nimport { CoinSelectionResult, CoinSelector } from './coinSelector';\n\nimport {\n  coinSelect,\n  makeChanges,\n  reduceRecipients,\n  throwErrorHandler,\n} from './utils';\n\nexport type CompareUtxoFn = (a: UnblindedOutput, b: UnblindedOutput) => number;\n\nconst defaultCompareFn: CompareUtxoFn = (\n  a: UnblindedOutput,\n  b: UnblindedOutput\n) => getSats(a) - getSats(b);\n\n/**\n * select utxo for outputs among unspents.\n * @param unspents a set of unspents.\n * @param recipients the outputs targetted by the coin selection\n */\nexport function greedyCoinSelector(sortFn = defaultCompareFn): CoinSelector {\n  return (errorHandler = throwErrorHandler) => {\n    const coinSelectFn = coinSelect(sortFn)(errorHandler);\n    return (\n      unspents: UnblindedOutput[],\n      recipients: RecipientInterface[],\n      changeAddressGetter: ChangeAddressFromAssetGetter\n    ): CoinSelectionResult => {\n      const makeChangesFn = makeChanges(changeAddressGetter);\n      const recipientsMap = reduceRecipients(recipients);\n      const selectedUtxos = coinSelectFn(unspents)(recipientsMap);\n      const changeOutputs = makeChangesFn(recipientsMap)(selectedUtxos);\n\n      return {\n        selectedUtxos,\n        changeOutputs,\n      };\n    };\n  };\n}\n","import axios from 'axios';\nimport { Transaction, TxOutput } from 'liquidjs-lib';\nimport {\n  TxInterface,\n  InputInterface,\n  Output,\n  Outpoint,\n  isUnblindedOutput,\n  getSats,\n  getAsset,\n} from '../types';\nimport { EsploraTx, EsploraUtxo } from './types';\n\n/**\n * Fetch the raw transaction by txid\n * @param txId txID to fetch\n * @param url esplora URL\n */\nexport async function fetchTxHex(txId: string, url: string): Promise<string> {\n  return (await axios.get(`${url}/tx/${txId}/hex`)).data;\n}\n\n/**\n * Fetch the transaction as TxInterface (with prevouts)\n * @param txId transaction's hash to fetch\n * @param url the esplora URL\n */\nexport async function fetchTx(txId: string, url: string): Promise<TxInterface> {\n  return esploraTxToTxInterface(\n    (await axios.get(`${url}/tx/${txId}`)).data,\n    url\n  );\n}\n\n/**\n * Fetch unspents for a given address.\n * @param address\n * @param url the esplora URL\n */\nexport async function fetchUtxos(\n  address: string,\n  url: string\n): Promise<Output[]> {\n  const esploraUtxos: EsploraUtxo[] = (\n    await axios.get(`${url}/address/${address}/utxo`)\n  ).data;\n  return Promise.all(esploraUtxos.map(outpointToUtxo(url)));\n}\n\nconst outpointToUtxo = (esploraURL: string) => async (\n  outpoint: Outpoint\n): Promise<Output> => {\n  const prevoutHex: string = await fetchTxHex(outpoint.txid, esploraURL);\n  const prevout = Transaction.fromHex(prevoutHex).outs[outpoint.vout];\n  return { ...outpoint, prevout };\n};\n\n/**\n * Convert an esplora transaction to a TxInterface\n * @param esploraTx\n * @param explorerUrl\n */\nexport async function esploraTxToTxInterface(\n  esploraTx: EsploraTx,\n  explorerUrl: string\n): Promise<TxInterface> {\n  const inputTxIds: string[] = [];\n  const inputVouts: number[] = [];\n\n  for (const input of esploraTx.vin) {\n    inputTxIds.push(input.txid);\n    inputVouts.push(input.vout);\n  }\n\n  const prevoutTxHexs = await Promise.all(\n    inputTxIds.map((txid, index) => {\n      if (!esploraTx.vin[index].is_pegin) return fetchTxHex(txid, explorerUrl);\n      return Promise.resolve(undefined); // return undefined in case of pegin\n    })\n  );\n\n  const prevoutAsOutput = prevoutTxHexs.map(\n    (hex: string | undefined, index: number) => {\n      if (!hex) return undefined;\n      return makeOutput(\n        { txid: inputTxIds[index], vout: inputVouts[index] },\n        Transaction.fromHex(hex).outs[inputVouts[index]]\n      );\n    }\n  );\n\n  const txInputs: InputInterface[] = inputTxIds.map(\n    (txid: string, index: number) => {\n      return {\n        prevout: prevoutAsOutput[index],\n        txid: txid,\n        vout: inputVouts[index],\n        isPegin: esploraTx.vin[index].is_pegin,\n      };\n    }\n  );\n\n  const txHex = await fetchTxHex(esploraTx.txid, explorerUrl);\n  const transaction = Transaction.fromHex(txHex);\n\n  const makeOutpoint = (index: number): Outpoint => ({\n    txid: esploraTx.txid,\n    vout: index,\n  });\n  const makeOutputFromTxout = (txout: TxOutput, index: number): Output =>\n    makeOutput(makeOutpoint(index), txout);\n  const txOutputs = transaction.outs.map(makeOutputFromTxout);\n\n  const tx: TxInterface = {\n    txid: esploraTx.txid,\n    vin: txInputs,\n    vout: txOutputs,\n    fee: esploraTx.fee,\n    status: {\n      confirmed: esploraTx.status.confirmed,\n      blockHash: esploraTx.status.block_hash,\n      blockHeight: esploraTx.status.block_height,\n      blockTime: esploraTx.status.block_time,\n    },\n  };\n\n  return tx;\n}\n\n// util function for output mapping\nfunction makeOutput(outpoint: Outpoint, txOutput: TxOutput): Output {\n  return {\n    ...outpoint,\n    prevout: txOutput,\n  };\n}\n\n/**\n * Create unblinded explorer URL from blinding data\n * @param baseURL\n * @param txID\n * @param outputsBlinder\n */\nexport function makeUnblindURL(\n  baseURL: string,\n  txID: string,\n  outputsBlinder: {\n    value: number;\n    asset: string;\n    assetBlinder: string;\n    valueBlinder: string;\n  }[]\n): string {\n  const outputsString = outputsBlinder\n    .map(\n      ({ value, asset, assetBlinder, valueBlinder }) =>\n        `${value},${asset},${valueBlinder},${assetBlinder}`\n    )\n    .join(',');\n  return `${baseURL}/tx/${txID}#blinded=${outputsString}`;\n}\n\n/**\n * Create explorer URL with unblinding data\n * @param tx transaction to create the link for\n * @param baseURL base web Explorer URL\n */\nexport function getUnblindURLFromTx(tx: TxInterface, baseURL: string) {\n  const outputsData: {\n    value: number;\n    asset: string;\n    assetBlinder: string;\n    valueBlinder: string;\n  }[] = [];\n\n  const reverseHex = (blinder: string) =>\n    Buffer.from(blinder, 'hex')\n      .reverse()\n      .toString('hex');\n\n  for (const output of tx.vout) {\n    if (output.prevout.script.length > 0 && isUnblindedOutput(output)) {\n      outputsData.push({\n        value: getSats(output),\n        asset: getAsset(output),\n        assetBlinder: reverseHex(\n          output.unblindData.assetBlindingFactor.toString('hex')\n        ),\n        valueBlinder: reverseHex(\n          output.unblindData.valueBlindingFactor.toString('hex')\n        ),\n      });\n    }\n  }\n\n  return makeUnblindURL(baseURL, tx.txid, outputsData);\n}\n","export default class UnblindError extends Error {\n  constructor(txid: string, vout: number, blindingKey: string) {\n    super(\n      `UnblindError output (${txid}:${vout}) with blind key ${blindingKey}`\n    );\n  }\n}\n","import axios from 'axios';\nimport UnblindError from '../error/unblind-error';\nimport {\n  BlindingKeyGetter,\n  BlindingKeyGetterAsync,\n  isUnblindedOutput,\n  TxInterface,\n} from '../types';\nimport { isConfidentialOutput, unblindOutput } from '../utils';\nimport { esploraTxToTxInterface } from './esplora';\nimport { EsploraTx } from './types';\n\n/**\n * Return an async generator fetching and unblinding addresses' transactions\n * @param addresses\n * @param blindingKeyGetter\n * @param explorerUrl\n * @param skip optional, can be used to skip certain transaction\n */\nexport async function* fetchAndUnblindTxsGenerator(\n  addresses: string[],\n  blindingKeyGetter: BlindingKeyGetter,\n  explorerUrl: string,\n  skip?: (tx: TxInterface) => boolean\n): AsyncGenerator<\n  TxInterface,\n  { txIDs: string[]; errors: Error[] },\n  undefined\n> {\n  const txIDs: string[] = [];\n  const errors: Error[] = [];\n\n  for (const address of addresses) {\n    try {\n      const txsGenerator = fetchTxsGenerator(address, explorerUrl, skip);\n      let txIterator = await txsGenerator.next();\n      while (!txIterator.done) {\n        const tx = txIterator.value;\n        if (txIDs.includes(tx.txid)) {\n          txIterator = await txsGenerator.next();\n          continue;\n        }\n\n        const { unblindedTx, errors: errs } = await unblindTransaction(\n          tx,\n          async (script: string) => blindingKeyGetter(script)\n        );\n        errors.push(...errs);\n        yield unblindedTx;\n\n        txIDs.push(tx.txid);\n        txIterator = await txsGenerator.next();\n      }\n    } catch (err) {\n      if (err instanceof Error) {\n        errors.push(err);\n      }\n\n      if (typeof err === 'string') {\n        errors.push(new Error(err));\n      }\n\n      errors.push(new Error('unknown error'));\n    }\n  }\n  return { txIDs, errors };\n}\n\n/**\n * Use FetchAndUnblindTxsGenerator to get all utxos for a set of addresses\n * @param addresses\n * @param blindingKeyGetter\n * @param explorerUrl\n * @param skip optional\n */\nexport async function fetchAndUnblindTxs(\n  addresses: string[],\n  blindingKeyGetter: BlindingKeyGetter,\n  explorerUrl: string,\n  skip?: (tx: TxInterface) => boolean\n): Promise<TxInterface[]> {\n  const generator = fetchAndUnblindTxsGenerator(\n    addresses,\n    blindingKeyGetter,\n    explorerUrl,\n    skip\n  );\n\n  const txs: TxInterface[] = [];\n\n  let iterator = await generator.next();\n  while (!iterator.done) {\n    txs.push(iterator.value);\n    iterator = await generator.next();\n  }\n\n  return txs;\n}\n\n/**\n * Fetch all the txs associated to a given address and unblind them using the blindingPrivateKey.\n * @param address the confidential address\n * @param explorerUrl the Esplora URL API using to fetch blockchain data.\n */\nasync function* fetchTxsGenerator(\n  address: string,\n  explorerUrl: string,\n  skip?: (tx: TxInterface) => boolean\n): AsyncGenerator<TxInterface, number, undefined> {\n  let lastSeenTxid = undefined;\n  let newTxs: EsploraTx[] = [];\n  let numberOfTxs = 0;\n\n  do {\n    // fetch up to 25 txs\n    newTxs = await fetch25newestTxsForAddress(\n      address,\n      explorerUrl,\n      lastSeenTxid\n    );\n\n    if (newTxs.length === 0) break;\n    lastSeenTxid = newTxs[newTxs.length - 1].txid;\n    numberOfTxs += newTxs.length;\n\n    // convert them into txInterface\n    const txs: Promise<TxInterface>[] = newTxs.map(tx =>\n      esploraTxToTxInterface(tx, explorerUrl)\n    );\n\n    for (const tx of txs) {\n      const transaction = await tx;\n      if (skip?.(transaction)) {\n        continue;\n      }\n      yield transaction;\n    }\n  } while (lastSeenTxid);\n\n  return numberOfTxs;\n}\n\n/**\n * takes the a TxInterface and try to transform BlindedOutputInterface to UnblindedOutputInterface (prevouts & outputs)\n * @param tx transaction to unblind\n * @param blindingPrivateKeys the privateKeys using to unblind the outputs.\n */\nexport async function unblindTransaction(\n  tx: TxInterface,\n  blindingPrivateKeyGetter: BlindingKeyGetterAsync\n): Promise<{ unblindedTx: TxInterface; errors: UnblindError[] }> {\n  const promises: Promise<void>[] = [];\n  const errors: UnblindError[] = [];\n\n  // try to unblind prevouts, if success replace blinded prevout by unblinded prevout\n  for (let inputIndex = 0; inputIndex < tx.vin.length; inputIndex++) {\n    const output = tx.vin[inputIndex].prevout;\n    if (output && isConfidentialOutput(output.prevout)) {\n      const promise = async () => {\n        const blindingKey = await blindingPrivateKeyGetter(\n          output.prevout.script.toString('hex')\n        );\n        if (blindingKey) {\n          try {\n            const unblinded = await unblindOutput(output, blindingKey);\n            tx.vin[inputIndex].prevout = unblinded;\n          } catch (_) {\n            errors.push(\n              new UnblindError(\n                tx.vin[inputIndex].txid,\n                tx.vin[inputIndex].vout,\n                blindingKey\n              )\n            );\n          }\n        }\n      };\n\n      promises.push(promise());\n    }\n  }\n\n  // try to unblind outputs\n  for (let outputIndex = 0; outputIndex < tx.vout.length; outputIndex++) {\n    const output = tx.vout[outputIndex];\n    if (!isUnblindedOutput(output)) {\n      const promise = async () => {\n        const blindingKey = await blindingPrivateKeyGetter(\n          output.prevout.script.toString('hex')\n        );\n        if (blindingKey) {\n          try {\n            const unblinded = await unblindOutput(output, blindingKey);\n            tx.vout[outputIndex] = unblinded;\n          } catch (err) {\n            errors.push(new UnblindError(tx.txid, outputIndex, blindingKey));\n          }\n        }\n      };\n\n      promises.push(promise());\n    }\n  }\n\n  await Promise.all(promises);\n\n  return { unblindedTx: tx, errors };\n}\n\nasync function fetch25newestTxsForAddress(\n  address: string,\n  explorerUrl: string,\n  lastSeenTxid?: string\n): Promise<EsploraTx[]> {\n  let url = `${explorerUrl}/address/${address}/txs/chain`;\n  if (lastSeenTxid) {\n    url += `/${lastSeenTxid}`;\n  }\n\n  const response = await axios.get(url);\n  return response.data;\n}\n","import ECPairFactory, { TinySecp256k1Interface } from 'ecpair';\nimport { address } from 'liquidjs-lib';\nimport UnblindError from '../error/unblind-error';\nimport {\n  AddressInterface,\n  InputInterface,\n  TxInterface,\n  UnblindedOutput,\n  Output,\n} from '../types';\nimport { unblindOutput } from '../utils';\nimport { fetchUtxos } from './esplora';\n\n/**\n * fetchAndUnblindUtxosGenerator returns the unblinded utxos associated with a set of addresses.\n * @param addressesAndBlindingKeys the set of addresses with blinding key (if confidential)\n * @param url esplora URL\n * @param skip optional, using to skip blinding step\n */\nexport async function* fetchAndUnblindUtxosGenerator(\n  ecclib: TinySecp256k1Interface,\n  addressesAndBlindingKeys: AddressInterface[],\n  url: string,\n  skip?: (utxo: Output) => boolean\n): AsyncGenerator<\n  UnblindedOutput,\n  { numberOfUtxos: number; errors: Error[] },\n  undefined\n> {\n  let numberOfUtxos = 0;\n  const errors = [];\n\n  // the generator repeats the process for each addresses\n  for (const {\n    confidentialAddress,\n    blindingPrivateKey,\n  } of addressesAndBlindingKeys) {\n    try {\n      // check the blinding private key\n      if (blindingPrivateKey.length > 0) {\n        const blindingKeyPair = ECPairFactory(ecclib).fromPrivateKey(\n          Buffer.from(blindingPrivateKey, 'hex')\n        );\n        const addressPublicKey = address.fromConfidential(confidentialAddress)\n          .blindingKey;\n        if (!blindingKeyPair.publicKey.equals(addressPublicKey)) {\n          throw new Error('wrong blinding private key');\n        }\n      }\n\n      // fetch the unspents\n      const blindedUtxos = await fetchUtxos(confidentialAddress, url);\n\n      // at each 'next' call, the generator will return the result of the next promise\n      for (const blindedUtxo of blindedUtxos) {\n        if (skip?.(blindedUtxo)) continue;\n\n        yield await tryToUnblindUtxo(blindedUtxo, blindingPrivateKey);\n        numberOfUtxos++;\n      }\n    } catch (err) {\n      if (err instanceof Error) errors.push(err);\n      if (typeof err === 'string') errors.push(new Error(err));\n      errors.push(new Error('unknow error'));\n    }\n  }\n  return { numberOfUtxos, errors };\n}\n\n// Aggregate generator's result.\nexport async function fetchAndUnblindUtxos(\n  ecclib: TinySecp256k1Interface,\n  addressesAndBlindingKeys: AddressInterface[],\n  url: string,\n  skip?: (utxo: Output) => boolean\n): Promise<UnblindedOutput[]> {\n  const utxosGenerator = fetchAndUnblindUtxosGenerator(\n    ecclib,\n    addressesAndBlindingKeys,\n    url,\n    skip\n  );\n  const utxos: UnblindedOutput[] = [];\n\n  let iterator = await utxosGenerator.next();\n  while (!iterator.done) {\n    utxos.push(iterator.value);\n    iterator = await utxosGenerator.next();\n  }\n\n  return utxos;\n}\n\n/**\n * try to unblind the utxo with blindPrivKey. if unblind fails, return utxo\n * if unblind step success: set prevout & unblindData members in UtxoInterface result\n * @param utxo utxo to unblind\n * @param blindPrivKey the blinding private key using to unblind\n * @param url esplora endpoint URL\n */\nexport async function tryToUnblindUtxo(\n  utxo: Output,\n  blindPrivKey: string\n): Promise<UnblindedOutput> {\n  try {\n    return unblindOutput(utxo, blindPrivKey);\n  } catch (_) {\n    throw new UnblindError(utxo.txid, utxo.vout, blindPrivKey);\n  }\n}\n\n/**\n * Reduce a set of transactions using a set of scripts\n * @param txs the wallet's transactions\n * @param walletScripts the set of scripts to use in order to filter tx's outputs\n * @param initialState initial utxos state (set in txs reducer) - optional (default: [])\n */\nexport function utxosFromTransactions(\n  txs: TxInterface[],\n  walletScripts: Set<string>,\n  initialState: (Output | UnblindedOutput)[] = []\n): (Output | UnblindedOutput)[] {\n  const orInfinity = (a?: number) => (a ? a : Infinity);\n  const compareBlockHeight = (a: TxInterface, b: TxInterface) =>\n    orInfinity(a.status.blockHeight) - orInfinity(b.status.blockHeight) || 0;\n  const compareVin = (a: TxInterface, b: TxInterface) =>\n    a.vin.map(i => i.txid).includes(b.txid) ? 1 : -1;\n  const compare = (a: TxInterface, b: TxInterface) =>\n    compareBlockHeight(a, b) || compareVin(a, b);\n  return txs\n    .sort(compare)\n    .reduce((utxoSet: (Output | UnblindedOutput)[], tx: TxInterface, _) => {\n      const withoutSpentUtxo = removeInputsFromUtxos(utxoSet, tx.vin);\n      return addOutputsToUtxos(withoutSpentUtxo, tx, walletScripts);\n    }, initialState);\n}\n\nfunction addOutputsToUtxos(\n  utxos: (Output | UnblindedOutput)[],\n  tx: TxInterface,\n  walletScripts: Set<string>\n) {\n  const isWalletOutput = (o: Output) =>\n    walletScripts.has(o.prevout.script.toString('hex'));\n  const walletOutputs = tx.vout.filter(isWalletOutput);\n  return utxos.concat(walletOutputs);\n}\n\nfunction removeInputsFromUtxos(utxoSet: Output[], inputs: InputInterface[]) {\n  let result = utxoSet;\n  for (const input of inputs) {\n    result = result.filter(\n      u => !(u.txid === input.txid && u.vout === input.vout)\n    );\n  }\n\n  return result;\n}\n","import { confidential } from 'liquidjs-lib';\nimport { BlindingKeyGetterAsync, TxInterface, UnblindedOutput } from '../types';\nimport { isConfidentialOutput } from '../utils';\nimport { ChainAPI } from './api';\nimport { unblindTransaction } from './transaction';\nimport { EsploraTx, EsploraUtxo } from './types';\nimport { tryToUnblindUtxo } from './utxos';\n\nexport async function* utxosFetchGenerator(\n  addresses: string[],\n  blindingKeyGetter: BlindingKeyGetterAsync,\n  api: ChainAPI,\n  skip?: (utxo: EsploraUtxo) => boolean\n): AsyncGenerator<\n  UnblindedOutput,\n  { numberOfUtxos: number; errors: Error[] },\n  undefined\n> {\n  let numberOfUtxos = 0;\n  const errors = [];\n  const utxos = await api.fetchUtxos(addresses, skip);\n  for (const utxo of utxos) {\n    try {\n      if (!isConfidentialOutput(utxo.prevout)) {\n        yield {\n          ...utxo,\n          unblindData: {\n            asset: utxo.prevout.asset.slice(1),\n            value: confidential\n              .confidentialValueToSatoshi(utxo.prevout.value)\n              .toString(10),\n            assetBlindingFactor: Buffer.alloc(32),\n            valueBlindingFactor: Buffer.alloc(32),\n          },\n        };\n      }\n\n      const privateBlindingKey = await blindingKeyGetter(\n        utxo.prevout.script.toString('hex')\n      );\n      if (!privateBlindingKey) {\n        // do not unblind, just skip and continue\n        continue;\n      }\n\n      const unblindedUtxo = await tryToUnblindUtxo(utxo, privateBlindingKey);\n      yield unblindedUtxo;\n      numberOfUtxos++;\n    } catch (err) {\n      console.log(err);\n      if (err instanceof Error) {\n        errors.push(err);\n      }\n\n      if (typeof err === 'string') {\n        errors.push(new Error(err));\n      }\n      errors.push(new Error('unknown error'));\n    }\n  }\n\n  return { numberOfUtxos, errors };\n}\n\nexport async function* txsFetchGenerator(\n  addresses: string[],\n  blindingKeyGetter: BlindingKeyGetterAsync,\n  api: ChainAPI,\n  skip?: (tx: EsploraTx) => boolean\n): AsyncGenerator<\n  TxInterface,\n  { txIDs: string[]; errors: Error[] },\n  undefined\n> {\n  const txIDs: string[] = [];\n  const errors: Error[] = [];\n  const transactions = await api.fetchTxs(addresses, skip);\n  for (const tx of transactions) {\n    try {\n      const { unblindedTx, errors: errs } = await unblindTransaction(\n        tx,\n        blindingKeyGetter\n      );\n      errors.push(...errs);\n      yield unblindedTx;\n\n      txIDs.push(tx.txid);\n    } catch (err) {\n      if (err instanceof Error) {\n        errors.push(err);\n      }\n\n      if (typeof err === 'string') {\n        errors.push(new Error(err));\n      }\n      errors.push(new Error('unknown error'));\n    }\n  }\n  return { txIDs, errors };\n}\n\nexport async function fetchAllTxs(\n  addresses: string[],\n  blindingKeyGetter: BlindingKeyGetterAsync,\n  api: ChainAPI,\n  skip?: (tx: EsploraTx) => boolean\n): Promise<TxInterface[]> {\n  const txs: TxInterface[] = [];\n  for await (const tx of txsFetchGenerator(\n    addresses,\n    blindingKeyGetter,\n    api,\n    skip\n  )) {\n    txs.push(tx);\n  }\n  return txs;\n}\n\nexport async function fetchAllUtxos(\n  addresses: string[],\n  blindingKeyGetter: BlindingKeyGetterAsync,\n  api: ChainAPI,\n  skip?: (utxo: EsploraUtxo) => boolean\n): Promise<UnblindedOutput[]> {\n  const utxos: UnblindedOutput[] = [];\n  for await (const utxo of utxosFetchGenerator(\n    addresses,\n    blindingKeyGetter,\n    api,\n    skip\n  )) {\n    utxos.push(utxo);\n  }\n  return utxos;\n}\n","import axios, { AxiosInstance } from 'axios';\nimport { Transaction, TxOutput } from 'liquidjs-lib';\nimport { InputInterface, Outpoint, Output, TxInterface } from '../types';\nimport { EsploraTx, EsploraUtxo } from './types';\n\nexport interface ChainAPI {\n  fetchUtxos(\n    addresses: string[],\n    skip?: (utxo: EsploraUtxo) => boolean\n  ): Promise<Output[]>;\n  fetchTxs(\n    addresses: string[],\n    skip?: (esploraTx: EsploraTx) => boolean\n  ): Promise<TxInterface[]>;\n  fetchTxsHex(txids: string[]): Promise<{ txid: string; hex: string }[]>;\n  addressesHasBeenUsed(addresses: string[]): Promise<boolean[]>;\n}\n\n/**\n * Esplora is the ChainAPI implmentation for regular esplora instance\n * Esplora also exports extra methods specific to esplora instance\n */\nexport class Electrs implements ChainAPI {\n  readonly electrsURL: string;\n  readonly axios: AxiosInstance;\n\n  constructor(url: string, axiosIns?: AxiosInstance) {\n    this.electrsURL = url;\n    this.axios = axiosIns ?? axios.create();\n  }\n\n  static fromURL(url: string): Electrs {\n    return new Electrs(url);\n  }\n\n  async addressesHasBeenUsed(addresses: string[]): Promise<boolean[]> {\n    const hasBeenUsed = async (address: string) => {\n      try {\n        const data = (\n          await axios.get(`${this.electrsURL}/address/${address}/txs`)\n        ).data;\n        return data.length > 0;\n      } catch (e) {\n        return false;\n      }\n    };\n    return Promise.all(addresses.map(hasBeenUsed));\n  }\n\n  async fetchUtxos(\n    addresses: string[],\n    skip?: (utxo: EsploraUtxo) => boolean\n  ): Promise<Output[]> {\n    const reqs = addresses.map(address =>\n      this.axios.get(`${this.electrsURL}/address/${address}/utxo`)\n    );\n    const responses = await Promise.allSettled(reqs);\n    const resolvedResponses = responses.map(r =>\n      r.status === 'fulfilled' ? r.value.data : []\n    );\n    const utxos = resolvedResponses.map(r => (r ? r : []));\n    return Promise.all(\n      utxos\n        .flat()\n        .filter((u: EsploraUtxo) => (skip ? !skip(u) : true))\n        .map(this.outpointToUtxo())\n    );\n  }\n\n  async fetchTxs(\n    addresses: string[],\n    skip?: (tx: EsploraTx) => boolean\n  ): Promise<TxInterface[]> {\n    const esploraTxs = await Promise.all(\n      addresses.map(this.fetchAllTxsForAddress())\n    );\n    const txs = esploraTxs\n      .flat()\n      .filter((tx: EsploraTx) => (skip ? !skip(tx) : true))\n      .map(esploraTxToTxInterface(ids => this.fetchTxsHex(ids)));\n    return Promise.all(txs);\n  }\n\n  async fetchTxHex(txid: string): Promise<string> {\n    const h = (await this.axios.get(`${this.electrsURL}/tx/${txid}/hex`)).data;\n    return h;\n  }\n\n  async fetchTxsHex(txids: string[]): Promise<{ txid: string; hex: string }[]> {\n    return Promise.all(\n      txids.map(async txid => ({ txid, hex: await this.fetchTxHex(txid) }))\n    );\n  }\n\n  async fetchTx(txid: string): Promise<TxInterface> {\n    return esploraTxToTxInterface(ids => this.fetchTxsHex(ids))(\n      (await this.axios.get(`${this.electrsURL}/tx/${txid}`)).data\n    );\n  }\n\n  private fetchAllTxsForAddress() {\n    return async (address: string): Promise<EsploraTx[]> => {\n      let lastSeenTxid = undefined;\n      const txs = [];\n      do {\n        // fetch up to 25 txs\n        const nextTxs: EsploraTx[] = await this.fetch25newestTxsForAddress(\n          address,\n          lastSeenTxid\n        );\n\n        if (nextTxs.length === 0) break;\n        txs.push(...nextTxs);\n        if (nextTxs.length < 25) break;\n        lastSeenTxid = nextTxs[nextTxs.length - 1].txid;\n      } while (lastSeenTxid);\n      return txs;\n    };\n  }\n\n  private async fetch25newestTxsForAddress(\n    address: string,\n    lastSeenTxid?: string\n  ): Promise<EsploraTx[]> {\n    let url = `${this.electrsURL}/address/${address}/txs/chain`;\n    if (lastSeenTxid) {\n      url += `/${lastSeenTxid}`;\n    }\n\n    const response = await this.axios.get(url);\n    return response.data;\n  }\n\n  protected outpointToUtxo() {\n    return async (outpoint: Outpoint): Promise<Output> => {\n      const prevoutHex = await this.fetchTxHex(outpoint.txid);\n      const prevout = Transaction.fromHex(prevoutHex).outs[outpoint.vout];\n      return { ...outpoint, prevout };\n    };\n  }\n}\n\n// https://electrs-batch-server.vulpem.com/\nexport class ElectrsBatchServer extends Electrs implements ChainAPI {\n  constructor(\n    readonly batchServerURL: string,\n    readonly electrsURL: string,\n    axiosIns?: AxiosInstance\n  ) {\n    super(electrsURL, axiosIns);\n  }\n\n  static fromURL(_: string): ElectrsBatchServer {\n    throw new Error(\n      'Not implemented: use Electrs.fromURL or ElectrsBatchServer.fromURLs instead'\n    );\n  }\n\n  static fromURLs(url: string, electrsUrl: string): ElectrsBatchServer {\n    return new ElectrsBatchServer(url, electrsUrl);\n  }\n\n  async addressesHasBeenUsed(addresses: string[]): Promise<boolean[]> {\n    const response = await this.axios.post(\n      `${this.batchServerURL}/addresses/transactions`,\n      { addresses }\n    );\n    const results = [];\n    for (const { transaction } of response.data) {\n      results.push(transaction.length > 0);\n    }\n    return results;\n  }\n\n  async fetchUtxos(\n    addresses: string[],\n    skip?: (utxo: EsploraUtxo) => boolean\n  ): Promise<Output[]> {\n    const response = await this.axios.post(\n      `${this.batchServerURL}/addresses/utxo`,\n      { addresses }\n    );\n    if (response.status !== 200) {\n      throw new Error(`Error fetching utxos: ${response.status}`);\n    }\n\n    if (!response.data || !Array.isArray(response.data)) {\n      throw new Error('Invalid response from batch server');\n    }\n\n    const utxos = [];\n    for (const { utxo } of response.data) {\n      if (!Array.isArray(utxo)) continue;\n      if (utxo.length === 0) continue;\n      utxos.push(...utxo);\n    }\n\n    return await Promise.all(\n      utxos\n        .filter((u: EsploraUtxo) => (skip ? !skip(u) : true))\n        .map(super.outpointToUtxo())\n    );\n  }\n\n  async fetchTxsHex(txids: string[]): Promise<{ txid: string; hex: string }[]> {\n    const response = await this.axios.post(\n      `${this.batchServerURL}/transactions/hex`,\n      { txids }\n    );\n    return response.data || [];\n  }\n\n  async fetchTxs(\n    addresses: string[],\n    skip?: (tx: EsploraTx) => boolean\n  ): Promise<TxInterface[]> {\n    const response = await this.axios.post(\n      `${this.batchServerURL}/addresses/transactions`,\n      { addresses }\n    );\n    const promises = [];\n\n    for (const { transaction } of response.data) {\n      if (transaction.length === 0) continue;\n      promises.push(\n        ...transaction\n          .filter((tx: EsploraTx) => (skip ? !skip(tx) : true))\n          .map(esploraTxToTxInterface(ids => this.fetchTxsHex(ids)))\n      );\n    }\n    return Promise.all(promises);\n  }\n}\n\n// util function for output mapping\nfunction makeOutput(outpoint: Outpoint, txOutput: TxOutput): Output {\n  return {\n    ...outpoint,\n    prevout: txOutput,\n  };\n}\n\nfunction esploraTxToTxInterface(\n  fetchTxFn: (txIDs: string[]) => Promise<{ txid: string; hex: string }[]>\n) {\n  return async (esploraTx: EsploraTx): Promise<TxInterface> => {\n    // make an unique call to the api to fetch all the transaction needed\n    // prevouts transactions (except pegin) + the current transaction\n    const transactions = await fetchTxFn([\n      ...esploraTx.vin.filter(input => !input.is_pegin).map(i => i.txid),\n      esploraTx.txid,\n    ]);\n\n    const makePrevout = ({ txid, vout }: Outpoint): Output => {\n      const hex = transactions?.find(t => t.txid === txid);\n      if (!hex) throw new Error(`Could not find tx ${txid}`);\n      const prevout = Transaction.fromHex(hex.hex).outs[vout];\n      return makeOutput({ txid, vout }, prevout);\n    };\n\n    const txInputs: InputInterface[] = esploraTx.vin.map(input => ({\n      prevout: input.is_pegin ? undefined : makePrevout(input),\n      txid: input.txid,\n      vout: input.vout,\n      isPegin: input.is_pegin,\n    }));\n\n    const txHex = transactions?.find(t => t.txid === esploraTx.txid)?.hex;\n    if (!txHex) throw new Error(`Could not find tx ${esploraTx.txid}`);\n    const transaction = Transaction.fromHex(txHex);\n\n    const makeOutpoint = (index: number): Outpoint => ({\n      txid: esploraTx.txid,\n      vout: index,\n    });\n\n    const makeOutputFromTxout = (txout: TxOutput, index: number): Output =>\n      makeOutput(makeOutpoint(index), txout);\n    const txOutputs = transaction.outs.map(makeOutputFromTxout);\n\n    const tx: TxInterface = {\n      txid: esploraTx.txid,\n      vin: txInputs,\n      vout: txOutputs,\n      fee: esploraTx.fee,\n      status: {\n        confirmed: esploraTx.status.confirmed,\n        blockHash: esploraTx.status.block_hash,\n        blockHeight: esploraTx.status.block_height,\n        blockTime: esploraTx.status.block_time,\n      },\n    };\n\n    return tx;\n  };\n}\n","import {\n  CoinSelectionResult,\n  CoinSelector,\n} from './coinselection/coinSelector';\nimport {\n  ChangeAddressFromAssetGetter,\n  RecipientInterface,\n  UnblindedOutput,\n  Output,\n  CoinSelectorErrorFn,\n} from './types';\nimport {\n  Psbt,\n  address as laddress,\n  AssetHash,\n  confidential,\n} from 'liquidjs-lib';\nimport { checkCoinSelect, throwErrorHandler } from './coinselection/utils';\nimport { decodePset } from './utils';\n\nexport function craftSingleRecipientPset(\n  unspents: UnblindedOutput[],\n  recipient: RecipientInterface,\n  coinSelector: CoinSelector,\n  changeAddressByAsset: ChangeAddressFromAssetGetter,\n  substractFeeFromRecipient = false,\n  satsPerByte = DEFAULT_SATS_PER_BYTE\n) {\n  const network = laddress.getNetwork(recipient.address);\n  const substractScenario =\n    substractFeeFromRecipient && recipient.asset === network.assetHash;\n\n  const firstSelection = coinSelector(throwErrorHandler)(\n    unspents,\n    [recipient],\n    changeAddressByAsset\n  );\n\n  const fee = createFeeOutput(\n    firstSelection.selectedUtxos.length,\n    // Change outputs + 1 recipient + 1 fee\n    firstSelection.changeOutputs.length + 2,\n    satsPerByte,\n    network.assetHash\n  );\n\n  let errorHandler: CoinSelectorErrorFn = throwErrorHandler;\n  if (substractScenario) {\n    errorHandler = (asset: string, need: number, has: number) => {\n      if (asset === recipient.asset) {\n        recipient.value = has - fee.value;\n        return;\n      } // do not throw error if not enougt fund with recipient's asset.\n      throwErrorHandler(asset, need, has);\n    };\n  }\n\n  const { selectedUtxos, changeOutputs } = coinSelector(errorHandler)(\n    unspents,\n    [recipient, fee],\n    changeAddressByAsset\n  );\n\n  const outs = [recipient, ...changeOutputs, fee];\n  checkCoinSelect(outs)(selectedUtxos);\n\n  return addToTx(new Psbt({ network }).toBase64(), selectedUtxos, outs);\n}\n\nexport interface BuildTxArgs {\n  psetBase64: string;\n  unspents: UnblindedOutput[];\n  recipients: RecipientInterface[];\n  coinSelector: CoinSelector;\n  changeAddressByAsset: ChangeAddressFromAssetGetter;\n  addFee?: boolean;\n  satsPerByte?: number;\n  errorHandler?: CoinSelectorErrorFn;\n}\n\nexport const DEFAULT_SATS_PER_BYTE = 0.1;\n\nfunction validateAndProcess(args: BuildTxArgs): BuildTxArgs {\n  if (!args.satsPerByte) {\n    args.satsPerByte = DEFAULT_SATS_PER_BYTE;\n  }\n\n  if (!args.errorHandler) {\n    args.errorHandler = throwErrorHandler;\n  }\n\n  if (!args.addFee) {\n    args.addFee = false;\n  }\n\n  if (args.addFee && args.satsPerByte < 0.1) {\n    throw new Error('satsPerByte minimum value is 0.1');\n  }\n\n  if (args.recipients.length === 0) {\n    throw new Error(\n      'need a least one recipient output to build the transaction'\n    );\n  }\n\n  if (args.unspents.length === 0) {\n    throw new Error('need at least one unspent to fund the transaction');\n  }\n\n  return args;\n}\n\n/**\n * buildTx selects utxos among unspents to fill outputs' requirements,\n * then it adds the associated inputs and outputs to the tx.\n * finally it returns the new pset base64 encoded.\n * @param args buildTxArgs wraps arguments\n */\nexport function craftMultipleRecipientsPset(args: BuildTxArgs): string {\n  // validate and deconstruct args object\n  const {\n    changeAddressByAsset,\n    coinSelector,\n    psetBase64,\n    recipients,\n    unspents,\n    addFee,\n    satsPerByte,\n    errorHandler,\n  } = validateAndProcess(args);\n\n  const firstSelection = coinSelector(errorHandler!)(\n    unspents,\n    recipients,\n    changeAddressByAsset\n  );\n\n  // if not fee, just add selected unspents as inputs and specified outputs + change outputs to pset\n  if (!addFee) {\n    const outs = recipients.concat(firstSelection.changeOutputs);\n    checkCoinSelect(outs)(firstSelection.selectedUtxos);\n    return addToTx(psetBase64, firstSelection.selectedUtxos, outs);\n  }\n\n  // otherwise, handle the fee output\n  const fee = createFeeOutputFromPset(\n    psetBase64,\n    firstSelection,\n    recipients,\n    satsPerByte\n  );\n  const { changeOutputs, selectedUtxos } = coinSelector(errorHandler!)(\n    unspents,\n    [...recipients, fee],\n    changeAddressByAsset\n  );\n\n  const outs = [...recipients, ...changeOutputs, fee];\n\n  // check that input amount = output amount and input assets = output assets\n  checkCoinSelect(outs)(selectedUtxos);\n\n  return addToTx(psetBase64, selectedUtxos, outs);\n}\n\nfunction createFeeOutputFromPset(\n  psetBase64: string,\n  firstSelection: CoinSelectionResult,\n  recipients: RecipientInterface[],\n  satsPerByte: number | undefined\n) {\n  const pset = decodePset(psetBase64);\n  const nbInputs =\n    pset.data.inputs.length + firstSelection.selectedUtxos.length + 1;\n  let nbOutputs =\n    pset.data.outputs.length +\n    recipients.length +\n    firstSelection.changeOutputs.length +\n    1;\n\n  const feeAssetHash = laddress.getNetwork(recipients[0].address).assetHash;\n  const fee = createFeeOutput(nbInputs, nbOutputs, satsPerByte!, feeAssetHash);\n  return fee;\n}\n\n// this function create a recipient interface for Fee output using tx size estimation\nexport function createFeeOutput(\n  numInputs: number,\n  numOutputs: number,\n  satsPerByte: number,\n  assetHash: string\n): RecipientInterface {\n  const sizeEstimation = estimateTxSize(numInputs, numOutputs);\n  const feeEstimation = Math.ceil(sizeEstimation * satsPerByte);\n\n  return {\n    asset: assetHash,\n    value: feeEstimation,\n    address: '',\n  };\n}\n\nexport function addToTx(\n  psetBase64: string,\n  unspents: Output[],\n  recipients: RecipientInterface[]\n): string {\n  const pset = decodePset(psetBase64);\n  const nonce = Buffer.alloc(1);\n\n  for (const { asset, value, address } of recipients) {\n    const script =\n      address === '' ? Buffer.alloc(0) : laddress.toOutputScript(address);\n    pset.addOutput({\n      asset: AssetHash.fromHex(asset, false).bytes,\n      value: confidential.satoshiToConfidentialValue(value),\n      script,\n      nonce,\n    });\n  }\n\n  for (const unspent of unspents) {\n    pset.addInput({\n      hash: unspent.txid,\n      index: unspent.vout,\n      witnessUtxo: unspent.prevout,\n    });\n  }\n\n  return pset.toBase64();\n}\n\n// estimate segwit transaction size in bytes depending on number of inputs and outputs\nexport function estimateTxSize(numInputs: number, numOutputs: number): number {\n  const base = calcTxSize(false, numInputs, numOutputs, false);\n  const total = calcTxSize(true, numInputs, numOutputs, true);\n  const weight = base * 3 + total;\n  const vsize = (weight + 3) / 4;\n\n  return vsize;\n}\n\nfunction calcTxSize(\n  withWitness: boolean,\n  numInputs: number,\n  numOutputs: number,\n  isConfidential: boolean\n) {\n  const inputsSize = calcInputsSize(withWitness, numInputs);\n  const outputsSize = calcOutputsSize(isConfidential, numOutputs);\n\n  return (\n    9 +\n    varIntSerializeSize(numOutputs) +\n    varIntSerializeSize(numInputs) +\n    inputsSize +\n    outputsSize\n  );\n}\n\nfunction calcInputsSize(withWitness: boolean, numInputs: number): number {\n  // prevout hash + prevout index\n  let size = (32 + 8) * numInputs;\n  if (withWitness) {\n    // scriptsig + pubkey\n    size += numInputs * (72 + 33);\n  }\n\n  return size;\n}\n\nfunction calcOutputsSize(isConfidential: boolean, numOutputs: number): number {\n  // asset + value + empty nonce\n  const baseOutputSize = 33 + 33 + 1;\n  let size = baseOutputSize * numOutputs;\n\n  if (isConfidential) {\n    // rangeproof + surjectionproof + 32 bytes for nonce\n    size += (4174 + 67 + 32) * numOutputs;\n  }\n\n  // fee asset + fee empty nonce + fee value\n  size += 33 + 1 + 9;\n\n  return size;\n}\n\nfunction varIntSerializeSize(val: number): number {\n  const maxUINT16 = 65535;\n  const maxUINT32 = 4294967295;\n\n  if (val < 0xfd) {\n    return 1;\n  }\n\n  if (val <= maxUINT16) {\n    return 3;\n  }\n\n  if (val <= maxUINT32) {\n    return 5;\n  }\n\n  return 9;\n}\n","import { Psbt } from 'liquidjs-lib';\nimport { CoinSelector } from './coinselection/coinSelector';\nimport {\n  AddressInterface,\n  RecipientInterface,\n  ChangeAddressFromAssetGetter,\n  NetworkString,\n  UnblindedOutput,\n} from './types';\nimport { getNetwork } from './utils';\nimport {\n  craftMultipleRecipientsPset,\n  BuildTxArgs,\n  DEFAULT_SATS_PER_BYTE,\n  craftSingleRecipientPset,\n} from './transaction';\nimport { fetchAndUnblindUtxos } from './explorer/utxos';\nimport { Network } from 'liquidjs-lib/src/networks';\nimport { TinySecp256k1Interface } from 'ecpair';\n\n/**\n * Wallet abstraction.\n */\nexport interface WalletInterface {\n  network: Network;\n  createTx(): string;\n  buildTx(\n    psetBase64: string,\n    recipients: RecipientInterface[],\n    coinSelector: CoinSelector,\n    changeAddressByAsset: ChangeAddressFromAssetGetter,\n    addFee?: boolean,\n    satsPerByte?: number\n  ): string;\n  sendTx(\n    recipient: RecipientInterface,\n    coinSelector: CoinSelector,\n    changeAddressByAsset: ChangeAddressFromAssetGetter,\n    substractFee?: boolean,\n    satsPerByte?: number\n  ): string;\n}\n\n/**\n * Implementation of Wallet Interface.\n * @member network type of network (regtest...)\n * @member addresses list of AddressInterface.\n * @method createTx init empty PSET.\n * @method updateTx update a PSET with outputs and inputs (for Swap tx).\n */\nexport class Wallet implements WalletInterface {\n  network: Network;\n  unspents: UnblindedOutput[];\n\n  constructor(unspents: UnblindedOutput[], network: Network) {\n    this.network = network;\n    this.unspents = unspents;\n  }\n\n  /**\n   * Returns an empty liquidjs lib Psbt instance.\n   */\n  createTx(): string {\n    const pset = new Psbt({ network: this.network });\n    return pset.toBase64();\n  }\n\n  buildTx(\n    psetBase64: string,\n    recipients: RecipientInterface[],\n    coinSelector: CoinSelector,\n    changeAddressByAsset: ChangeAddressFromAssetGetter,\n    addFee?: boolean,\n    satsPerByte?: number\n  ): string {\n    const args: BuildTxArgs = {\n      psetBase64,\n      recipients,\n      coinSelector,\n      changeAddressByAsset,\n      addFee,\n      satsPerByte,\n      unspents: this.unspents,\n    };\n\n    return craftMultipleRecipientsPset(args);\n  }\n\n  sendTx(\n    recipient: RecipientInterface,\n    coinSelector: CoinSelector,\n    changeAddressByAsset: ChangeAddressFromAssetGetter,\n    substractFee = false,\n    satsPerByte = DEFAULT_SATS_PER_BYTE\n  ) {\n    return craftSingleRecipientPset(\n      this.unspents,\n      recipient,\n      coinSelector,\n      changeAddressByAsset,\n      substractFee,\n      satsPerByte\n    );\n  }\n}\n\n/**\n * Factory: list of addresses --to--> Wallet\n * @param addresses a list of addressInterface.\n * @param explorerUrl the esplora endpoint used to fetch addresses's utxos\n * @param network network type\n */\nexport async function walletFromAddresses(\n  ecclib: TinySecp256k1Interface,\n  addresses: AddressInterface[],\n  explorerUrl: string,\n  network?: NetworkString\n): Promise<WalletInterface> {\n  const utxos = await fetchAndUnblindUtxos(ecclib, addresses, explorerUrl);\n  return walletFromCoins(utxos, network);\n}\n\nexport function walletFromCoins(\n  coins: UnblindedOutput[],\n  network?: NetworkString\n): WalletInterface {\n  return new Wallet(coins, getNetwork(network));\n}\n","import { getAsset, Output, getSats } from './types';\nimport { groupBy } from './utils';\n\n/**\n * reduces the set of unspents in order to compute sats grouped by assets.\n * @param unspents the utxos to reduce\n */\nexport function balances(unspents: Output[]): Record<string, number> {\n  const unspentsByAsset = groupBy<Output>(unspents, getAsset);\n  const balances: Record<string, number> = {};\n\n  for (const [asset, utxos] of Object.entries(unspentsByAsset)) {\n    balances[asset] = sumSats(utxos);\n  }\n\n  return balances;\n}\n\nfunction sumSats(unspents: Output[]): number {\n  return unspents.reduce((acc, utxo) => acc + getSats(utxo), 0);\n}\n","import { confidential, address } from 'liquidjs-lib';\nimport { UnblindedOutput } from './types';\nimport { isConfidentialOutput, psetToUnsignedTx } from './utils';\n\n/**\n * iterates through pset's inputs and try to find the prevout blinders.\n * @param pset the unsigned pset to blind\n * @param utxos a set of coins (should contain all the pset prevouts to build the whole map)\n * @returns a map inputIndex => blinders data which can be used as input of blindOutputByIndex.\n */\nexport function inputBlindingDataMap(\n  pset: string,\n  utxos: UnblindedOutput[]\n): Map<number, confidential.UnblindOutputResult> {\n  const inputBlindingData = new Map<number, confidential.UnblindOutputResult>();\n  const txidToBuffer = function(txid: string) {\n    return Buffer.from(txid, 'hex').reverse();\n  };\n\n  let index = -1;\n  for (const input of psetToUnsignedTx(pset).ins) {\n    index++;\n    const utxo = utxos.find(\n      u => txidToBuffer(u.txid).equals(input.hash) && u.vout === input.index\n    );\n\n    // only add unblind data if the prevout of the input is confidential\n    if (utxo && utxo.unblindData && isConfidentialOutput(utxo.prevout)) {\n      inputBlindingData.set(index, utxo.unblindData);\n    }\n  }\n\n  return inputBlindingData;\n}\n\n/**\n * find the blinding public key associated with output script using a set of addresses.\n * @param pset the unsigned pset to blind\n * @param outputAddresses a set of addresses used to craft the pset outputs.\n * @returns the blinding public mapped to output index. Can be used as input in blindOutputByIndex.\n */\nexport function outputBlindingPubkeysMap(\n  pset: string,\n  outputAddresses: string[]\n): Map<number, Buffer> {\n  const outPubkeys: Map<number, Buffer> = new Map();\n\n  for (const outAddress of outputAddresses) {\n    const index = outputIndexFromAddress(pset, outAddress);\n    if (index === -1) continue;\n    if (isConfidentialAddress(outAddress)) {\n      outPubkeys.set(index, blindingKeyFromAddress(outAddress));\n    }\n  }\n\n  return outPubkeys;\n}\n\nfunction outputIndexFromAddress(tx: string, addressToFind: string): number {\n  const utx = psetToUnsignedTx(tx);\n  const recipientScript = address.toOutputScript(addressToFind);\n  return utx.outs.findIndex(out => out.script.equals(recipientScript));\n}\n\nfunction isConfidentialAddress(addr: string): boolean {\n  try {\n    address.fromConfidential(addr);\n    return true;\n  } catch (ignore) {\n    return false;\n  }\n}\n\nfunction blindingKeyFromAddress(addr: string): Buffer {\n  return address.fromConfidential(addr).blindingKey;\n}\n","import axios from 'axios';\nimport { IdentityInterface } from '../identity/identity';\nimport { Multisig } from '../identity/multisig';\nimport { MultisigWatchOnly } from '../identity/multisigWatchOnly';\nimport { MasterPublicKey } from './../identity/masterpubkey';\nimport { Mnemonic } from './../identity/mnemonic';\nimport { Restorer } from './restorer';\n\n// from Esplora\n\nexport const BLOCKSTREAM_ESPLORA_ENDPOINT =\n  'https://blockstream.info/liquid/api';\n\nexport interface EsploraRestorerOpts {\n  esploraURL: string;\n  gapLimit: number;\n}\n\nexport function restorerFromEsplora<R extends IdentityInterface>(\n  identity: R,\n  getAddress: (isChange: boolean, index: number) => string\n): Restorer<EsploraRestorerOpts, R> {\n  return async ({\n    esploraURL = BLOCKSTREAM_ESPLORA_ENDPOINT,\n    gapLimit = 20,\n  }) => {\n    const restoreFunc = async function(\n      getAddrFunc: (index: number) => Promise<string>\n    ): Promise<number | undefined> {\n      let counter = 0;\n      let next = 0;\n      let maxIndex: number | undefined = undefined;\n\n      while (counter < gapLimit) {\n        const cpyNext = next;\n        // generate a set of addresses from next to (next + gapLimit - 1)\n        const addrs = await Promise.all(\n          Array.from(Array(gapLimit).keys())\n            .map(i => i + cpyNext)\n            .map(getAddrFunc)\n        );\n\n        const hasBeenUsedArray = await Promise.all(\n          addrs.map(a => addressHasBeenUsed(a, esploraURL))\n        );\n\n        let indexInArray = 0;\n        for (const hasBeenUsed of hasBeenUsedArray) {\n          if (hasBeenUsed) {\n            maxIndex = indexInArray + next;\n            counter = 0;\n          } else {\n            counter++;\n            if (counter === gapLimit) return maxIndex; // duplicate the stop condition\n          }\n          indexInArray++;\n        }\n\n        next += gapLimit; // increase next\n      }\n\n      return maxIndex;\n    };\n\n    const restorerExternal = restoreFunc((index: number) => {\n      return Promise.resolve(getAddress(false, index));\n    });\n\n    const restorerInternal = restoreFunc((index: number) => {\n      return Promise.resolve(getAddress(true, index));\n    });\n\n    const [lastUsedExternalIndex, lastUsedInternalIndex] = await Promise.all([\n      restorerExternal,\n      restorerInternal,\n    ]);\n\n    return restorerFromState(identity)({\n      lastUsedExternalIndex,\n      lastUsedInternalIndex,\n    });\n  };\n}\n\nasync function addressHasBeenUsed(\n  address: string,\n  esploraURL: string\n): Promise<boolean> {\n  try {\n    const data = (await axios.get(`${esploraURL}/address/${address}/txs`)).data;\n    return data.length > 0;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * build an async esplora restorer for a specific mnemonic\n * @param mnemonicToRestore\n */\nexport function mnemonicRestorerFromEsplora(mnemonicToRestore: Mnemonic) {\n  return restorerFromEsplora<Mnemonic>(\n    mnemonicToRestore,\n    (isChange, index) =>\n      mnemonicToRestore.getAddress(isChange, index).address.confidentialAddress\n  );\n}\n\n/**\n * build an async esplora restorer for a specific masterPubKey\n * @param toRestore\n */\nexport function masterPubKeyRestorerFromEsplora(toRestore: MasterPublicKey) {\n  return restorerFromEsplora<MasterPublicKey>(\n    toRestore,\n    (isChange, index) =>\n      toRestore.getAddress(isChange, index).address.confidentialAddress\n  );\n}\n\n/**\n * build an async esplora restorer for a MultisigWatchOnly\n * @param toRestore\n */\nexport function multisigWatchOnlyFromEsplora(toRestore: MultisigWatchOnly) {\n  return restorerFromEsplora<MultisigWatchOnly>(\n    toRestore,\n    (isChange, index) =>\n      toRestore.getMultisigAddress(\n        isChange\n          ? MultisigWatchOnly.INTERNAL_INDEX\n          : MultisigWatchOnly.EXTERNAL_INDEX,\n        index\n      ).confidentialAddress\n  );\n}\n\n/**\n * build an async esplora restorer for a Multisig\n * @param toRestore\n */\nexport function multisigFromEsplora(toRestore: Multisig) {\n  return restorerFromEsplora<Multisig>(\n    toRestore,\n    (isChange, index) =>\n      toRestore.getMultisigAddress(\n        isChange\n          ? MultisigWatchOnly.INTERNAL_INDEX\n          : MultisigWatchOnly.EXTERNAL_INDEX,\n        index\n      ).confidentialAddress\n  );\n}\n\n// From state\n\nexport interface StateRestorerOpts {\n  lastUsedExternalIndex?: number;\n  lastUsedInternalIndex?: number;\n}\n\nexport function restorerFromState<R extends IdentityInterface>(\n  identity: R\n): Restorer<StateRestorerOpts, R> {\n  return async ({ lastUsedExternalIndex, lastUsedInternalIndex }) => {\n    const promises = [];\n\n    if (lastUsedExternalIndex !== undefined) {\n      for (let i = 0; i <= lastUsedExternalIndex; i++) {\n        const promise = identity.getNextAddress();\n        promises.push(promise);\n      }\n    }\n\n    if (lastUsedInternalIndex !== undefined) {\n      for (let i = 0; i <= lastUsedInternalIndex; i++) {\n        const promise = identity.getNextChangeAddress();\n        promises.push(promise);\n      }\n    }\n\n    await Promise.all(promises);\n\n    return identity;\n  };\n}\n\n/**\n * create a restorer from state for a given mnemonic\n * @param toRestore\n */\nexport function mnemonicRestorerFromState(toRestore: Mnemonic) {\n  return restorerFromState<Mnemonic>(toRestore);\n}\n\n/**\n * create a restorer from state for a given mnemonic\n * @param toRestore\n */\nexport function masterPubKeyRestorerFromState(toRestore: MasterPublicKey) {\n  return restorerFromState<MasterPublicKey>(toRestore);\n}\n","import { script } from 'liquidjs-lib';\nimport { bip341 } from 'liquidjs-lib';\n\n// analyse a script to know what it need as input\nconst { OPS } = script;\n\ninterface SignatureNeed {\n  pubkey: string;\n}\n\n/**\n * Script input need is the object representing the need of inputs for a script\n * The current version can be improved: now it doesn't take into account the order of the inputs\n * `sigs` describes the need of signatures\n * `introspection` is a boolean indicating if the script contains any introspection opcodes\n * `needParameters` is a boolean indicating if the script needs parameters extra parameter (excluding CHECKSIG)\n */\nexport interface ScriptInputsNeeds {\n  sigs: SignatureNeed[];\n  hasIntrospection: boolean;\n  needParameters: boolean;\n}\n\nconst NEED_PARAMS_OPCODES = [\n  OPS.OP_PUSHDATA1,\n  OPS.OP_PUSHDATA2,\n  OPS.OP_PUSHDATA4,\n  OPS.OP_1NEGATE,\n  OPS.OP_RESERVED,\n  OPS.OP_IF,\n  OPS.OP_VERIF,\n  OPS.OP_VERNOTIF,\n  OPS.OP_ELSE,\n  OPS.OP_ENDIF,\n  OPS.OP_VERIFY,\n  OPS.OP_TOALTSTACK,\n  OPS.OP_FROMALTSTACK,\n  OPS.OP_2DROP,\n  OPS.OP_2DUP,\n  OPS.OP_3DUP,\n  OPS.OP_2OVER,\n  OPS.OP_2ROT,\n  OPS.OP_2SWAP,\n  OPS.OP_NIP,\n  OPS.OP_OVER,\n  OPS.OP_PICK,\n  OPS.OP_ROLL,\n  OPS.OP_ROT,\n  OPS.OP_SWAP,\n  OPS.OP_TUCK,\n  OPS.OP_CAT,\n  OPS.OP_SUBSTR,\n  OPS.OP_SUBSTR_LAZY,\n  OPS.OP_LEFT,\n  OPS.OP_RIGHT,\n  OPS.OP_SIZE,\n  OPS.OP_INVERT,\n  OPS.OP_AND,\n  OPS.OP_OR,\n  OPS.OP_XOR,\n  OPS.OP_EQUAL,\n  OPS.OP_EQUALVERIFY,\n  OPS.OP_RESERVED1,\n  OPS.OP_RESERVED2,\n  OPS.OP_1ADD,\n  OPS.OP_1SUB,\n  OPS.OP_2MUL,\n  OPS.OP_2DIV,\n  OPS.OP_NEGATE,\n  OPS.OP_ABS,\n  OPS.OP_NOT,\n  OPS.OP_0NOTEQUAL,\n  OPS.OP_ADD,\n  OPS.OP_SUB,\n  OPS.OP_MUL,\n  OPS.OP_DIV,\n  OPS.OP_MOD,\n  OPS.OP_LSHIFT,\n  OPS.OP_RSHIFT,\n  OPS.OP_BOOLAND,\n  OPS.OP_BOOLOR,\n  OPS.OP_NUMEQUAL,\n  OPS.OP_NUMEQUALVERIFY,\n  OPS.OP_NUMNOTEQUAL,\n  OPS.OP_LESSTHAN,\n  OPS.OP_GREATERTHAN,\n  OPS.OP_LESSTHANOREQUAL,\n  OPS.OP_GREATERTHANOREQUAL,\n  OPS.OP_MIN,\n  OPS.OP_MAX,\n  OPS.OP_WITHIN,\n  OPS.OP_RIPEMD160,\n  OPS.OP_SHA1,\n  OPS.OP_SHA256,\n  OPS.OP_HASH160,\n  OPS.OP_HASH256,\n  OPS.OP_CODESEPARATOR,\n  OPS.OP_CHECKMULTISIG,\n  OPS.OP_CHECKMULTISIGVERIFY,\n  OPS.OP_DETERMINISTICRANDOM,\n  OPS.OP_SHA256INITIALIZE,\n  OPS.OP_SHA256UPDATE,\n  OPS.OP_SHA256FINALIZE,\n  OPS.OP_ADD64,\n  OPS.OP_SUB64,\n  OPS.OP_MUL64,\n  OPS.OP_DIV64,\n  OPS.OP_NEG64,\n  OPS.OP_LESSTHAN64,\n  OPS.OP_LESSTHANOREQUAL64,\n  OPS.OP_GREATERTHAN64,\n  OPS.OP_GREATERTHANOREQUAL64,\n  OPS.OP_SCRIPTNUMTOLE64,\n  OPS.OP_LE64TOSCRIPTNUM,\n  OPS.OP_LE32TOLE64,\n  OPS.OP_ECMULSCALARVERIFY,\n  OPS.OP_TWEAKVERIFY,\n  OPS.OP_PUBKEYHASH,\n  OPS.OP_PUBKEY,\n  OPS.OP_INVALIDOPCODE,\n];\n\nconst INTROSPECTION_OPCODES = [\n  OPS.OP_INSPECTINPUTOUTPOINT,\n  OPS.OP_INSPECTINPUTASSET,\n  OPS.OP_INSPECTINPUTVALUE,\n  OPS.OP_INSPECTINPUTSCRIPTPUBKEY,\n  OPS.OP_INSPECTINPUTSEQUENCE,\n  OPS.OP_INSPECTINPUTISSUANCE,\n  OPS.OP_PUSHCURRENTINPUTINDEX,\n  OPS.OP_INSPECTOUTPUTASSET,\n  OPS.OP_INSPECTOUTPUTVALUE,\n  OPS.OP_INSPECTOUTPUTNONCE,\n  OPS.OP_INSPECTOUTPUTSCRIPTPUBKEY,\n  OPS.OP_INSPECTVERSION,\n  OPS.OP_INSPECTLOCKTIME,\n  OPS.OP_INSPECTNUMINPUTS,\n  OPS.OP_INSPECTNUMOUTPUTS,\n];\n\ntype NeedAnalyserFunction = (\n  stack: Buffer[]\n) => (pos: number) => ScriptInputsNeeds;\n\nfunction validatePosition(stack: Buffer[], pos: number) {\n  return !(pos < 0 || pos >= stack.length);\n}\n\nfunction mergeNeeds(...needs: ScriptInputsNeeds[]): ScriptInputsNeeds {\n  return {\n    sigs: needs.reduce(\n      (acc: ScriptInputsNeeds['sigs'], need) => acc.concat(need.sigs),\n      []\n    ),\n    hasIntrospection: needs.reduce(\n      (acc: ScriptInputsNeeds['hasIntrospection'], need) =>\n        acc || need.hasIntrospection,\n      false\n    ),\n    needParameters: needs.reduce(\n      (acc: ScriptInputsNeeds['needParameters'], need) =>\n        acc || need.needParameters,\n      false\n    ),\n  };\n}\n\nconst needParametersAnalyser: NeedAnalyserFunction = stack => pos => {\n  if (!validatePosition(stack, pos))\n    throw new Error('Invalid position (NEED PARAM OPCODE)');\n  return {\n    sigs: [],\n    hasIntrospection: false,\n    needParameters: true,\n  };\n};\n\nconst introspectionAnalyzer: NeedAnalyserFunction = stack => pos => {\n  if (!validatePosition(stack, pos))\n    throw new Error('invalid position (INTROSPECTION OPCODE)');\n  return {\n    sigs: [],\n    hasIntrospection: true,\n    needParameters: false,\n  };\n};\n\nconst checksigAnalyzer: NeedAnalyserFunction = stack => pos => {\n  if (!validatePosition(stack, pos))\n    throw new Error('invalid position (CHECKSIG)');\n  if (!validatePosition(stack, pos - 1)) {\n    return {\n      sigs: [],\n      hasIntrospection: false,\n      needParameters: true,\n    };\n  }\n\n  const pubkey = stack[pos - 1];\n\n  return {\n    sigs: [{ pubkey: pubkey.toString('hex') }],\n    hasIntrospection: false,\n    needParameters: false,\n  };\n};\n\nconst hex = (n: number) => Buffer.of(n).toString('hex');\n\nconst ANALYZERS_BY_OPCODE = new Map<string, NeedAnalyserFunction>().set(\n  hex(OPS.OP_CHECKSIG),\n  checksigAnalyzer\n);\n\nINTROSPECTION_OPCODES.forEach(op =>\n  ANALYZERS_BY_OPCODE.set(hex(op), introspectionAnalyzer)\n);\nNEED_PARAMS_OPCODES.forEach(op =>\n  ANALYZERS_BY_OPCODE.set(hex(op), needParametersAnalyser)\n);\n\nfunction decompileScript(b: Buffer): Buffer[] {\n  const stack = script.decompile(b);\n  if (stack === null) throw new Error('malformed script');\n  return stack?.map(s => (Buffer.isBuffer(s) ? s : Buffer.of(s))) ?? [];\n}\n\n/**\n * Analyze a script to know what it need as input\n * @param scriptHex must be a valid Elements script\n * @returns an object describing how to build the script inputs\n */\nexport function analyse(scriptHex: string): ScriptInputsNeeds {\n  const scriptBuffer = Buffer.from(scriptHex, 'hex');\n  const stack = decompileScript(scriptBuffer);\n\n  let needs: ScriptInputsNeeds = {\n    sigs: [],\n    hasIntrospection: false,\n    needParameters: false,\n  };\n\n  for (let i = 0; i < stack.length; i++) {\n    const elem = stack[i].toString('hex');\n    const analyser = ANALYZERS_BY_OPCODE.get(elem);\n    if (!analyser) continue;\n    needs = mergeNeeds(needs, analyser(stack)(i));\n  }\n\n  return needs;\n}\n\nexport function analyzeTapscriptTree(\n  tree?: bip341.HashTree\n): Record<string, ScriptInputsNeeds> {\n  if (!tree) return {};\n  const children = {\n    ...(tree.left ? analyzeTapscriptTree(tree.left) : {}),\n    ...(tree.right ? analyzeTapscriptTree(tree.right) : {}),\n  };\n\n  if (tree.scriptHex)\n    return { ...children, [tree.scriptHex]: analyse(tree.scriptHex) };\n  return children;\n}\n","import { bip341 } from 'liquidjs-lib';\n\nexport enum TypeAST {\n  SCRIPT = 0, // one of ScriptType\n  TREE, // {asm(...)|TREE,asm(...)|TREE}\n  HEX, // ? bits hex\n  KEY, // 64 bits hex\n}\n\nexport enum ScriptType {\n  ELTR = 'eltr', // eltr(KEY, TREE)\n  ASM = 'asm', // asm(STRING)\n  RAW = 'raw', // raw(HEX)\n}\n\nconst numOfChildren = new Map<ScriptType, number>()\n  .set(ScriptType.ELTR, 2)\n  .set(ScriptType.ASM, 1)\n  .set(ScriptType.RAW, 1);\n\n// Abstract syntax tree\nexport interface AST<V = any> {\n  type: TypeAST;\n  value: V;\n  children: AST[];\n}\n\nexport interface DescriptorsCompilerAPI {\n  compile: (ast: AST) => TemplateResult;\n}\n\n// (template string, context) --parser--> AST --compiler--> Result object\nexport interface TemplateResult {\n  scriptPubKey(): Buffer; // the address' script\n  redeemScript?(): Buffer; // optional, only if needed to spend the scriptPubKey (e.g. for P2SH, P2WSH, P2WSH-P2SH...)\n  // optional, returns witnesses needed to spend the scriptPubKey\n  // in case of segwit v0 = [redeemScript()]\n  // in case of segwit v1 = [leafScript, taprootControlBlock]\n  witnesses?(...args: any[]): Buffer[];\n  taprootHashTree?: bip341.HashTree; // optional, should be undefined if not an eltr template\n  taprootInternalKey?: string; // optional, should be undefined if not an eltr template\n}\n\nconst withoutEccCompilers = new Map([\n  [ScriptType.RAW, compileRAW],\n  [ScriptType.ASM, compileASM],\n]);\n\nfunction compileFromEcc(ecc: bip341.TinySecp256k1Interface) {\n  // map cmd to compile functions\n  const compilers = withoutEccCompilers.set(\n    ScriptType.ELTR,\n    makeCompileELTR(bip341.BIP341Factory(ecc))\n  );\n\n  return (ast: AST): TemplateResult => {\n    return compileScript(ast, compilers, true);\n  };\n}\n\nexport const DescriptorsCompilerFactory = (\n  ecc: bip341.TinySecp256k1Interface\n): DescriptorsCompilerAPI => {\n  return {\n    compile: compileFromEcc(ecc),\n  };\n};\n\nfunction checkScriptNode(ast: AST, scriptType: ScriptType): void {\n  if (ast.type !== TypeAST.SCRIPT) {\n    throw new Error('Expected script node');\n  }\n\n  if (ast.value !== scriptType) {\n    throw new Error(`Expected ${scriptType} script`);\n  }\n\n  if (ast.children.length !== numOfChildren.get(ast.value)) {\n    throw new Error(\n      `Expected script node ${ast.type} with ${numOfChildren.get(\n        ast.value\n      )} of children`\n    );\n  }\n}\n\nfunction compileHEX(ast: AST): TemplateResult {\n  if (ast.type !== TypeAST.HEX) {\n    throw new Error('Expected hex node');\n  }\n\n  if (typeof ast.value !== 'string')\n    throw new Error('Expected hex node with string value');\n  const script = Buffer.from(ast.value, 'hex');\n  return {\n    scriptPubKey: () => script,\n  };\n}\n\n// 'raw' node\nfunction compileRAW(ast: AST): TemplateResult {\n  checkScriptNode(ast, ScriptType.RAW);\n  return compileHEX(ast.children[0]);\n}\n\n// 'asm' node, which is a subset of raw\nfunction compileASM(ast: AST): TemplateResult {\n  checkScriptNode(ast, ScriptType.ASM);\n  return compileHEX(ast.children[0]);\n}\n\n// this is not a ScriptCompileFunction\n// recursive way to get all the leaves of the tree\nfunction compileTREE(ast: AST): bip341.TaprootLeaf[] {\n  if (ast.type !== TypeAST.TREE) {\n    throw new Error('Expected tree node');\n  }\n\n  const leaves: bip341.TaprootLeaf[] = [];\n  if (ast.children.length < 1 || ast.children.length > 2) {\n    throw new Error('Expected tree node with 1 or 2 leaves');\n  }\n\n  for (const child of ast.children) {\n    switch (child.type) {\n      case TypeAST.SCRIPT:\n        leaves.push({\n          scriptHex: compileScript(child, withoutEccCompilers) // we do not expect any toplevel compilers so we can use withoutEccCompilers\n            .scriptPubKey()\n            .toString('hex'),\n        });\n        break;\n      case TypeAST.TREE:\n        leaves.push(...compileTREE(child));\n        break;\n      default:\n        throw new Error(\n          `Expected tree node with children of type ${TypeAST.SCRIPT} or ${TypeAST.TREE}`\n        );\n    }\n  }\n\n  return leaves;\n}\n\nfunction compileKEY(ast: AST): Buffer {\n  if (ast.type !== TypeAST.KEY) {\n    throw new Error('Expected key node');\n  }\n\n  if (typeof ast.value !== 'string' && ast.value.length === 64)\n    throw new Error('Expected key (64 hex chars)');\n  return Buffer.from(ast.value, 'hex');\n}\n\nfunction makeCompileELTR(bip341lib: bip341.BIP341API) {\n  return function(ast: AST): TemplateResult {\n    checkScriptNode(ast, ScriptType.ELTR);\n\n    if (ast.children[0].type !== TypeAST.KEY) {\n      throw new Error('Expected KEY as first argument of eltr');\n    }\n\n    if (ast.children[1].type !== TypeAST.TREE) {\n      throw new Error('Expected TREE as second argument of eltr');\n    }\n\n    const internalKey = compileKEY(ast.children[0]);\n    const leaves = compileTREE(ast.children[1]);\n\n    const tree = bip341.toHashTree(leaves, true);\n    // this is a trick for the bip341 functions (accept only prefixed keys)\n    const prefixedInternalKey = Buffer.concat([Buffer.of(0x00), internalKey]);\n\n    // segwit v1 scriptPubKey\n    const scriptPubKey = bip341lib.taprootOutputScript(\n      prefixedInternalKey,\n      tree\n    );\n\n    return {\n      witnesses: (leafScript: string): Buffer[] => {\n        const leaf = leaves.find(l => l.scriptHex === leafScript);\n        if (!leaf) {\n          throw new Error(\n            'Could not find leaf script for script ' + leafScript\n          );\n        }\n\n        const path = bip341.findScriptPath(tree, bip341.tapLeafHash(leaf));\n        return bip341lib.taprootSignScriptStack(\n          prefixedInternalKey,\n          leaf,\n          tree.hash,\n          path\n        );\n      },\n      scriptPubKey: () => scriptPubKey,\n      taprootHashTree: tree,\n      taprootInternalKey: internalKey.toString('hex'),\n    };\n  };\n}\n\nconst topLevelOnly = [ScriptType.RAW, ScriptType.ELTR];\n\ntype CompilersMap = Map<ScriptType, ScriptCompileFunction>;\ntype ScriptCompileFunction = (ast: AST) => TemplateResult;\n\n// main compile function\nfunction compileScript(\n  ast: AST,\n  compilersMap: CompilersMap,\n  isTop = false\n): TemplateResult {\n  const compileFunction = compilersMap.get(ast.value);\n  if (!compileFunction) {\n    throw new Error(`node type: ${ast.type} is not a descriptor`);\n  }\n\n  if (!isTop && topLevelOnly.includes(ast.value)) {\n    throw new Error(`node type: ${ast.value} is a top level only descriptor`);\n  }\n\n  return compileFunction(ast);\n}\n","const hexRegExp = /^([A-Fa-f0-9]{2})+/;\n\nexport function readHex(text: string): [string, string] {\n  return readWithRegExp(hexRegExp, text);\n}\n\nfunction readWithRegExp(regexp: RegExp, text: string): [string, string] {\n  const match = text.match(regexp);\n  if (!match) {\n    return ['', text];\n  }\n  return [match[0], text.slice(match[0].length)];\n}\n\nexport function readUntil(text: string, char: string): [string, string] {\n  const index = text.indexOf(char);\n  if (index === -1) {\n    throw new Error(`Expected ${char}`);\n  }\n  return [text.slice(0, index), text.slice(index)];\n}\n","import { script } from 'liquidjs-lib';\nimport { ScriptType, TypeAST, AST } from './ast';\nimport { readHex, readUntil } from './utils';\n\nconst EXPECT_TOKEN = (token: string, got: string) =>\n  new Error(`Expected \"${token}\" got \"${got}\"`);\n\nfunction cmd(type: ScriptType): string {\n  return type.toString();\n}\n\ntype Parser = (text: string) => [AST | undefined, string];\n\nfunction compose(...parsers: Parser[]): Parser {\n  return (text: string) => {\n    let result: AST | undefined;\n    let remainingText = text.trimStart();\n    for (const parser of parsers) {\n      const [child, text] = parser(remainingText);\n      if (child) {\n        if (result) {\n          result.children.push(child);\n        } else {\n          result = child;\n        }\n      }\n      remainingText = text.trimStart();\n    }\n\n    return [result, remainingText];\n  };\n}\n\nfunction oneOf(...parsers: Parser[]): Parser {\n  const errors: Error[] = [];\n  return (text: string) => {\n    for (const parser of parsers) {\n      try {\n        return parser(text);\n      } catch (e) {\n        // ignore\n        if (e instanceof Error) {\n          errors.push(e);\n        }\n      }\n    }\n\n    throw new Error(`one of: ${errors.map(e => e.message).join(', ')}`);\n  };\n}\n\nconst parseHEX: Parser = (text: string) => {\n  const [hex, remainingText] = readHex(text);\n  return [{ type: TypeAST.HEX, value: hex, children: [] }, remainingText];\n};\n\nconst parseKEY: Parser = (text: string) => {\n  const [hex, remainingText] = readHex(text);\n  if (hex.length !== 64) {\n    throw EXPECT_TOKEN('key (hex string with len=64)', hex);\n  }\n\n  return [{ type: TypeAST.KEY, value: hex, children: [] }, remainingText];\n};\n\nconst parseASMScript: Parser = (text: string) => {\n  const [str, remainingText] = readUntil(text, ')');\n  const asmScript = script.fromASM(str);\n  return [\n    { type: TypeAST.HEX, value: asmScript.toString('hex'), children: [] },\n    remainingText,\n  ];\n};\n\n// parse a token, does not create any AST node\nconst parseToken = (token: string): Parser => (text: string) => {\n  if (text.startsWith(token)) {\n    return [undefined, text.slice(token.length)];\n  }\n\n  throw EXPECT_TOKEN(token, text.slice(0, token.length));\n};\n\nconst parseTreeToken: Parser = (text: string) => {\n  const [, remainingText] = parseToken('{')(text);\n  return [\n    { type: TypeAST.TREE, value: undefined, children: [] },\n    remainingText,\n  ];\n};\n\nconst parseEndTreeToken = parseToken('}');\n\n// tree parser\nconst parseTREE: Parser = (text: string) => {\n  if (text.startsWith('{')) {\n    return compose(\n      parseTreeToken,\n      parseTREE,\n      oneOf(\n        compose(parseComma, parseTREE, parseEndTreeToken),\n        parseEndTreeToken\n      )\n    )(text);\n  }\n\n  return parseSCRIPT(text);\n};\n\nconst parseScriptToken = (type: ScriptType): Parser => (text: string) => {\n  const res = compose(parseToken(cmd(type)), parseToken('('))(text);\n  return [{ type: TypeAST.SCRIPT, value: type, children: [] }, res[1]];\n};\n\nconst parseEndCmd = parseToken(')');\nconst parseComma = parseToken(',');\n\nexport const parseSCRIPT: Parser = (text: string) => {\n  return oneOf(parseASM, parseRAW, parseELTR)(text);\n};\n\nconst parseRAW = compose(\n  parseScriptToken(ScriptType.RAW), // raw(\n  parseHEX, // hex of any length\n  parseEndCmd // ')'\n);\n\nconst parseELTR = compose(\n  parseScriptToken(ScriptType.ELTR), // eltr(\n  parseKEY, // 64 hex chars\n  parseComma, // ','\n  parseTREE, // TREE\n  parseEndCmd // ')'\n);\n\nconst parseASM = compose(\n  parseScriptToken(ScriptType.ASM), // asm(\n  parseASMScript, // opcodes\n  parseEndCmd // ')'\n);\n","const namespaceRegexp = new RegExp('[$][a-zA-Z0-9|@_.-]+', 'g');\n\nexport interface Context {\n  // map namespace token to public key\n  namespaces: Map<string, { pubkey: string }>;\n}\n\nfunction replaceAll(str: string, find: string, replace: string): string {\n  return str.split(find).join(replace);\n}\n\nexport function findNamespaces(text: string): Array<string> {\n  const namespaces = Array.from(new Set(text.match(namespaceRegexp)));\n  if (!namespaces) return [];\n  return namespaces.map(n => n.slice(1)); // remove the '$' token\n}\n\nexport function processNamespaces(\n  ctx: Context['namespaces'],\n  text: string\n): string {\n  const namespaces = findNamespaces(text);\n  if (!namespaces.length) return text;\n\n  let processedText = text;\n  for (const namespace of namespaces) {\n    const namespacePublicKey = ctx.get(namespace)?.pubkey;\n    if (!namespacePublicKey)\n      throw new Error(`Could not find namespace context: ${namespace}`);\n    processedText = replaceAll(\n      processedText,\n      '$' + namespace,\n      namespacePublicKey\n    );\n  }\n\n  return processedText;\n}\n\nexport function preprocessor(ctx: Context, text: string): string {\n  return processNamespaces(ctx.namespaces, text);\n}\n","import { bip341 } from 'liquidjs-lib';\nimport { DescriptorsCompilerFactory, TemplateResult } from './ast';\nimport { parseSCRIPT } from './parser';\nimport { Context, findNamespaces, preprocessor } from './preprocessing';\nexport { Context, TemplateResult };\n\n/**\n * evaluate a template string and return witness scripts and redeem script associated with it\n * @param ctx used to replace xpubs with their current derivated public keys\n * @param template the string to evaluate\n **/\n\nexport function makeEvaluateDescriptor(ecc: bip341.TinySecp256k1Interface) {\n  const compile = DescriptorsCompilerFactory(ecc).compile;\n  return function(ctx: Context, template: string): TemplateResult {\n    const processedTemplate = preprocessor(ctx, template);\n    const [ast] = parseSCRIPT(processedTemplate);\n    if (!ast) throw new Error('Failed to parse template');\n    return compile(ast);\n  };\n}\n\n/**\n * validate can be used without a context object to validate the parsability of a template string\n * @param template the template string to validate\n * @returns true if template is OK, false otherwise\n */\nexport function validate(template: string): boolean {\n  const namespaces = findNamespaces(template);\n  if (namespaces.length > 0) {\n    const fakeKey = Buffer.alloc(32).toString('hex');\n    const fakeCtx: Context = {\n      namespaces: new Map(),\n    };\n\n    for (const namespace of namespaces) {\n      fakeCtx.namespaces.set(namespace, { pubkey: fakeKey });\n    }\n\n    template = preprocessor(fakeCtx, template);\n  }\n  try {\n    const [ast] = parseSCRIPT(template);\n    if (!ast) return false;\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n","import { ChainAPI } from '../explorer/api';\nimport { IdentityInterface } from '../identity/identity';\nimport { Mnemonic } from '../identity/mnemonic';\nimport { restorerFromState } from './mnemonic-restorer';\nimport { Restorer } from './restorer';\n\nfunction makeRestorerFromChainAPI<T extends IdentityInterface>(\n  id: T,\n  getAddress: (isChange: boolean, index: number) => string\n): Restorer<{ api: ChainAPI; gapLimit: number }, IdentityInterface> {\n  return async ({ gapLimit, api }) => {\n    const restoreFunc = async function(\n      getAddrFunc: (index: number) => Promise<string>\n    ): Promise<number | undefined> {\n      let counter = 0;\n      let next = 0;\n      let maxIndex: number | undefined = undefined;\n\n      while (counter < gapLimit) {\n        const cpyNext = next;\n        // generate a set of addresses from next to (next + gapLimit - 1)\n        const addrs = await Promise.all(\n          Array.from(Array(gapLimit).keys())\n            .map(i => i + cpyNext)\n            .map(getAddrFunc)\n        );\n\n        const hasBeenUsedArray = await api.addressesHasBeenUsed(addrs);\n\n        let indexInArray = 0;\n        for (const hasBeenUsed of hasBeenUsedArray) {\n          if (hasBeenUsed) {\n            maxIndex = indexInArray + next;\n            counter = 0;\n          } else {\n            counter++;\n            if (counter === gapLimit) return maxIndex; // duplicate the stop condition\n          }\n          indexInArray++;\n        }\n\n        next += gapLimit; // increase next\n      }\n\n      return maxIndex;\n    };\n    const restorerExternal = restoreFunc((index: number) => {\n      return Promise.resolve(getAddress(false, index));\n    });\n\n    const restorerInternal = restoreFunc((index: number) => {\n      return Promise.resolve(getAddress(true, index));\n    });\n\n    const [lastUsedExternalIndex, lastUsedInternalIndex] = await Promise.all([\n      restorerExternal,\n      restorerInternal,\n    ]);\n\n    return restorerFromState(id)({\n      lastUsedExternalIndex,\n      lastUsedInternalIndex,\n    });\n  };\n}\n\nexport function mnemonicRestorerFromChain(mnemonicToRestore: Mnemonic) {\n  return makeRestorerFromChainAPI<Mnemonic>(\n    mnemonicToRestore,\n    (isChange, index) =>\n      mnemonicToRestore.getAddress(isChange, index).address.confidentialAddress\n  );\n}\n"],"names":["runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","ZERO","Buffer","alloc","emptyNonce","from","bufferNotEmptyOrNull","buffer","isConfidentialOutput","surjectionProof","nonce","rangeProof","BufferMap","map","Map","bufferToStringPrimitive","toString","valueOf","get","set","Array","prefixes","changeVersionBytes","xpub","targetFormat","has","trim","data","b58","decode","concat","encode","toXpub","anyPub","IdentityType","extendedPubKeyRegexp","masterBlindKeyRegexp","isValidXpub","test","isValidExtendedBlindKey","masterBlind","psetToUnsignedHex","psetBase64","pset","Psbt","fromBase64","ignore","globalMap","unsignedTx","toBuffer","psetToUnsignedTx","ptx","Transaction","fromHex","getNetwork","str","networks","liquid","unblindOutput","utxo","blindPrivKey","prevout","unblindData","asset","confidential","confidentialValueToSatoshi","assetBlindingFactor","valueBlindingFactor","unblindOutputWithKey","checkIdentityType","actual","expect","checkMnemonic","mnemonic","language","setDefaultWordlist","validateMnemonic","decodePset","groupBy","xs","reduce","rv","x","k","row","isUnblindedOutput","output","getSats","parseInt","getAsset","Identity","args","chain","network","ecclib","blindPsetWithBlindKeysGetter","getBlindingKeyPair","outputsToBlind","outputsPubKeys","inputsBlindingDataLike","inputsData","outputsKeys","transaction","index","pubKey","outs","script","publicKey","inputs","input","witnessUtxo","nonWitnessUtxo","vout","ins","witness","fromBuffer","privKey","privateKey","blindOutputsByIndex","ECCKeysGenerator","toBase64","MasterPublicKey","INITIAL_INDEX","opts","masterPublicKey","masterBlindingKey","masterPublicKeyNode","BIP32Factory","fromBase58","masterBlindingKeyNode","SLIP77Factory","fromMasterBlindingKey","baseDerivationPath","INITIAL_BASE_PATH","blindPset","_this2","isAbleToSign","derivePublicKeyWithIndex","isChange","derive","scriptPubKey","checkScript","scriptToAddressCache","scriptFromPublicKey","payments","p2wpkh","pubkey","createConfidentialAddress","signingPublicKey","blindingPublicKey","blindkey","confidentialAddress","persistAddressToCache","address","publicKeyBuffer","getAddress","blindingKeyPair","path","blindingPrivateKey","derivationPath","getNextAddress","addr","getNextChangeAddress","changeIndex","getBlindingPrivateKey","signPset","_","getAddresses","addrExtended","getXPub","toBase58","Mnemonic","bip39","walletSeed","passphrase","masterPrivateKeyNode","fromSeed","derivePath","neutered","masterKey","wif","toWIF","ECPairFactory","fromWIF","signInputPromises","addressGeneration","privateKeyBuffer","signingKeyPair","fromPrivateKey","signInputAsync","all","Random","randomMnemonic","PrivateKey","_this","decodeFromWif","signingKeyWIF","blindingKeyWIF","equals","indexOfInputs","_this3","BrowserInject","Inject","window","windowProvider","provider","signTransaction","__","___","____","xor","a","b","bip67sort","array","sort","bip67compareFunction","MultisigWatchOnly","required","cosignersLength","checkRequiredSignature","requiredSignatures","cosigners","seed","cosignersPublicKeys","cosigner","mnemonicToSeedSync","bip32","baseNode","fromPublicKey","chainCode","cosignerToXPub","blindingKeyMasterNode","chainCodes","prefix","chainCodesXOR","crypto","sha256","blindingKeyFromChainCode","getMultisigAddress","EXTERNAL_INDEX","nextIndex","INTERNAL_INDEX","nextChangeIndex","externals","internals","outputsIndexToBlind","outputsPubKeysByIndex","change","blindingKey","multisigPayment","p2wsh","redeem","p2ms","m","pubkeys","toOutputScript","witnessScript","p2msPayment","Multisig","signer","scriptToPath","toScript","throwErrorHandler","need","recipientsReducer","results","makeAssetFilter","assetToFilter","u","checkCoinSelect","recipients","selectedUtxos","check","outputs","groupByAsset","inputsByAsset","outputsByAsset","inputsAssets","outputsAssets","every","includes","sumInputs","sumNumbers","sumOutputs","acc","current","defaultCompareFn","fetchTxHex","txId","url","axios","esploraTxToTxInterface","fetchUtxos","outpointToUtxo","esploraURL","outpoint","txid","esploraTx","explorerUrl","inputTxIds","inputVouts","vin","is_pegin","prevoutAsOutput","hex","makeOutput","txInputs","isPegin","makeOutpoint","txOutputs","txout","fee","status","confirmed","blockHash","block_hash","blockHeight","block_height","blockTime","block_time","txOutput","makeUnblindURL","baseURL","txID","outputsBlinder","valueBlinder","assetBlinder","join","UnblindError","_Error","fetchAndUnblindTxsGenerator","addresses","blindingKeyGetter","skip","txIDs","errors","txsGenerator","fetchTxsGenerator","txIterator","tx","unblindTransaction","unblindedTx","_context2","txs","lastSeenTxid","newTxs","numberOfTxs","fetch25newestTxsForAddress","blindingPrivateKeyGetter","promises","inputIndex","promise","outputIndex","fetchAndUnblindUtxosGenerator","addressesAndBlindingKeys","numberOfUtxos","addressPublicKey","fromConfidential","blindedUtxo","tryToUnblindUtxo","_context","fetchAndUnblindUtxos","utxosGenerator","utxos","utxosFetchGenerator","api","privateBlindingKey","unblindedUtxo","console","log","txsFetchGenerator","fetchTxs","Electrs","axiosIns","electrsURL","fromURL","addressesHasBeenUsed","reqs","allSettled","resolvedResponses","r","flat","filter","fetchAllTxsForAddress","ids","fetchTxsHex","txids","_this4","fetchTx","_this5","_this6","nextTxs","_this7","ElectrsBatchServer","batchServerURL","fromURLs","electrsUrl","post","response","isArray","_this9","fetchTxFn","transactions","makePrevout","find","t","txHex","_transactions$find","craftSingleRecipientPset","unspents","recipient","coinSelector","changeAddressByAsset","substractFeeFromRecipient","satsPerByte","DEFAULT_SATS_PER_BYTE","laddress","substractScenario","assetHash","firstSelection","createFeeOutput","changeOutputs","errorHandler","addToTx","craftMultipleRecipientsPset","addFee","validateAndProcess","createFeeOutputFromPset","numInputs","numOutputs","sizeEstimation","estimateTxSize","Math","ceil","addOutput","AssetHash","bytes","satoshiToConfidentialValue","unspent","addInput","hash","calcTxSize","withWitness","isConfidential","inputsSize","size","calcInputsSize","outputsSize","calcOutputsSize","varIntSerializeSize","val","Wallet","createTx","buildTx","sendTx","substractFee","walletFromCoins","coins","sumSats","outputIndexFromAddress","addressToFind","utx","recipientScript","findIndex","out","isConfidentialAddress","restorerFromEsplora","identity","gapLimit","restorerExternal","restoreFunc","getAddrFunc","counter","maxIndex","cpyNext","addrs","addressHasBeenUsed","indexInArray","restorerInternal","lastUsedExternalIndex","lastUsedInternalIndex","restorerFromState","OPS","NEED_PARAMS_OPCODES","OP_PUSHDATA1","OP_PUSHDATA2","OP_PUSHDATA4","OP_1NEGATE","OP_RESERVED","OP_IF","OP_VERIF","OP_VERNOTIF","OP_ELSE","OP_ENDIF","OP_VERIFY","OP_TOALTSTACK","OP_FROMALTSTACK","OP_2DROP","OP_2DUP","OP_3DUP","OP_2OVER","OP_2ROT","OP_2SWAP","OP_NIP","OP_OVER","OP_PICK","OP_ROLL","OP_ROT","OP_SWAP","OP_TUCK","OP_CAT","OP_SUBSTR","OP_SUBSTR_LAZY","OP_LEFT","OP_RIGHT","OP_SIZE","OP_INVERT","OP_AND","OP_OR","OP_XOR","OP_EQUAL","OP_EQUALVERIFY","OP_RESERVED1","OP_RESERVED2","OP_1ADD","OP_1SUB","OP_2MUL","OP_2DIV","OP_NEGATE","OP_ABS","OP_NOT","OP_0NOTEQUAL","OP_ADD","OP_SUB","OP_MUL","OP_DIV","OP_MOD","OP_LSHIFT","OP_RSHIFT","OP_BOOLAND","OP_BOOLOR","OP_NUMEQUAL","OP_NUMEQUALVERIFY","OP_NUMNOTEQUAL","OP_LESSTHAN","OP_GREATERTHAN","OP_LESSTHANOREQUAL","OP_GREATERTHANOREQUAL","OP_MIN","OP_MAX","OP_WITHIN","OP_RIPEMD160","OP_SHA1","OP_SHA256","OP_HASH160","OP_HASH256","OP_CODESEPARATOR","OP_CHECKMULTISIG","OP_CHECKMULTISIGVERIFY","OP_DETERMINISTICRANDOM","OP_SHA256INITIALIZE","OP_SHA256UPDATE","OP_SHA256FINALIZE","OP_ADD64","OP_SUB64","OP_MUL64","OP_DIV64","OP_NEG64","OP_LESSTHAN64","OP_LESSTHANOREQUAL64","OP_GREATERTHAN64","OP_GREATERTHANOREQUAL64","OP_SCRIPTNUMTOLE64","OP_LE64TOSCRIPTNUM","OP_LE32TOLE64","OP_ECMULSCALARVERIFY","OP_TWEAKVERIFY","OP_PUBKEYHASH","OP_PUBKEY","OP_INVALIDOPCODE","INTROSPECTION_OPCODES","OP_INSPECTINPUTOUTPOINT","OP_INSPECTINPUTASSET","OP_INSPECTINPUTVALUE","OP_INSPECTINPUTSCRIPTPUBKEY","OP_INSPECTINPUTSEQUENCE","OP_INSPECTINPUTISSUANCE","OP_PUSHCURRENTINPUTINDEX","OP_INSPECTOUTPUTASSET","OP_INSPECTOUTPUTVALUE","OP_INSPECTOUTPUTNONCE","OP_INSPECTOUTPUTSCRIPTPUBKEY","OP_INSPECTVERSION","OP_INSPECTLOCKTIME","OP_INSPECTNUMINPUTS","OP_INSPECTNUMOUTPUTS","validatePosition","stack","pos","mergeNeeds","needs","sigs","hasIntrospection","needParameters","TypeAST","ScriptType","needParametersAnalyser","introspectionAnalyzer","checksigAnalyzer","n","of","ANALYZERS_BY_OPCODE","OP_CHECKSIG","analyse","scriptHex","decompile","s","isBuffer","decompileScript","elem","analyser","op","numOfChildren","ELTR","ASM","RAW","withoutEccCompilers","ast","checkScriptNode","compileHEX","children","compileFromEcc","ecc","bip341lib","compilers","bip341","BIP341Factory","KEY","TREE","internalKey","compileKEY","leaves","compileTREE","child","SCRIPT","compileScript","tree","toHashTree","prefixedInternalKey","taprootOutputScript","witnesses","leafScript","leaf","l","findScriptPath","tapLeafHash","taprootSignScriptStack","taprootHashTree","taprootInternalKey","scriptType","HEX","topLevelOnly","compilersMap","isTop","compileFunction","hexRegExp","readHex","text","regexp","match","readWithRegExp","EXPECT_TOKEN","token","got","compose","parsers","remainingText","trimStart","parser","oneOf","e","message","parseHEX","parseKEY","parseASMScript","char","indexOf","readUntil","asmScript","fromASM","parseToken","startsWith","parseTreeToken","parseEndTreeToken","parseTREE","parseComma","parseSCRIPT","parseScriptToken","res","cmd","parseEndCmd","parseASM","parseRAW","parseELTR","namespaceRegexp","RegExp","findNamespaces","namespaces","Set","preprocessor","ctx","replace","processedText","namespace","namespacePublicKey","_ctx$get","split","processNamespaces","analyzeTapscriptTree","left","right","unspentsByAsset","balances","entries","xub","derivationPathSplitted","outputsData","reverseHex","blinder","sortFn","compareFn","coinSelectFn","toSelect","selectors","coinSelectorFilter","amount","amtSelected","selected","coinSelectUtxosFilter","flatMap","fnSelect","changeAddressGetter","makeChangesFn","changeAmount","sum","sumUtxos","diff","makeChanges","recipientsMap","reduceRecipients","inputBlindingData","Number","isSafeInteger","compile","DescriptorsCompilerFactory","template","processedTemplate","toRestore","mnemonicToRestore","id","outputAddresses","outPubkeys","outAddress","walletScripts","initialState","orInfinity","Infinity","compareBlockHeight","compareVin","utxoSet","walletOutputs","o","addOutputsToUtxos","removeInputsFromUtxos","fakeKey","fakeCtx"],"mappings":"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"}